
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Stock
 * 
 */
export type Stock = $Result.DefaultSelection<Prisma.$StockPayload>
/**
 * Model Genus
 * 
 */
export type Genus = $Result.DefaultSelection<Prisma.$GenusPayload>
/**
 * Model Species
 * 
 */
export type Species = $Result.DefaultSelection<Prisma.$SpeciesPayload>
/**
 * Model SpeciesImage
 * 
 */
export type SpeciesImage = $Result.DefaultSelection<Prisma.$SpeciesImagePayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Plant
 * 
 */
export type Plant = $Result.DefaultSelection<Prisma.$PlantPayload>
/**
 * Model Agrochemical
 * 
 */
export type Agrochemical = $Result.DefaultSelection<Prisma.$AgrochemicalPayload>
/**
 * Model FertilizationProgram
 * 
 */
export type FertilizationProgram = $Result.DefaultSelection<Prisma.$FertilizationProgramPayload>
/**
 * Model FertilizationCycle
 * 
 */
export type FertilizationCycle = $Result.DefaultSelection<Prisma.$FertilizationCyclePayload>
/**
 * Model FertilizationTask
 * 
 */
export type FertilizationTask = $Result.DefaultSelection<Prisma.$FertilizationTaskPayload>
/**
 * Model PhytosanitaryProgram
 * 
 */
export type PhytosanitaryProgram = $Result.DefaultSelection<Prisma.$PhytosanitaryProgramPayload>
/**
 * Model PhytosanitaryCycle
 * 
 */
export type PhytosanitaryCycle = $Result.DefaultSelection<Prisma.$PhytosanitaryCyclePayload>
/**
 * Model PhytosanitaryTask
 * 
 */
export type PhytosanitaryTask = $Result.DefaultSelection<Prisma.$PhytosanitaryTaskPayload>
/**
 * Model IrrigationProgram
 * 
 */
export type IrrigationProgram = $Result.DefaultSelection<Prisma.$IrrigationProgramPayload>
/**
 * Model IrrigationTask
 * 
 */
export type IrrigationTask = $Result.DefaultSelection<Prisma.$IrrigationTaskPayload>
/**
 * Model SensorReading
 * 
 */
export type SensorReading = $Result.DefaultSelection<Prisma.$SensorReadingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  User: 'User',
  Admin: 'Admin'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ZoneType: {
  Zona_A: 'Zona_A',
  Zona_B: 'Zona_B',
  Zona_C: 'Zona_C',
  Zona_D: 'Zona_D'
};

export type ZoneType = (typeof ZoneType)[keyof typeof ZoneType]


export const TableType: {
  Mesa_1: 'Mesa_1',
  Mesa_2: 'Mesa_2',
  Mesa_3: 'Mesa_3',
  Mesa_4: 'Mesa_4',
  Mesa_5: 'Mesa_5',
  Mesa_6: 'Mesa_6'
};

export type TableType = (typeof TableType)[keyof typeof TableType]


export const PlantType: {
  Adenium_Obesum: 'Adenium_Obesum',
  Bromeliad: 'Bromeliad',
  Cactus: 'Cactus',
  Orchid: 'Orchid',
  Succulent: 'Succulent'
};

export type PlantType = (typeof PlantType)[keyof typeof PlantType]


export const PotSize: {
  Nro_5: 'Nro_5',
  Nro_7: 'Nro_7',
  Nro_10: 'Nro_10',
  Nro_14: 'Nro_14'
};

export type PotSize = (typeof PotSize)[keyof typeof PotSize]


export const TaskStatus: {
  Pendiente: 'Pendiente',
  Completada: 'Completada',
  Cancelada: 'Cancelada',
  Reprogramada: 'Reprogramada'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const AgrochemicalType: {
  Fertilizante: 'Fertilizante',
  Fitosanitario: 'Fitosanitario'
};

export type AgrochemicalType = (typeof AgrochemicalType)[keyof typeof AgrochemicalType]


export const AgrochemicalPorpose: {
  Desarrollo: 'Desarrollo',
  Mantenimiento: 'Mantenimiento',
  Floracion: 'Floracion',
  Fungicida: 'Fungicida',
  Insecticida: 'Insecticida',
  Acaricida: 'Acaricida'
};

export type AgrochemicalPorpose = (typeof AgrochemicalPorpose)[keyof typeof AgrochemicalPorpose]


export const TriggerType: {
  Diario: 'Diario',
  Interdiario: 'Interdiario',
  Sensores: 'Sensores'
};

export type TriggerType = (typeof TriggerType)[keyof typeof TriggerType]


export const ActuatorType: {
  Aspercion: 'Aspercion',
  Nebulizacion: 'Nebulizacion',
  Humedecer_Suelo: 'Humedecer_Suelo'
};

export type ActuatorType = (typeof ActuatorType)[keyof typeof ActuatorType]


export const SensorType: {
  Humedad_Relativa: 'Humedad_Relativa',
  Temperatura: 'Temperatura',
  Intensidad_Luminosa: 'Intensidad_Luminosa'
};

export type SensorType = (typeof SensorType)[keyof typeof SensorType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ZoneType = $Enums.ZoneType

export const ZoneType: typeof $Enums.ZoneType

export type TableType = $Enums.TableType

export const TableType: typeof $Enums.TableType

export type PlantType = $Enums.PlantType

export const PlantType: typeof $Enums.PlantType

export type PotSize = $Enums.PotSize

export const PotSize: typeof $Enums.PotSize

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type AgrochemicalType = $Enums.AgrochemicalType

export const AgrochemicalType: typeof $Enums.AgrochemicalType

export type AgrochemicalPorpose = $Enums.AgrochemicalPorpose

export const AgrochemicalPorpose: typeof $Enums.AgrochemicalPorpose

export type TriggerType = $Enums.TriggerType

export const TriggerType: typeof $Enums.TriggerType

export type ActuatorType = $Enums.ActuatorType

export const ActuatorType: typeof $Enums.ActuatorType

export type SensorType = $Enums.SensorType

export const SensorType: typeof $Enums.SensorType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Stocks
 * const stocks = await prisma.stock.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Stocks
   * const stocks = await prisma.stock.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.stock`: Exposes CRUD operations for the **Stock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stocks
    * const stocks = await prisma.stock.findMany()
    * ```
    */
  get stock(): Prisma.StockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genus`: Exposes CRUD operations for the **Genus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genera
    * const genera = await prisma.genus.findMany()
    * ```
    */
  get genus(): Prisma.GenusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.species`: Exposes CRUD operations for the **Species** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Species
    * const species = await prisma.species.findMany()
    * ```
    */
  get species(): Prisma.SpeciesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.speciesImage`: Exposes CRUD operations for the **SpeciesImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpeciesImages
    * const speciesImages = await prisma.speciesImage.findMany()
    * ```
    */
  get speciesImage(): Prisma.SpeciesImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plant`: Exposes CRUD operations for the **Plant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plants
    * const plants = await prisma.plant.findMany()
    * ```
    */
  get plant(): Prisma.PlantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agrochemical`: Exposes CRUD operations for the **Agrochemical** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agrochemicals
    * const agrochemicals = await prisma.agrochemical.findMany()
    * ```
    */
  get agrochemical(): Prisma.AgrochemicalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fertilizationProgram`: Exposes CRUD operations for the **FertilizationProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FertilizationPrograms
    * const fertilizationPrograms = await prisma.fertilizationProgram.findMany()
    * ```
    */
  get fertilizationProgram(): Prisma.FertilizationProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fertilizationCycle`: Exposes CRUD operations for the **FertilizationCycle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FertilizationCycles
    * const fertilizationCycles = await prisma.fertilizationCycle.findMany()
    * ```
    */
  get fertilizationCycle(): Prisma.FertilizationCycleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fertilizationTask`: Exposes CRUD operations for the **FertilizationTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FertilizationTasks
    * const fertilizationTasks = await prisma.fertilizationTask.findMany()
    * ```
    */
  get fertilizationTask(): Prisma.FertilizationTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.phytosanitaryProgram`: Exposes CRUD operations for the **PhytosanitaryProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhytosanitaryPrograms
    * const phytosanitaryPrograms = await prisma.phytosanitaryProgram.findMany()
    * ```
    */
  get phytosanitaryProgram(): Prisma.PhytosanitaryProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.phytosanitaryCycle`: Exposes CRUD operations for the **PhytosanitaryCycle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhytosanitaryCycles
    * const phytosanitaryCycles = await prisma.phytosanitaryCycle.findMany()
    * ```
    */
  get phytosanitaryCycle(): Prisma.PhytosanitaryCycleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.phytosanitaryTask`: Exposes CRUD operations for the **PhytosanitaryTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhytosanitaryTasks
    * const phytosanitaryTasks = await prisma.phytosanitaryTask.findMany()
    * ```
    */
  get phytosanitaryTask(): Prisma.PhytosanitaryTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.irrigationProgram`: Exposes CRUD operations for the **IrrigationProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IrrigationPrograms
    * const irrigationPrograms = await prisma.irrigationProgram.findMany()
    * ```
    */
  get irrigationProgram(): Prisma.IrrigationProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.irrigationTask`: Exposes CRUD operations for the **IrrigationTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IrrigationTasks
    * const irrigationTasks = await prisma.irrigationTask.findMany()
    * ```
    */
  get irrigationTask(): Prisma.IrrigationTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sensorReading`: Exposes CRUD operations for the **SensorReading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SensorReadings
    * const sensorReadings = await prisma.sensorReading.findMany()
    * ```
    */
  get sensorReading(): Prisma.SensorReadingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Stock: 'Stock',
    Genus: 'Genus',
    Species: 'Species',
    SpeciesImage: 'SpeciesImage',
    Location: 'Location',
    Plant: 'Plant',
    Agrochemical: 'Agrochemical',
    FertilizationProgram: 'FertilizationProgram',
    FertilizationCycle: 'FertilizationCycle',
    FertilizationTask: 'FertilizationTask',
    PhytosanitaryProgram: 'PhytosanitaryProgram',
    PhytosanitaryCycle: 'PhytosanitaryCycle',
    PhytosanitaryTask: 'PhytosanitaryTask',
    IrrigationProgram: 'IrrigationProgram',
    IrrigationTask: 'IrrigationTask',
    SensorReading: 'SensorReading'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "stock" | "genus" | "species" | "speciesImage" | "location" | "plant" | "agrochemical" | "fertilizationProgram" | "fertilizationCycle" | "fertilizationTask" | "phytosanitaryProgram" | "phytosanitaryCycle" | "phytosanitaryTask" | "irrigationProgram" | "irrigationTask" | "sensorReading"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Stock: {
        payload: Prisma.$StockPayload<ExtArgs>
        fields: Prisma.StockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findFirst: {
            args: Prisma.StockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findMany: {
            args: Prisma.StockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          create: {
            args: Prisma.StockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          createMany: {
            args: Prisma.StockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          delete: {
            args: Prisma.StockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          update: {
            args: Prisma.StockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          deleteMany: {
            args: Prisma.StockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          upsert: {
            args: Prisma.StockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          aggregate: {
            args: Prisma.StockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStock>
          }
          groupBy: {
            args: Prisma.StockGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockCountArgs<ExtArgs>
            result: $Utils.Optional<StockCountAggregateOutputType> | number
          }
        }
      }
      Genus: {
        payload: Prisma.$GenusPayload<ExtArgs>
        fields: Prisma.GenusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenusPayload>
          }
          findFirst: {
            args: Prisma.GenusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenusPayload>
          }
          findMany: {
            args: Prisma.GenusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenusPayload>[]
          }
          create: {
            args: Prisma.GenusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenusPayload>
          }
          createMany: {
            args: Prisma.GenusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenusPayload>[]
          }
          delete: {
            args: Prisma.GenusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenusPayload>
          }
          update: {
            args: Prisma.GenusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenusPayload>
          }
          deleteMany: {
            args: Prisma.GenusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenusPayload>[]
          }
          upsert: {
            args: Prisma.GenusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenusPayload>
          }
          aggregate: {
            args: Prisma.GenusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenus>
          }
          groupBy: {
            args: Prisma.GenusGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenusGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenusCountArgs<ExtArgs>
            result: $Utils.Optional<GenusCountAggregateOutputType> | number
          }
        }
      }
      Species: {
        payload: Prisma.$SpeciesPayload<ExtArgs>
        fields: Prisma.SpeciesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpeciesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpeciesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesPayload>
          }
          findFirst: {
            args: Prisma.SpeciesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpeciesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesPayload>
          }
          findMany: {
            args: Prisma.SpeciesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesPayload>[]
          }
          create: {
            args: Prisma.SpeciesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesPayload>
          }
          createMany: {
            args: Prisma.SpeciesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpeciesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesPayload>[]
          }
          delete: {
            args: Prisma.SpeciesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesPayload>
          }
          update: {
            args: Prisma.SpeciesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesPayload>
          }
          deleteMany: {
            args: Prisma.SpeciesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpeciesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpeciesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesPayload>[]
          }
          upsert: {
            args: Prisma.SpeciesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesPayload>
          }
          aggregate: {
            args: Prisma.SpeciesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecies>
          }
          groupBy: {
            args: Prisma.SpeciesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeciesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpeciesCountArgs<ExtArgs>
            result: $Utils.Optional<SpeciesCountAggregateOutputType> | number
          }
        }
      }
      SpeciesImage: {
        payload: Prisma.$SpeciesImagePayload<ExtArgs>
        fields: Prisma.SpeciesImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpeciesImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpeciesImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesImagePayload>
          }
          findFirst: {
            args: Prisma.SpeciesImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpeciesImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesImagePayload>
          }
          findMany: {
            args: Prisma.SpeciesImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesImagePayload>[]
          }
          create: {
            args: Prisma.SpeciesImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesImagePayload>
          }
          createMany: {
            args: Prisma.SpeciesImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpeciesImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesImagePayload>[]
          }
          delete: {
            args: Prisma.SpeciesImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesImagePayload>
          }
          update: {
            args: Prisma.SpeciesImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesImagePayload>
          }
          deleteMany: {
            args: Prisma.SpeciesImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpeciesImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpeciesImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesImagePayload>[]
          }
          upsert: {
            args: Prisma.SpeciesImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeciesImagePayload>
          }
          aggregate: {
            args: Prisma.SpeciesImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeciesImage>
          }
          groupBy: {
            args: Prisma.SpeciesImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeciesImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpeciesImageCountArgs<ExtArgs>
            result: $Utils.Optional<SpeciesImageCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Plant: {
        payload: Prisma.$PlantPayload<ExtArgs>
        fields: Prisma.PlantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          findFirst: {
            args: Prisma.PlantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          findMany: {
            args: Prisma.PlantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>[]
          }
          create: {
            args: Prisma.PlantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          createMany: {
            args: Prisma.PlantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>[]
          }
          delete: {
            args: Prisma.PlantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          update: {
            args: Prisma.PlantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          deleteMany: {
            args: Prisma.PlantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>[]
          }
          upsert: {
            args: Prisma.PlantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          aggregate: {
            args: Prisma.PlantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlant>
          }
          groupBy: {
            args: Prisma.PlantGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlantGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlantCountArgs<ExtArgs>
            result: $Utils.Optional<PlantCountAggregateOutputType> | number
          }
        }
      }
      Agrochemical: {
        payload: Prisma.$AgrochemicalPayload<ExtArgs>
        fields: Prisma.AgrochemicalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgrochemicalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrochemicalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgrochemicalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrochemicalPayload>
          }
          findFirst: {
            args: Prisma.AgrochemicalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrochemicalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgrochemicalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrochemicalPayload>
          }
          findMany: {
            args: Prisma.AgrochemicalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrochemicalPayload>[]
          }
          create: {
            args: Prisma.AgrochemicalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrochemicalPayload>
          }
          createMany: {
            args: Prisma.AgrochemicalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgrochemicalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrochemicalPayload>[]
          }
          delete: {
            args: Prisma.AgrochemicalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrochemicalPayload>
          }
          update: {
            args: Prisma.AgrochemicalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrochemicalPayload>
          }
          deleteMany: {
            args: Prisma.AgrochemicalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgrochemicalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgrochemicalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrochemicalPayload>[]
          }
          upsert: {
            args: Prisma.AgrochemicalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrochemicalPayload>
          }
          aggregate: {
            args: Prisma.AgrochemicalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgrochemical>
          }
          groupBy: {
            args: Prisma.AgrochemicalGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgrochemicalGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgrochemicalCountArgs<ExtArgs>
            result: $Utils.Optional<AgrochemicalCountAggregateOutputType> | number
          }
        }
      }
      FertilizationProgram: {
        payload: Prisma.$FertilizationProgramPayload<ExtArgs>
        fields: Prisma.FertilizationProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FertilizationProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FertilizationProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationProgramPayload>
          }
          findFirst: {
            args: Prisma.FertilizationProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FertilizationProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationProgramPayload>
          }
          findMany: {
            args: Prisma.FertilizationProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationProgramPayload>[]
          }
          create: {
            args: Prisma.FertilizationProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationProgramPayload>
          }
          createMany: {
            args: Prisma.FertilizationProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FertilizationProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationProgramPayload>[]
          }
          delete: {
            args: Prisma.FertilizationProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationProgramPayload>
          }
          update: {
            args: Prisma.FertilizationProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationProgramPayload>
          }
          deleteMany: {
            args: Prisma.FertilizationProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FertilizationProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FertilizationProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationProgramPayload>[]
          }
          upsert: {
            args: Prisma.FertilizationProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationProgramPayload>
          }
          aggregate: {
            args: Prisma.FertilizationProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFertilizationProgram>
          }
          groupBy: {
            args: Prisma.FertilizationProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<FertilizationProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.FertilizationProgramCountArgs<ExtArgs>
            result: $Utils.Optional<FertilizationProgramCountAggregateOutputType> | number
          }
        }
      }
      FertilizationCycle: {
        payload: Prisma.$FertilizationCyclePayload<ExtArgs>
        fields: Prisma.FertilizationCycleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FertilizationCycleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationCyclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FertilizationCycleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationCyclePayload>
          }
          findFirst: {
            args: Prisma.FertilizationCycleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationCyclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FertilizationCycleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationCyclePayload>
          }
          findMany: {
            args: Prisma.FertilizationCycleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationCyclePayload>[]
          }
          create: {
            args: Prisma.FertilizationCycleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationCyclePayload>
          }
          createMany: {
            args: Prisma.FertilizationCycleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FertilizationCycleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationCyclePayload>[]
          }
          delete: {
            args: Prisma.FertilizationCycleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationCyclePayload>
          }
          update: {
            args: Prisma.FertilizationCycleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationCyclePayload>
          }
          deleteMany: {
            args: Prisma.FertilizationCycleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FertilizationCycleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FertilizationCycleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationCyclePayload>[]
          }
          upsert: {
            args: Prisma.FertilizationCycleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationCyclePayload>
          }
          aggregate: {
            args: Prisma.FertilizationCycleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFertilizationCycle>
          }
          groupBy: {
            args: Prisma.FertilizationCycleGroupByArgs<ExtArgs>
            result: $Utils.Optional<FertilizationCycleGroupByOutputType>[]
          }
          count: {
            args: Prisma.FertilizationCycleCountArgs<ExtArgs>
            result: $Utils.Optional<FertilizationCycleCountAggregateOutputType> | number
          }
        }
      }
      FertilizationTask: {
        payload: Prisma.$FertilizationTaskPayload<ExtArgs>
        fields: Prisma.FertilizationTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FertilizationTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FertilizationTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationTaskPayload>
          }
          findFirst: {
            args: Prisma.FertilizationTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FertilizationTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationTaskPayload>
          }
          findMany: {
            args: Prisma.FertilizationTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationTaskPayload>[]
          }
          create: {
            args: Prisma.FertilizationTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationTaskPayload>
          }
          createMany: {
            args: Prisma.FertilizationTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FertilizationTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationTaskPayload>[]
          }
          delete: {
            args: Prisma.FertilizationTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationTaskPayload>
          }
          update: {
            args: Prisma.FertilizationTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationTaskPayload>
          }
          deleteMany: {
            args: Prisma.FertilizationTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FertilizationTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FertilizationTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationTaskPayload>[]
          }
          upsert: {
            args: Prisma.FertilizationTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FertilizationTaskPayload>
          }
          aggregate: {
            args: Prisma.FertilizationTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFertilizationTask>
          }
          groupBy: {
            args: Prisma.FertilizationTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<FertilizationTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.FertilizationTaskCountArgs<ExtArgs>
            result: $Utils.Optional<FertilizationTaskCountAggregateOutputType> | number
          }
        }
      }
      PhytosanitaryProgram: {
        payload: Prisma.$PhytosanitaryProgramPayload<ExtArgs>
        fields: Prisma.PhytosanitaryProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhytosanitaryProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhytosanitaryProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryProgramPayload>
          }
          findFirst: {
            args: Prisma.PhytosanitaryProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhytosanitaryProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryProgramPayload>
          }
          findMany: {
            args: Prisma.PhytosanitaryProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryProgramPayload>[]
          }
          create: {
            args: Prisma.PhytosanitaryProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryProgramPayload>
          }
          createMany: {
            args: Prisma.PhytosanitaryProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhytosanitaryProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryProgramPayload>[]
          }
          delete: {
            args: Prisma.PhytosanitaryProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryProgramPayload>
          }
          update: {
            args: Prisma.PhytosanitaryProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryProgramPayload>
          }
          deleteMany: {
            args: Prisma.PhytosanitaryProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhytosanitaryProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PhytosanitaryProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryProgramPayload>[]
          }
          upsert: {
            args: Prisma.PhytosanitaryProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryProgramPayload>
          }
          aggregate: {
            args: Prisma.PhytosanitaryProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhytosanitaryProgram>
          }
          groupBy: {
            args: Prisma.PhytosanitaryProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhytosanitaryProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhytosanitaryProgramCountArgs<ExtArgs>
            result: $Utils.Optional<PhytosanitaryProgramCountAggregateOutputType> | number
          }
        }
      }
      PhytosanitaryCycle: {
        payload: Prisma.$PhytosanitaryCyclePayload<ExtArgs>
        fields: Prisma.PhytosanitaryCycleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhytosanitaryCycleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryCyclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhytosanitaryCycleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryCyclePayload>
          }
          findFirst: {
            args: Prisma.PhytosanitaryCycleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryCyclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhytosanitaryCycleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryCyclePayload>
          }
          findMany: {
            args: Prisma.PhytosanitaryCycleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryCyclePayload>[]
          }
          create: {
            args: Prisma.PhytosanitaryCycleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryCyclePayload>
          }
          createMany: {
            args: Prisma.PhytosanitaryCycleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhytosanitaryCycleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryCyclePayload>[]
          }
          delete: {
            args: Prisma.PhytosanitaryCycleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryCyclePayload>
          }
          update: {
            args: Prisma.PhytosanitaryCycleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryCyclePayload>
          }
          deleteMany: {
            args: Prisma.PhytosanitaryCycleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhytosanitaryCycleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PhytosanitaryCycleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryCyclePayload>[]
          }
          upsert: {
            args: Prisma.PhytosanitaryCycleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryCyclePayload>
          }
          aggregate: {
            args: Prisma.PhytosanitaryCycleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhytosanitaryCycle>
          }
          groupBy: {
            args: Prisma.PhytosanitaryCycleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhytosanitaryCycleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhytosanitaryCycleCountArgs<ExtArgs>
            result: $Utils.Optional<PhytosanitaryCycleCountAggregateOutputType> | number
          }
        }
      }
      PhytosanitaryTask: {
        payload: Prisma.$PhytosanitaryTaskPayload<ExtArgs>
        fields: Prisma.PhytosanitaryTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhytosanitaryTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhytosanitaryTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryTaskPayload>
          }
          findFirst: {
            args: Prisma.PhytosanitaryTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhytosanitaryTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryTaskPayload>
          }
          findMany: {
            args: Prisma.PhytosanitaryTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryTaskPayload>[]
          }
          create: {
            args: Prisma.PhytosanitaryTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryTaskPayload>
          }
          createMany: {
            args: Prisma.PhytosanitaryTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhytosanitaryTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryTaskPayload>[]
          }
          delete: {
            args: Prisma.PhytosanitaryTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryTaskPayload>
          }
          update: {
            args: Prisma.PhytosanitaryTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryTaskPayload>
          }
          deleteMany: {
            args: Prisma.PhytosanitaryTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhytosanitaryTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PhytosanitaryTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryTaskPayload>[]
          }
          upsert: {
            args: Prisma.PhytosanitaryTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhytosanitaryTaskPayload>
          }
          aggregate: {
            args: Prisma.PhytosanitaryTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhytosanitaryTask>
          }
          groupBy: {
            args: Prisma.PhytosanitaryTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhytosanitaryTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhytosanitaryTaskCountArgs<ExtArgs>
            result: $Utils.Optional<PhytosanitaryTaskCountAggregateOutputType> | number
          }
        }
      }
      IrrigationProgram: {
        payload: Prisma.$IrrigationProgramPayload<ExtArgs>
        fields: Prisma.IrrigationProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IrrigationProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IrrigationProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationProgramPayload>
          }
          findFirst: {
            args: Prisma.IrrigationProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IrrigationProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationProgramPayload>
          }
          findMany: {
            args: Prisma.IrrigationProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationProgramPayload>[]
          }
          create: {
            args: Prisma.IrrigationProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationProgramPayload>
          }
          createMany: {
            args: Prisma.IrrigationProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IrrigationProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationProgramPayload>[]
          }
          delete: {
            args: Prisma.IrrigationProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationProgramPayload>
          }
          update: {
            args: Prisma.IrrigationProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationProgramPayload>
          }
          deleteMany: {
            args: Prisma.IrrigationProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IrrigationProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IrrigationProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationProgramPayload>[]
          }
          upsert: {
            args: Prisma.IrrigationProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationProgramPayload>
          }
          aggregate: {
            args: Prisma.IrrigationProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIrrigationProgram>
          }
          groupBy: {
            args: Prisma.IrrigationProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<IrrigationProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.IrrigationProgramCountArgs<ExtArgs>
            result: $Utils.Optional<IrrigationProgramCountAggregateOutputType> | number
          }
        }
      }
      IrrigationTask: {
        payload: Prisma.$IrrigationTaskPayload<ExtArgs>
        fields: Prisma.IrrigationTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IrrigationTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IrrigationTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationTaskPayload>
          }
          findFirst: {
            args: Prisma.IrrigationTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IrrigationTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationTaskPayload>
          }
          findMany: {
            args: Prisma.IrrigationTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationTaskPayload>[]
          }
          create: {
            args: Prisma.IrrigationTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationTaskPayload>
          }
          createMany: {
            args: Prisma.IrrigationTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IrrigationTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationTaskPayload>[]
          }
          delete: {
            args: Prisma.IrrigationTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationTaskPayload>
          }
          update: {
            args: Prisma.IrrigationTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationTaskPayload>
          }
          deleteMany: {
            args: Prisma.IrrigationTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IrrigationTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IrrigationTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationTaskPayload>[]
          }
          upsert: {
            args: Prisma.IrrigationTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IrrigationTaskPayload>
          }
          aggregate: {
            args: Prisma.IrrigationTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIrrigationTask>
          }
          groupBy: {
            args: Prisma.IrrigationTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<IrrigationTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.IrrigationTaskCountArgs<ExtArgs>
            result: $Utils.Optional<IrrigationTaskCountAggregateOutputType> | number
          }
        }
      }
      SensorReading: {
        payload: Prisma.$SensorReadingPayload<ExtArgs>
        fields: Prisma.SensorReadingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SensorReadingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorReadingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SensorReadingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorReadingPayload>
          }
          findFirst: {
            args: Prisma.SensorReadingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorReadingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SensorReadingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorReadingPayload>
          }
          findMany: {
            args: Prisma.SensorReadingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorReadingPayload>[]
          }
          create: {
            args: Prisma.SensorReadingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorReadingPayload>
          }
          createMany: {
            args: Prisma.SensorReadingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SensorReadingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorReadingPayload>[]
          }
          delete: {
            args: Prisma.SensorReadingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorReadingPayload>
          }
          update: {
            args: Prisma.SensorReadingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorReadingPayload>
          }
          deleteMany: {
            args: Prisma.SensorReadingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SensorReadingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SensorReadingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorReadingPayload>[]
          }
          upsert: {
            args: Prisma.SensorReadingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorReadingPayload>
          }
          aggregate: {
            args: Prisma.SensorReadingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSensorReading>
          }
          groupBy: {
            args: Prisma.SensorReadingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SensorReadingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SensorReadingCountArgs<ExtArgs>
            result: $Utils.Optional<SensorReadingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    stock?: StockOmit
    genus?: GenusOmit
    species?: SpeciesOmit
    speciesImage?: SpeciesImageOmit
    location?: LocationOmit
    plant?: PlantOmit
    agrochemical?: AgrochemicalOmit
    fertilizationProgram?: FertilizationProgramOmit
    fertilizationCycle?: FertilizationCycleOmit
    fertilizationTask?: FertilizationTaskOmit
    phytosanitaryProgram?: PhytosanitaryProgramOmit
    phytosanitaryCycle?: PhytosanitaryCycleOmit
    phytosanitaryTask?: PhytosanitaryTaskOmit
    irrigationProgram?: IrrigationProgramOmit
    irrigationTask?: IrrigationTaskOmit
    sensorReading?: SensorReadingOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type StockCountOutputType
   */

  export type StockCountOutputType = {
    species: number
  }

  export type StockCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    species?: boolean | StockCountOutputTypeCountSpeciesArgs
  }

  // Custom InputTypes
  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCountOutputType
     */
    select?: StockCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeCountSpeciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeciesWhereInput
  }


  /**
   * Count Type GenusCountOutputType
   */

  export type GenusCountOutputType = {
    species: number
  }

  export type GenusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    species?: boolean | GenusCountOutputTypeCountSpeciesArgs
  }

  // Custom InputTypes
  /**
   * GenusCountOutputType without action
   */
  export type GenusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenusCountOutputType
     */
    select?: GenusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenusCountOutputType without action
   */
  export type GenusCountOutputTypeCountSpeciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeciesWhereInput
  }


  /**
   * Count Type SpeciesCountOutputType
   */

  export type SpeciesCountOutputType = {
    plants: number
    images: number
  }

  export type SpeciesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plants?: boolean | SpeciesCountOutputTypeCountPlantsArgs
    images?: boolean | SpeciesCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * SpeciesCountOutputType without action
   */
  export type SpeciesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeciesCountOutputType
     */
    select?: SpeciesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpeciesCountOutputType without action
   */
  export type SpeciesCountOutputTypeCountPlantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantWhereInput
  }

  /**
   * SpeciesCountOutputType without action
   */
  export type SpeciesCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeciesImageWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    plants: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plants?: boolean | LocationCountOutputTypeCountPlantsArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountPlantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantWhereInput
  }


  /**
   * Count Type AgrochemicalCountOutputType
   */

  export type AgrochemicalCountOutputType = {
    fertilizationCycles: number
    fertilizationTasks: number
    phytosanitaryCycles: number
    phytosanitaryTasks: number
  }

  export type AgrochemicalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fertilizationCycles?: boolean | AgrochemicalCountOutputTypeCountFertilizationCyclesArgs
    fertilizationTasks?: boolean | AgrochemicalCountOutputTypeCountFertilizationTasksArgs
    phytosanitaryCycles?: boolean | AgrochemicalCountOutputTypeCountPhytosanitaryCyclesArgs
    phytosanitaryTasks?: boolean | AgrochemicalCountOutputTypeCountPhytosanitaryTasksArgs
  }

  // Custom InputTypes
  /**
   * AgrochemicalCountOutputType without action
   */
  export type AgrochemicalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgrochemicalCountOutputType
     */
    select?: AgrochemicalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgrochemicalCountOutputType without action
   */
  export type AgrochemicalCountOutputTypeCountFertilizationCyclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FertilizationCycleWhereInput
  }

  /**
   * AgrochemicalCountOutputType without action
   */
  export type AgrochemicalCountOutputTypeCountFertilizationTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FertilizationTaskWhereInput
  }

  /**
   * AgrochemicalCountOutputType without action
   */
  export type AgrochemicalCountOutputTypeCountPhytosanitaryCyclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhytosanitaryCycleWhereInput
  }

  /**
   * AgrochemicalCountOutputType without action
   */
  export type AgrochemicalCountOutputTypeCountPhytosanitaryTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhytosanitaryTaskWhereInput
  }


  /**
   * Count Type FertilizationProgramCountOutputType
   */

  export type FertilizationProgramCountOutputType = {
    productsCycle: number
  }

  export type FertilizationProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productsCycle?: boolean | FertilizationProgramCountOutputTypeCountProductsCycleArgs
  }

  // Custom InputTypes
  /**
   * FertilizationProgramCountOutputType without action
   */
  export type FertilizationProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationProgramCountOutputType
     */
    select?: FertilizationProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FertilizationProgramCountOutputType without action
   */
  export type FertilizationProgramCountOutputTypeCountProductsCycleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FertilizationCycleWhereInput
  }


  /**
   * Count Type FertilizationCycleCountOutputType
   */

  export type FertilizationCycleCountOutputType = {
    tasks: number
  }

  export type FertilizationCycleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | FertilizationCycleCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * FertilizationCycleCountOutputType without action
   */
  export type FertilizationCycleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycleCountOutputType
     */
    select?: FertilizationCycleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FertilizationCycleCountOutputType without action
   */
  export type FertilizationCycleCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FertilizationTaskWhereInput
  }


  /**
   * Count Type PhytosanitaryProgramCountOutputType
   */

  export type PhytosanitaryProgramCountOutputType = {
    productsCycle: number
  }

  export type PhytosanitaryProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productsCycle?: boolean | PhytosanitaryProgramCountOutputTypeCountProductsCycleArgs
  }

  // Custom InputTypes
  /**
   * PhytosanitaryProgramCountOutputType without action
   */
  export type PhytosanitaryProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryProgramCountOutputType
     */
    select?: PhytosanitaryProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PhytosanitaryProgramCountOutputType without action
   */
  export type PhytosanitaryProgramCountOutputTypeCountProductsCycleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhytosanitaryCycleWhereInput
  }


  /**
   * Count Type PhytosanitaryCycleCountOutputType
   */

  export type PhytosanitaryCycleCountOutputType = {
    tasks: number
  }

  export type PhytosanitaryCycleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | PhytosanitaryCycleCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * PhytosanitaryCycleCountOutputType without action
   */
  export type PhytosanitaryCycleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycleCountOutputType
     */
    select?: PhytosanitaryCycleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PhytosanitaryCycleCountOutputType without action
   */
  export type PhytosanitaryCycleCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhytosanitaryTaskWhereInput
  }


  /**
   * Count Type IrrigationProgramCountOutputType
   */

  export type IrrigationProgramCountOutputType = {
    tasks: number
  }

  export type IrrigationProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | IrrigationProgramCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * IrrigationProgramCountOutputType without action
   */
  export type IrrigationProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationProgramCountOutputType
     */
    select?: IrrigationProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IrrigationProgramCountOutputType without action
   */
  export type IrrigationProgramCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationTaskWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Stock
   */

  export type AggregateStock = {
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  export type StockAvgAggregateOutputType = {
    quantity: number | null
  }

  export type StockSumAggregateOutputType = {
    quantity: number | null
  }

  export type StockMinAggregateOutputType = {
    id: string | null
    quantity: number | null
    available: boolean | null
  }

  export type StockMaxAggregateOutputType = {
    id: string | null
    quantity: number | null
    available: boolean | null
  }

  export type StockCountAggregateOutputType = {
    id: number
    quantity: number
    available: number
    _all: number
  }


  export type StockAvgAggregateInputType = {
    quantity?: true
  }

  export type StockSumAggregateInputType = {
    quantity?: true
  }

  export type StockMinAggregateInputType = {
    id?: true
    quantity?: true
    available?: true
  }

  export type StockMaxAggregateInputType = {
    id?: true
    quantity?: true
    available?: true
  }

  export type StockCountAggregateInputType = {
    id?: true
    quantity?: true
    available?: true
    _all?: true
  }

  export type StockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stock to aggregate.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stocks
    **/
    _count?: true | StockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMaxAggregateInputType
  }

  export type GetStockAggregateType<T extends StockAggregateArgs> = {
        [P in keyof T & keyof AggregateStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock[P]>
      : GetScalarType<T[P], AggregateStock[P]>
  }




  export type StockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
    orderBy?: StockOrderByWithAggregationInput | StockOrderByWithAggregationInput[]
    by: StockScalarFieldEnum[] | StockScalarFieldEnum
    having?: StockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockCountAggregateInputType | true
    _avg?: StockAvgAggregateInputType
    _sum?: StockSumAggregateInputType
    _min?: StockMinAggregateInputType
    _max?: StockMaxAggregateInputType
  }

  export type StockGroupByOutputType = {
    id: string
    quantity: number
    available: boolean
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  type GetStockGroupByPayload<T extends StockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockGroupByOutputType[P]>
            : GetScalarType<T[P], StockGroupByOutputType[P]>
        }
      >
    >


  export type StockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    available?: boolean
    species?: boolean | Stock$speciesArgs<ExtArgs>
    _count?: boolean | StockCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>

  export type StockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    available?: boolean
  }, ExtArgs["result"]["stock"]>

  export type StockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    available?: boolean
  }, ExtArgs["result"]["stock"]>

  export type StockSelectScalar = {
    id?: boolean
    quantity?: boolean
    available?: boolean
  }

  export type StockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "available", ExtArgs["result"]["stock"]>
  export type StockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    species?: boolean | Stock$speciesArgs<ExtArgs>
    _count?: boolean | StockCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stock"
    objects: {
      species: Prisma.$SpeciesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quantity: number
      available: boolean
    }, ExtArgs["result"]["stock"]>
    composites: {}
  }

  type StockGetPayload<S extends boolean | null | undefined | StockDefaultArgs> = $Result.GetResult<Prisma.$StockPayload, S>

  type StockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockCountAggregateInputType | true
    }

  export interface StockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stock'], meta: { name: 'Stock' } }
    /**
     * Find zero or one Stock that matches the filter.
     * @param {StockFindUniqueArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockFindUniqueArgs>(args: SelectSubset<T, StockFindUniqueArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockFindUniqueOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockFindUniqueOrThrowArgs>(args: SelectSubset<T, StockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockFindFirstArgs>(args?: SelectSubset<T, StockFindFirstArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockFindFirstOrThrowArgs>(args?: SelectSubset<T, StockFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stocks
     * const stocks = await prisma.stock.findMany()
     * 
     * // Get first 10 Stocks
     * const stocks = await prisma.stock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockWithIdOnly = await prisma.stock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockFindManyArgs>(args?: SelectSubset<T, StockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stock.
     * @param {StockCreateArgs} args - Arguments to create a Stock.
     * @example
     * // Create one Stock
     * const Stock = await prisma.stock.create({
     *   data: {
     *     // ... data to create a Stock
     *   }
     * })
     * 
     */
    create<T extends StockCreateArgs>(args: SelectSubset<T, StockCreateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stocks.
     * @param {StockCreateManyArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stock = await prisma.stock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockCreateManyArgs>(args?: SelectSubset<T, StockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stocks and returns the data saved in the database.
     * @param {StockCreateManyAndReturnArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stock = await prisma.stock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stocks and only return the `id`
     * const stockWithIdOnly = await prisma.stock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockCreateManyAndReturnArgs>(args?: SelectSubset<T, StockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Stock.
     * @param {StockDeleteArgs} args - Arguments to delete one Stock.
     * @example
     * // Delete one Stock
     * const Stock = await prisma.stock.delete({
     *   where: {
     *     // ... filter to delete one Stock
     *   }
     * })
     * 
     */
    delete<T extends StockDeleteArgs>(args: SelectSubset<T, StockDeleteArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stock.
     * @param {StockUpdateArgs} args - Arguments to update one Stock.
     * @example
     * // Update one Stock
     * const stock = await prisma.stock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockUpdateArgs>(args: SelectSubset<T, StockUpdateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stocks.
     * @param {StockDeleteManyArgs} args - Arguments to filter Stocks to delete.
     * @example
     * // Delete a few Stocks
     * const { count } = await prisma.stock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockDeleteManyArgs>(args?: SelectSubset<T, StockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockUpdateManyArgs>(args: SelectSubset<T, StockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks and returns the data updated in the database.
     * @param {StockUpdateManyAndReturnArgs} args - Arguments to update many Stocks.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stocks and only return the `id`
     * const stockWithIdOnly = await prisma.stock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockUpdateManyAndReturnArgs>(args: SelectSubset<T, StockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Stock.
     * @param {StockUpsertArgs} args - Arguments to update or create a Stock.
     * @example
     * // Update or create a Stock
     * const stock = await prisma.stock.upsert({
     *   create: {
     *     // ... data to create a Stock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock we want to update
     *   }
     * })
     */
    upsert<T extends StockUpsertArgs>(args: SelectSubset<T, StockUpsertArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCountArgs} args - Arguments to filter Stocks to count.
     * @example
     * // Count the number of Stocks
     * const count = await prisma.stock.count({
     *   where: {
     *     // ... the filter for the Stocks we want to count
     *   }
     * })
    **/
    count<T extends StockCountArgs>(
      args?: Subset<T, StockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockAggregateArgs>(args: Subset<T, StockAggregateArgs>): Prisma.PrismaPromise<GetStockAggregateType<T>>

    /**
     * Group by Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockGroupByArgs['orderBy'] }
        : { orderBy?: StockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stock model
   */
  readonly fields: StockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    species<T extends Stock$speciesArgs<ExtArgs> = {}>(args?: Subset<T, Stock$speciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeciesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stock model
   */
  interface StockFieldRefs {
    readonly id: FieldRef<"Stock", 'String'>
    readonly quantity: FieldRef<"Stock", 'Int'>
    readonly available: FieldRef<"Stock", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Stock findUnique
   */
  export type StockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findUniqueOrThrow
   */
  export type StockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findFirst
   */
  export type StockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findFirstOrThrow
   */
  export type StockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findMany
   */
  export type StockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stocks to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock create
   */
  export type StockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to create a Stock.
     */
    data?: XOR<StockCreateInput, StockUncheckedCreateInput>
  }

  /**
   * Stock createMany
   */
  export type StockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stock createManyAndReturn
   */
  export type StockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stock update
   */
  export type StockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to update a Stock.
     */
    data: XOR<StockUpdateInput, StockUncheckedUpdateInput>
    /**
     * Choose, which Stock to update.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock updateMany
   */
  export type StockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stocks.
     */
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to update.
     */
    limit?: number
  }

  /**
   * Stock updateManyAndReturn
   */
  export type StockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * The data used to update Stocks.
     */
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to update.
     */
    limit?: number
  }

  /**
   * Stock upsert
   */
  export type StockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The filter to search for the Stock to update in case it exists.
     */
    where: StockWhereUniqueInput
    /**
     * In case the Stock found by the `where` argument doesn't exist, create a new Stock with this data.
     */
    create: XOR<StockCreateInput, StockUncheckedCreateInput>
    /**
     * In case the Stock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockUpdateInput, StockUncheckedUpdateInput>
  }

  /**
   * Stock delete
   */
  export type StockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter which Stock to delete.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock deleteMany
   */
  export type StockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stocks to delete
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to delete.
     */
    limit?: number
  }

  /**
   * Stock.species
   */
  export type Stock$speciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Species
     */
    select?: SpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Species
     */
    omit?: SpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesInclude<ExtArgs> | null
    where?: SpeciesWhereInput
    orderBy?: SpeciesOrderByWithRelationInput | SpeciesOrderByWithRelationInput[]
    cursor?: SpeciesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpeciesScalarFieldEnum | SpeciesScalarFieldEnum[]
  }

  /**
   * Stock without action
   */
  export type StockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
  }


  /**
   * Model Genus
   */

  export type AggregateGenus = {
    _count: GenusCountAggregateOutputType | null
    _min: GenusMinAggregateOutputType | null
    _max: GenusMaxAggregateOutputType | null
  }

  export type GenusMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.PlantType | null
  }

  export type GenusMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.PlantType | null
  }

  export type GenusCountAggregateOutputType = {
    id: number
    name: number
    type: number
    _all: number
  }


  export type GenusMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
  }

  export type GenusMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
  }

  export type GenusCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    _all?: true
  }

  export type GenusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genus to aggregate.
     */
    where?: GenusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genera to fetch.
     */
    orderBy?: GenusOrderByWithRelationInput | GenusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genera from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genera.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genera
    **/
    _count?: true | GenusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenusMaxAggregateInputType
  }

  export type GetGenusAggregateType<T extends GenusAggregateArgs> = {
        [P in keyof T & keyof AggregateGenus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenus[P]>
      : GetScalarType<T[P], AggregateGenus[P]>
  }




  export type GenusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenusWhereInput
    orderBy?: GenusOrderByWithAggregationInput | GenusOrderByWithAggregationInput[]
    by: GenusScalarFieldEnum[] | GenusScalarFieldEnum
    having?: GenusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenusCountAggregateInputType | true
    _min?: GenusMinAggregateInputType
    _max?: GenusMaxAggregateInputType
  }

  export type GenusGroupByOutputType = {
    id: string
    name: string
    type: $Enums.PlantType
    _count: GenusCountAggregateOutputType | null
    _min: GenusMinAggregateOutputType | null
    _max: GenusMaxAggregateOutputType | null
  }

  type GetGenusGroupByPayload<T extends GenusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenusGroupByOutputType[P]>
            : GetScalarType<T[P], GenusGroupByOutputType[P]>
        }
      >
    >


  export type GenusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    species?: boolean | Genus$speciesArgs<ExtArgs>
    _count?: boolean | GenusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genus"]>

  export type GenusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
  }, ExtArgs["result"]["genus"]>

  export type GenusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
  }, ExtArgs["result"]["genus"]>

  export type GenusSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
  }

  export type GenusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type", ExtArgs["result"]["genus"]>
  export type GenusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    species?: boolean | Genus$speciesArgs<ExtArgs>
    _count?: boolean | GenusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GenusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GenusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GenusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Genus"
    objects: {
      species: Prisma.$SpeciesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.PlantType
    }, ExtArgs["result"]["genus"]>
    composites: {}
  }

  type GenusGetPayload<S extends boolean | null | undefined | GenusDefaultArgs> = $Result.GetResult<Prisma.$GenusPayload, S>

  type GenusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenusCountAggregateInputType | true
    }

  export interface GenusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Genus'], meta: { name: 'Genus' } }
    /**
     * Find zero or one Genus that matches the filter.
     * @param {GenusFindUniqueArgs} args - Arguments to find a Genus
     * @example
     * // Get one Genus
     * const genus = await prisma.genus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenusFindUniqueArgs>(args: SelectSubset<T, GenusFindUniqueArgs<ExtArgs>>): Prisma__GenusClient<$Result.GetResult<Prisma.$GenusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Genus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenusFindUniqueOrThrowArgs} args - Arguments to find a Genus
     * @example
     * // Get one Genus
     * const genus = await prisma.genus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenusFindUniqueOrThrowArgs>(args: SelectSubset<T, GenusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenusClient<$Result.GetResult<Prisma.$GenusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenusFindFirstArgs} args - Arguments to find a Genus
     * @example
     * // Get one Genus
     * const genus = await prisma.genus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenusFindFirstArgs>(args?: SelectSubset<T, GenusFindFirstArgs<ExtArgs>>): Prisma__GenusClient<$Result.GetResult<Prisma.$GenusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenusFindFirstOrThrowArgs} args - Arguments to find a Genus
     * @example
     * // Get one Genus
     * const genus = await prisma.genus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenusFindFirstOrThrowArgs>(args?: SelectSubset<T, GenusFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenusClient<$Result.GetResult<Prisma.$GenusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Genera that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genera
     * const genera = await prisma.genus.findMany()
     * 
     * // Get first 10 Genera
     * const genera = await prisma.genus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genusWithIdOnly = await prisma.genus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenusFindManyArgs>(args?: SelectSubset<T, GenusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Genus.
     * @param {GenusCreateArgs} args - Arguments to create a Genus.
     * @example
     * // Create one Genus
     * const Genus = await prisma.genus.create({
     *   data: {
     *     // ... data to create a Genus
     *   }
     * })
     * 
     */
    create<T extends GenusCreateArgs>(args: SelectSubset<T, GenusCreateArgs<ExtArgs>>): Prisma__GenusClient<$Result.GetResult<Prisma.$GenusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Genera.
     * @param {GenusCreateManyArgs} args - Arguments to create many Genera.
     * @example
     * // Create many Genera
     * const genus = await prisma.genus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenusCreateManyArgs>(args?: SelectSubset<T, GenusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Genera and returns the data saved in the database.
     * @param {GenusCreateManyAndReturnArgs} args - Arguments to create many Genera.
     * @example
     * // Create many Genera
     * const genus = await prisma.genus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Genera and only return the `id`
     * const genusWithIdOnly = await prisma.genus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenusCreateManyAndReturnArgs>(args?: SelectSubset<T, GenusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Genus.
     * @param {GenusDeleteArgs} args - Arguments to delete one Genus.
     * @example
     * // Delete one Genus
     * const Genus = await prisma.genus.delete({
     *   where: {
     *     // ... filter to delete one Genus
     *   }
     * })
     * 
     */
    delete<T extends GenusDeleteArgs>(args: SelectSubset<T, GenusDeleteArgs<ExtArgs>>): Prisma__GenusClient<$Result.GetResult<Prisma.$GenusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Genus.
     * @param {GenusUpdateArgs} args - Arguments to update one Genus.
     * @example
     * // Update one Genus
     * const genus = await prisma.genus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenusUpdateArgs>(args: SelectSubset<T, GenusUpdateArgs<ExtArgs>>): Prisma__GenusClient<$Result.GetResult<Prisma.$GenusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Genera.
     * @param {GenusDeleteManyArgs} args - Arguments to filter Genera to delete.
     * @example
     * // Delete a few Genera
     * const { count } = await prisma.genus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenusDeleteManyArgs>(args?: SelectSubset<T, GenusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genera.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genera
     * const genus = await prisma.genus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenusUpdateManyArgs>(args: SelectSubset<T, GenusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genera and returns the data updated in the database.
     * @param {GenusUpdateManyAndReturnArgs} args - Arguments to update many Genera.
     * @example
     * // Update many Genera
     * const genus = await prisma.genus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Genera and only return the `id`
     * const genusWithIdOnly = await prisma.genus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenusUpdateManyAndReturnArgs>(args: SelectSubset<T, GenusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Genus.
     * @param {GenusUpsertArgs} args - Arguments to update or create a Genus.
     * @example
     * // Update or create a Genus
     * const genus = await prisma.genus.upsert({
     *   create: {
     *     // ... data to create a Genus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genus we want to update
     *   }
     * })
     */
    upsert<T extends GenusUpsertArgs>(args: SelectSubset<T, GenusUpsertArgs<ExtArgs>>): Prisma__GenusClient<$Result.GetResult<Prisma.$GenusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Genera.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenusCountArgs} args - Arguments to filter Genera to count.
     * @example
     * // Count the number of Genera
     * const count = await prisma.genus.count({
     *   where: {
     *     // ... the filter for the Genera we want to count
     *   }
     * })
    **/
    count<T extends GenusCountArgs>(
      args?: Subset<T, GenusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenusAggregateArgs>(args: Subset<T, GenusAggregateArgs>): Prisma.PrismaPromise<GetGenusAggregateType<T>>

    /**
     * Group by Genus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenusGroupByArgs['orderBy'] }
        : { orderBy?: GenusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Genus model
   */
  readonly fields: GenusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Genus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    species<T extends Genus$speciesArgs<ExtArgs> = {}>(args?: Subset<T, Genus$speciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeciesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Genus model
   */
  interface GenusFieldRefs {
    readonly id: FieldRef<"Genus", 'String'>
    readonly name: FieldRef<"Genus", 'String'>
    readonly type: FieldRef<"Genus", 'PlantType'>
  }
    

  // Custom InputTypes
  /**
   * Genus findUnique
   */
  export type GenusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genus
     */
    select?: GenusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genus
     */
    omit?: GenusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenusInclude<ExtArgs> | null
    /**
     * Filter, which Genus to fetch.
     */
    where: GenusWhereUniqueInput
  }

  /**
   * Genus findUniqueOrThrow
   */
  export type GenusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genus
     */
    select?: GenusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genus
     */
    omit?: GenusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenusInclude<ExtArgs> | null
    /**
     * Filter, which Genus to fetch.
     */
    where: GenusWhereUniqueInput
  }

  /**
   * Genus findFirst
   */
  export type GenusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genus
     */
    select?: GenusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genus
     */
    omit?: GenusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenusInclude<ExtArgs> | null
    /**
     * Filter, which Genus to fetch.
     */
    where?: GenusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genera to fetch.
     */
    orderBy?: GenusOrderByWithRelationInput | GenusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genera.
     */
    cursor?: GenusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genera from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genera.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genera.
     */
    distinct?: GenusScalarFieldEnum | GenusScalarFieldEnum[]
  }

  /**
   * Genus findFirstOrThrow
   */
  export type GenusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genus
     */
    select?: GenusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genus
     */
    omit?: GenusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenusInclude<ExtArgs> | null
    /**
     * Filter, which Genus to fetch.
     */
    where?: GenusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genera to fetch.
     */
    orderBy?: GenusOrderByWithRelationInput | GenusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genera.
     */
    cursor?: GenusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genera from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genera.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genera.
     */
    distinct?: GenusScalarFieldEnum | GenusScalarFieldEnum[]
  }

  /**
   * Genus findMany
   */
  export type GenusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genus
     */
    select?: GenusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genus
     */
    omit?: GenusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenusInclude<ExtArgs> | null
    /**
     * Filter, which Genera to fetch.
     */
    where?: GenusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genera to fetch.
     */
    orderBy?: GenusOrderByWithRelationInput | GenusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genera.
     */
    cursor?: GenusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genera from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genera.
     */
    skip?: number
    distinct?: GenusScalarFieldEnum | GenusScalarFieldEnum[]
  }

  /**
   * Genus create
   */
  export type GenusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genus
     */
    select?: GenusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genus
     */
    omit?: GenusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenusInclude<ExtArgs> | null
    /**
     * The data needed to create a Genus.
     */
    data: XOR<GenusCreateInput, GenusUncheckedCreateInput>
  }

  /**
   * Genus createMany
   */
  export type GenusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Genera.
     */
    data: GenusCreateManyInput | GenusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genus createManyAndReturn
   */
  export type GenusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genus
     */
    select?: GenusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genus
     */
    omit?: GenusOmit<ExtArgs> | null
    /**
     * The data used to create many Genera.
     */
    data: GenusCreateManyInput | GenusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genus update
   */
  export type GenusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genus
     */
    select?: GenusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genus
     */
    omit?: GenusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenusInclude<ExtArgs> | null
    /**
     * The data needed to update a Genus.
     */
    data: XOR<GenusUpdateInput, GenusUncheckedUpdateInput>
    /**
     * Choose, which Genus to update.
     */
    where: GenusWhereUniqueInput
  }

  /**
   * Genus updateMany
   */
  export type GenusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Genera.
     */
    data: XOR<GenusUpdateManyMutationInput, GenusUncheckedUpdateManyInput>
    /**
     * Filter which Genera to update
     */
    where?: GenusWhereInput
    /**
     * Limit how many Genera to update.
     */
    limit?: number
  }

  /**
   * Genus updateManyAndReturn
   */
  export type GenusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genus
     */
    select?: GenusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genus
     */
    omit?: GenusOmit<ExtArgs> | null
    /**
     * The data used to update Genera.
     */
    data: XOR<GenusUpdateManyMutationInput, GenusUncheckedUpdateManyInput>
    /**
     * Filter which Genera to update
     */
    where?: GenusWhereInput
    /**
     * Limit how many Genera to update.
     */
    limit?: number
  }

  /**
   * Genus upsert
   */
  export type GenusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genus
     */
    select?: GenusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genus
     */
    omit?: GenusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenusInclude<ExtArgs> | null
    /**
     * The filter to search for the Genus to update in case it exists.
     */
    where: GenusWhereUniqueInput
    /**
     * In case the Genus found by the `where` argument doesn't exist, create a new Genus with this data.
     */
    create: XOR<GenusCreateInput, GenusUncheckedCreateInput>
    /**
     * In case the Genus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenusUpdateInput, GenusUncheckedUpdateInput>
  }

  /**
   * Genus delete
   */
  export type GenusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genus
     */
    select?: GenusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genus
     */
    omit?: GenusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenusInclude<ExtArgs> | null
    /**
     * Filter which Genus to delete.
     */
    where: GenusWhereUniqueInput
  }

  /**
   * Genus deleteMany
   */
  export type GenusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genera to delete
     */
    where?: GenusWhereInput
    /**
     * Limit how many Genera to delete.
     */
    limit?: number
  }

  /**
   * Genus.species
   */
  export type Genus$speciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Species
     */
    select?: SpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Species
     */
    omit?: SpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesInclude<ExtArgs> | null
    where?: SpeciesWhereInput
    orderBy?: SpeciesOrderByWithRelationInput | SpeciesOrderByWithRelationInput[]
    cursor?: SpeciesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpeciesScalarFieldEnum | SpeciesScalarFieldEnum[]
  }

  /**
   * Genus without action
   */
  export type GenusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genus
     */
    select?: GenusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genus
     */
    omit?: GenusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenusInclude<ExtArgs> | null
  }


  /**
   * Model Species
   */

  export type AggregateSpecies = {
    _count: SpeciesCountAggregateOutputType | null
    _avg: SpeciesAvgAggregateOutputType | null
    _sum: SpeciesSumAggregateOutputType | null
    _min: SpeciesMinAggregateOutputType | null
    _max: SpeciesMaxAggregateOutputType | null
  }

  export type SpeciesAvgAggregateOutputType = {
    price: number | null
  }

  export type SpeciesSumAggregateOutputType = {
    price: number | null
  }

  export type SpeciesMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    slug: string | null
    description: string | null
    genusId: string | null
    stockId: string | null
  }

  export type SpeciesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    slug: string | null
    description: string | null
    genusId: string | null
    stockId: string | null
  }

  export type SpeciesCountAggregateOutputType = {
    id: number
    name: number
    price: number
    slug: number
    description: number
    genusId: number
    stockId: number
    _all: number
  }


  export type SpeciesAvgAggregateInputType = {
    price?: true
  }

  export type SpeciesSumAggregateInputType = {
    price?: true
  }

  export type SpeciesMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    slug?: true
    description?: true
    genusId?: true
    stockId?: true
  }

  export type SpeciesMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    slug?: true
    description?: true
    genusId?: true
    stockId?: true
  }

  export type SpeciesCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    slug?: true
    description?: true
    genusId?: true
    stockId?: true
    _all?: true
  }

  export type SpeciesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Species to aggregate.
     */
    where?: SpeciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Species to fetch.
     */
    orderBy?: SpeciesOrderByWithRelationInput | SpeciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpeciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Species from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Species.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Species
    **/
    _count?: true | SpeciesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpeciesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpeciesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeciesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeciesMaxAggregateInputType
  }

  export type GetSpeciesAggregateType<T extends SpeciesAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecies[P]>
      : GetScalarType<T[P], AggregateSpecies[P]>
  }




  export type SpeciesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeciesWhereInput
    orderBy?: SpeciesOrderByWithAggregationInput | SpeciesOrderByWithAggregationInput[]
    by: SpeciesScalarFieldEnum[] | SpeciesScalarFieldEnum
    having?: SpeciesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeciesCountAggregateInputType | true
    _avg?: SpeciesAvgAggregateInputType
    _sum?: SpeciesSumAggregateInputType
    _min?: SpeciesMinAggregateInputType
    _max?: SpeciesMaxAggregateInputType
  }

  export type SpeciesGroupByOutputType = {
    id: string
    name: string
    price: number
    slug: string
    description: string | null
    genusId: string
    stockId: string
    _count: SpeciesCountAggregateOutputType | null
    _avg: SpeciesAvgAggregateOutputType | null
    _sum: SpeciesSumAggregateOutputType | null
    _min: SpeciesMinAggregateOutputType | null
    _max: SpeciesMaxAggregateOutputType | null
  }

  type GetSpeciesGroupByPayload<T extends SpeciesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeciesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeciesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeciesGroupByOutputType[P]>
            : GetScalarType<T[P], SpeciesGroupByOutputType[P]>
        }
      >
    >


  export type SpeciesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    slug?: boolean
    description?: boolean
    genusId?: boolean
    stockId?: boolean
    genus?: boolean | GenusDefaultArgs<ExtArgs>
    stock?: boolean | StockDefaultArgs<ExtArgs>
    plants?: boolean | Species$plantsArgs<ExtArgs>
    images?: boolean | Species$imagesArgs<ExtArgs>
    _count?: boolean | SpeciesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["species"]>

  export type SpeciesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    slug?: boolean
    description?: boolean
    genusId?: boolean
    stockId?: boolean
    genus?: boolean | GenusDefaultArgs<ExtArgs>
    stock?: boolean | StockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["species"]>

  export type SpeciesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    slug?: boolean
    description?: boolean
    genusId?: boolean
    stockId?: boolean
    genus?: boolean | GenusDefaultArgs<ExtArgs>
    stock?: boolean | StockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["species"]>

  export type SpeciesSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    slug?: boolean
    description?: boolean
    genusId?: boolean
    stockId?: boolean
  }

  export type SpeciesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "slug" | "description" | "genusId" | "stockId", ExtArgs["result"]["species"]>
  export type SpeciesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genus?: boolean | GenusDefaultArgs<ExtArgs>
    stock?: boolean | StockDefaultArgs<ExtArgs>
    plants?: boolean | Species$plantsArgs<ExtArgs>
    images?: boolean | Species$imagesArgs<ExtArgs>
    _count?: boolean | SpeciesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpeciesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genus?: boolean | GenusDefaultArgs<ExtArgs>
    stock?: boolean | StockDefaultArgs<ExtArgs>
  }
  export type SpeciesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genus?: boolean | GenusDefaultArgs<ExtArgs>
    stock?: boolean | StockDefaultArgs<ExtArgs>
  }

  export type $SpeciesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Species"
    objects: {
      genus: Prisma.$GenusPayload<ExtArgs>
      stock: Prisma.$StockPayload<ExtArgs>
      plants: Prisma.$PlantPayload<ExtArgs>[]
      images: Prisma.$SpeciesImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: number
      slug: string
      description: string | null
      genusId: string
      stockId: string
    }, ExtArgs["result"]["species"]>
    composites: {}
  }

  type SpeciesGetPayload<S extends boolean | null | undefined | SpeciesDefaultArgs> = $Result.GetResult<Prisma.$SpeciesPayload, S>

  type SpeciesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpeciesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpeciesCountAggregateInputType | true
    }

  export interface SpeciesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Species'], meta: { name: 'Species' } }
    /**
     * Find zero or one Species that matches the filter.
     * @param {SpeciesFindUniqueArgs} args - Arguments to find a Species
     * @example
     * // Get one Species
     * const species = await prisma.species.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpeciesFindUniqueArgs>(args: SelectSubset<T, SpeciesFindUniqueArgs<ExtArgs>>): Prisma__SpeciesClient<$Result.GetResult<Prisma.$SpeciesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Species that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpeciesFindUniqueOrThrowArgs} args - Arguments to find a Species
     * @example
     * // Get one Species
     * const species = await prisma.species.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpeciesFindUniqueOrThrowArgs>(args: SelectSubset<T, SpeciesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpeciesClient<$Result.GetResult<Prisma.$SpeciesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Species that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesFindFirstArgs} args - Arguments to find a Species
     * @example
     * // Get one Species
     * const species = await prisma.species.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpeciesFindFirstArgs>(args?: SelectSubset<T, SpeciesFindFirstArgs<ExtArgs>>): Prisma__SpeciesClient<$Result.GetResult<Prisma.$SpeciesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Species that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesFindFirstOrThrowArgs} args - Arguments to find a Species
     * @example
     * // Get one Species
     * const species = await prisma.species.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpeciesFindFirstOrThrowArgs>(args?: SelectSubset<T, SpeciesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpeciesClient<$Result.GetResult<Prisma.$SpeciesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Species that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Species
     * const species = await prisma.species.findMany()
     * 
     * // Get first 10 Species
     * const species = await prisma.species.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speciesWithIdOnly = await prisma.species.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpeciesFindManyArgs>(args?: SelectSubset<T, SpeciesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeciesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Species.
     * @param {SpeciesCreateArgs} args - Arguments to create a Species.
     * @example
     * // Create one Species
     * const Species = await prisma.species.create({
     *   data: {
     *     // ... data to create a Species
     *   }
     * })
     * 
     */
    create<T extends SpeciesCreateArgs>(args: SelectSubset<T, SpeciesCreateArgs<ExtArgs>>): Prisma__SpeciesClient<$Result.GetResult<Prisma.$SpeciesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Species.
     * @param {SpeciesCreateManyArgs} args - Arguments to create many Species.
     * @example
     * // Create many Species
     * const species = await prisma.species.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpeciesCreateManyArgs>(args?: SelectSubset<T, SpeciesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Species and returns the data saved in the database.
     * @param {SpeciesCreateManyAndReturnArgs} args - Arguments to create many Species.
     * @example
     * // Create many Species
     * const species = await prisma.species.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Species and only return the `id`
     * const speciesWithIdOnly = await prisma.species.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpeciesCreateManyAndReturnArgs>(args?: SelectSubset<T, SpeciesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeciesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Species.
     * @param {SpeciesDeleteArgs} args - Arguments to delete one Species.
     * @example
     * // Delete one Species
     * const Species = await prisma.species.delete({
     *   where: {
     *     // ... filter to delete one Species
     *   }
     * })
     * 
     */
    delete<T extends SpeciesDeleteArgs>(args: SelectSubset<T, SpeciesDeleteArgs<ExtArgs>>): Prisma__SpeciesClient<$Result.GetResult<Prisma.$SpeciesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Species.
     * @param {SpeciesUpdateArgs} args - Arguments to update one Species.
     * @example
     * // Update one Species
     * const species = await prisma.species.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpeciesUpdateArgs>(args: SelectSubset<T, SpeciesUpdateArgs<ExtArgs>>): Prisma__SpeciesClient<$Result.GetResult<Prisma.$SpeciesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Species.
     * @param {SpeciesDeleteManyArgs} args - Arguments to filter Species to delete.
     * @example
     * // Delete a few Species
     * const { count } = await prisma.species.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpeciesDeleteManyArgs>(args?: SelectSubset<T, SpeciesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Species.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Species
     * const species = await prisma.species.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpeciesUpdateManyArgs>(args: SelectSubset<T, SpeciesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Species and returns the data updated in the database.
     * @param {SpeciesUpdateManyAndReturnArgs} args - Arguments to update many Species.
     * @example
     * // Update many Species
     * const species = await prisma.species.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Species and only return the `id`
     * const speciesWithIdOnly = await prisma.species.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpeciesUpdateManyAndReturnArgs>(args: SelectSubset<T, SpeciesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeciesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Species.
     * @param {SpeciesUpsertArgs} args - Arguments to update or create a Species.
     * @example
     * // Update or create a Species
     * const species = await prisma.species.upsert({
     *   create: {
     *     // ... data to create a Species
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Species we want to update
     *   }
     * })
     */
    upsert<T extends SpeciesUpsertArgs>(args: SelectSubset<T, SpeciesUpsertArgs<ExtArgs>>): Prisma__SpeciesClient<$Result.GetResult<Prisma.$SpeciesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Species.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesCountArgs} args - Arguments to filter Species to count.
     * @example
     * // Count the number of Species
     * const count = await prisma.species.count({
     *   where: {
     *     // ... the filter for the Species we want to count
     *   }
     * })
    **/
    count<T extends SpeciesCountArgs>(
      args?: Subset<T, SpeciesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeciesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Species.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeciesAggregateArgs>(args: Subset<T, SpeciesAggregateArgs>): Prisma.PrismaPromise<GetSpeciesAggregateType<T>>

    /**
     * Group by Species.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeciesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeciesGroupByArgs['orderBy'] }
        : { orderBy?: SpeciesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeciesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeciesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Species model
   */
  readonly fields: SpeciesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Species.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpeciesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    genus<T extends GenusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenusDefaultArgs<ExtArgs>>): Prisma__GenusClient<$Result.GetResult<Prisma.$GenusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stock<T extends StockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockDefaultArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plants<T extends Species$plantsArgs<ExtArgs> = {}>(args?: Subset<T, Species$plantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    images<T extends Species$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Species$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeciesImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Species model
   */
  interface SpeciesFieldRefs {
    readonly id: FieldRef<"Species", 'String'>
    readonly name: FieldRef<"Species", 'String'>
    readonly price: FieldRef<"Species", 'Int'>
    readonly slug: FieldRef<"Species", 'String'>
    readonly description: FieldRef<"Species", 'String'>
    readonly genusId: FieldRef<"Species", 'String'>
    readonly stockId: FieldRef<"Species", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Species findUnique
   */
  export type SpeciesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Species
     */
    select?: SpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Species
     */
    omit?: SpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesInclude<ExtArgs> | null
    /**
     * Filter, which Species to fetch.
     */
    where: SpeciesWhereUniqueInput
  }

  /**
   * Species findUniqueOrThrow
   */
  export type SpeciesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Species
     */
    select?: SpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Species
     */
    omit?: SpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesInclude<ExtArgs> | null
    /**
     * Filter, which Species to fetch.
     */
    where: SpeciesWhereUniqueInput
  }

  /**
   * Species findFirst
   */
  export type SpeciesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Species
     */
    select?: SpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Species
     */
    omit?: SpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesInclude<ExtArgs> | null
    /**
     * Filter, which Species to fetch.
     */
    where?: SpeciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Species to fetch.
     */
    orderBy?: SpeciesOrderByWithRelationInput | SpeciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Species.
     */
    cursor?: SpeciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Species from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Species.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Species.
     */
    distinct?: SpeciesScalarFieldEnum | SpeciesScalarFieldEnum[]
  }

  /**
   * Species findFirstOrThrow
   */
  export type SpeciesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Species
     */
    select?: SpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Species
     */
    omit?: SpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesInclude<ExtArgs> | null
    /**
     * Filter, which Species to fetch.
     */
    where?: SpeciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Species to fetch.
     */
    orderBy?: SpeciesOrderByWithRelationInput | SpeciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Species.
     */
    cursor?: SpeciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Species from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Species.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Species.
     */
    distinct?: SpeciesScalarFieldEnum | SpeciesScalarFieldEnum[]
  }

  /**
   * Species findMany
   */
  export type SpeciesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Species
     */
    select?: SpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Species
     */
    omit?: SpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesInclude<ExtArgs> | null
    /**
     * Filter, which Species to fetch.
     */
    where?: SpeciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Species to fetch.
     */
    orderBy?: SpeciesOrderByWithRelationInput | SpeciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Species.
     */
    cursor?: SpeciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Species from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Species.
     */
    skip?: number
    distinct?: SpeciesScalarFieldEnum | SpeciesScalarFieldEnum[]
  }

  /**
   * Species create
   */
  export type SpeciesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Species
     */
    select?: SpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Species
     */
    omit?: SpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesInclude<ExtArgs> | null
    /**
     * The data needed to create a Species.
     */
    data: XOR<SpeciesCreateInput, SpeciesUncheckedCreateInput>
  }

  /**
   * Species createMany
   */
  export type SpeciesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Species.
     */
    data: SpeciesCreateManyInput | SpeciesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Species createManyAndReturn
   */
  export type SpeciesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Species
     */
    select?: SpeciesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Species
     */
    omit?: SpeciesOmit<ExtArgs> | null
    /**
     * The data used to create many Species.
     */
    data: SpeciesCreateManyInput | SpeciesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Species update
   */
  export type SpeciesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Species
     */
    select?: SpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Species
     */
    omit?: SpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesInclude<ExtArgs> | null
    /**
     * The data needed to update a Species.
     */
    data: XOR<SpeciesUpdateInput, SpeciesUncheckedUpdateInput>
    /**
     * Choose, which Species to update.
     */
    where: SpeciesWhereUniqueInput
  }

  /**
   * Species updateMany
   */
  export type SpeciesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Species.
     */
    data: XOR<SpeciesUpdateManyMutationInput, SpeciesUncheckedUpdateManyInput>
    /**
     * Filter which Species to update
     */
    where?: SpeciesWhereInput
    /**
     * Limit how many Species to update.
     */
    limit?: number
  }

  /**
   * Species updateManyAndReturn
   */
  export type SpeciesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Species
     */
    select?: SpeciesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Species
     */
    omit?: SpeciesOmit<ExtArgs> | null
    /**
     * The data used to update Species.
     */
    data: XOR<SpeciesUpdateManyMutationInput, SpeciesUncheckedUpdateManyInput>
    /**
     * Filter which Species to update
     */
    where?: SpeciesWhereInput
    /**
     * Limit how many Species to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Species upsert
   */
  export type SpeciesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Species
     */
    select?: SpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Species
     */
    omit?: SpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesInclude<ExtArgs> | null
    /**
     * The filter to search for the Species to update in case it exists.
     */
    where: SpeciesWhereUniqueInput
    /**
     * In case the Species found by the `where` argument doesn't exist, create a new Species with this data.
     */
    create: XOR<SpeciesCreateInput, SpeciesUncheckedCreateInput>
    /**
     * In case the Species was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpeciesUpdateInput, SpeciesUncheckedUpdateInput>
  }

  /**
   * Species delete
   */
  export type SpeciesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Species
     */
    select?: SpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Species
     */
    omit?: SpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesInclude<ExtArgs> | null
    /**
     * Filter which Species to delete.
     */
    where: SpeciesWhereUniqueInput
  }

  /**
   * Species deleteMany
   */
  export type SpeciesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Species to delete
     */
    where?: SpeciesWhereInput
    /**
     * Limit how many Species to delete.
     */
    limit?: number
  }

  /**
   * Species.plants
   */
  export type Species$plantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    where?: PlantWhereInput
    orderBy?: PlantOrderByWithRelationInput | PlantOrderByWithRelationInput[]
    cursor?: PlantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlantScalarFieldEnum | PlantScalarFieldEnum[]
  }

  /**
   * Species.images
   */
  export type Species$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeciesImage
     */
    select?: SpeciesImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeciesImage
     */
    omit?: SpeciesImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesImageInclude<ExtArgs> | null
    where?: SpeciesImageWhereInput
    orderBy?: SpeciesImageOrderByWithRelationInput | SpeciesImageOrderByWithRelationInput[]
    cursor?: SpeciesImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpeciesImageScalarFieldEnum | SpeciesImageScalarFieldEnum[]
  }

  /**
   * Species without action
   */
  export type SpeciesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Species
     */
    select?: SpeciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Species
     */
    omit?: SpeciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesInclude<ExtArgs> | null
  }


  /**
   * Model SpeciesImage
   */

  export type AggregateSpeciesImage = {
    _count: SpeciesImageCountAggregateOutputType | null
    _min: SpeciesImageMinAggregateOutputType | null
    _max: SpeciesImageMaxAggregateOutputType | null
  }

  export type SpeciesImageMinAggregateOutputType = {
    id: string | null
    url: string | null
    speciesId: string | null
  }

  export type SpeciesImageMaxAggregateOutputType = {
    id: string | null
    url: string | null
    speciesId: string | null
  }

  export type SpeciesImageCountAggregateOutputType = {
    id: number
    url: number
    speciesId: number
    _all: number
  }


  export type SpeciesImageMinAggregateInputType = {
    id?: true
    url?: true
    speciesId?: true
  }

  export type SpeciesImageMaxAggregateInputType = {
    id?: true
    url?: true
    speciesId?: true
  }

  export type SpeciesImageCountAggregateInputType = {
    id?: true
    url?: true
    speciesId?: true
    _all?: true
  }

  export type SpeciesImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeciesImage to aggregate.
     */
    where?: SpeciesImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeciesImages to fetch.
     */
    orderBy?: SpeciesImageOrderByWithRelationInput | SpeciesImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpeciesImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeciesImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeciesImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpeciesImages
    **/
    _count?: true | SpeciesImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeciesImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeciesImageMaxAggregateInputType
  }

  export type GetSpeciesImageAggregateType<T extends SpeciesImageAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeciesImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeciesImage[P]>
      : GetScalarType<T[P], AggregateSpeciesImage[P]>
  }




  export type SpeciesImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeciesImageWhereInput
    orderBy?: SpeciesImageOrderByWithAggregationInput | SpeciesImageOrderByWithAggregationInput[]
    by: SpeciesImageScalarFieldEnum[] | SpeciesImageScalarFieldEnum
    having?: SpeciesImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeciesImageCountAggregateInputType | true
    _min?: SpeciesImageMinAggregateInputType
    _max?: SpeciesImageMaxAggregateInputType
  }

  export type SpeciesImageGroupByOutputType = {
    id: string
    url: string
    speciesId: string
    _count: SpeciesImageCountAggregateOutputType | null
    _min: SpeciesImageMinAggregateOutputType | null
    _max: SpeciesImageMaxAggregateOutputType | null
  }

  type GetSpeciesImageGroupByPayload<T extends SpeciesImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeciesImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeciesImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeciesImageGroupByOutputType[P]>
            : GetScalarType<T[P], SpeciesImageGroupByOutputType[P]>
        }
      >
    >


  export type SpeciesImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    speciesId?: boolean
    species?: boolean | SpeciesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speciesImage"]>

  export type SpeciesImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    speciesId?: boolean
    species?: boolean | SpeciesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speciesImage"]>

  export type SpeciesImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    speciesId?: boolean
    species?: boolean | SpeciesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speciesImage"]>

  export type SpeciesImageSelectScalar = {
    id?: boolean
    url?: boolean
    speciesId?: boolean
  }

  export type SpeciesImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "speciesId", ExtArgs["result"]["speciesImage"]>
  export type SpeciesImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    species?: boolean | SpeciesDefaultArgs<ExtArgs>
  }
  export type SpeciesImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    species?: boolean | SpeciesDefaultArgs<ExtArgs>
  }
  export type SpeciesImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    species?: boolean | SpeciesDefaultArgs<ExtArgs>
  }

  export type $SpeciesImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpeciesImage"
    objects: {
      species: Prisma.$SpeciesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      speciesId: string
    }, ExtArgs["result"]["speciesImage"]>
    composites: {}
  }

  type SpeciesImageGetPayload<S extends boolean | null | undefined | SpeciesImageDefaultArgs> = $Result.GetResult<Prisma.$SpeciesImagePayload, S>

  type SpeciesImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpeciesImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpeciesImageCountAggregateInputType | true
    }

  export interface SpeciesImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpeciesImage'], meta: { name: 'SpeciesImage' } }
    /**
     * Find zero or one SpeciesImage that matches the filter.
     * @param {SpeciesImageFindUniqueArgs} args - Arguments to find a SpeciesImage
     * @example
     * // Get one SpeciesImage
     * const speciesImage = await prisma.speciesImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpeciesImageFindUniqueArgs>(args: SelectSubset<T, SpeciesImageFindUniqueArgs<ExtArgs>>): Prisma__SpeciesImageClient<$Result.GetResult<Prisma.$SpeciesImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpeciesImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpeciesImageFindUniqueOrThrowArgs} args - Arguments to find a SpeciesImage
     * @example
     * // Get one SpeciesImage
     * const speciesImage = await prisma.speciesImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpeciesImageFindUniqueOrThrowArgs>(args: SelectSubset<T, SpeciesImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpeciesImageClient<$Result.GetResult<Prisma.$SpeciesImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpeciesImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesImageFindFirstArgs} args - Arguments to find a SpeciesImage
     * @example
     * // Get one SpeciesImage
     * const speciesImage = await prisma.speciesImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpeciesImageFindFirstArgs>(args?: SelectSubset<T, SpeciesImageFindFirstArgs<ExtArgs>>): Prisma__SpeciesImageClient<$Result.GetResult<Prisma.$SpeciesImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpeciesImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesImageFindFirstOrThrowArgs} args - Arguments to find a SpeciesImage
     * @example
     * // Get one SpeciesImage
     * const speciesImage = await prisma.speciesImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpeciesImageFindFirstOrThrowArgs>(args?: SelectSubset<T, SpeciesImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpeciesImageClient<$Result.GetResult<Prisma.$SpeciesImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpeciesImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpeciesImages
     * const speciesImages = await prisma.speciesImage.findMany()
     * 
     * // Get first 10 SpeciesImages
     * const speciesImages = await prisma.speciesImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speciesImageWithIdOnly = await prisma.speciesImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpeciesImageFindManyArgs>(args?: SelectSubset<T, SpeciesImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeciesImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpeciesImage.
     * @param {SpeciesImageCreateArgs} args - Arguments to create a SpeciesImage.
     * @example
     * // Create one SpeciesImage
     * const SpeciesImage = await prisma.speciesImage.create({
     *   data: {
     *     // ... data to create a SpeciesImage
     *   }
     * })
     * 
     */
    create<T extends SpeciesImageCreateArgs>(args: SelectSubset<T, SpeciesImageCreateArgs<ExtArgs>>): Prisma__SpeciesImageClient<$Result.GetResult<Prisma.$SpeciesImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpeciesImages.
     * @param {SpeciesImageCreateManyArgs} args - Arguments to create many SpeciesImages.
     * @example
     * // Create many SpeciesImages
     * const speciesImage = await prisma.speciesImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpeciesImageCreateManyArgs>(args?: SelectSubset<T, SpeciesImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpeciesImages and returns the data saved in the database.
     * @param {SpeciesImageCreateManyAndReturnArgs} args - Arguments to create many SpeciesImages.
     * @example
     * // Create many SpeciesImages
     * const speciesImage = await prisma.speciesImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpeciesImages and only return the `id`
     * const speciesImageWithIdOnly = await prisma.speciesImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpeciesImageCreateManyAndReturnArgs>(args?: SelectSubset<T, SpeciesImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeciesImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpeciesImage.
     * @param {SpeciesImageDeleteArgs} args - Arguments to delete one SpeciesImage.
     * @example
     * // Delete one SpeciesImage
     * const SpeciesImage = await prisma.speciesImage.delete({
     *   where: {
     *     // ... filter to delete one SpeciesImage
     *   }
     * })
     * 
     */
    delete<T extends SpeciesImageDeleteArgs>(args: SelectSubset<T, SpeciesImageDeleteArgs<ExtArgs>>): Prisma__SpeciesImageClient<$Result.GetResult<Prisma.$SpeciesImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpeciesImage.
     * @param {SpeciesImageUpdateArgs} args - Arguments to update one SpeciesImage.
     * @example
     * // Update one SpeciesImage
     * const speciesImage = await prisma.speciesImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpeciesImageUpdateArgs>(args: SelectSubset<T, SpeciesImageUpdateArgs<ExtArgs>>): Prisma__SpeciesImageClient<$Result.GetResult<Prisma.$SpeciesImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpeciesImages.
     * @param {SpeciesImageDeleteManyArgs} args - Arguments to filter SpeciesImages to delete.
     * @example
     * // Delete a few SpeciesImages
     * const { count } = await prisma.speciesImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpeciesImageDeleteManyArgs>(args?: SelectSubset<T, SpeciesImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpeciesImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpeciesImages
     * const speciesImage = await prisma.speciesImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpeciesImageUpdateManyArgs>(args: SelectSubset<T, SpeciesImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpeciesImages and returns the data updated in the database.
     * @param {SpeciesImageUpdateManyAndReturnArgs} args - Arguments to update many SpeciesImages.
     * @example
     * // Update many SpeciesImages
     * const speciesImage = await prisma.speciesImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpeciesImages and only return the `id`
     * const speciesImageWithIdOnly = await prisma.speciesImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpeciesImageUpdateManyAndReturnArgs>(args: SelectSubset<T, SpeciesImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeciesImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpeciesImage.
     * @param {SpeciesImageUpsertArgs} args - Arguments to update or create a SpeciesImage.
     * @example
     * // Update or create a SpeciesImage
     * const speciesImage = await prisma.speciesImage.upsert({
     *   create: {
     *     // ... data to create a SpeciesImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpeciesImage we want to update
     *   }
     * })
     */
    upsert<T extends SpeciesImageUpsertArgs>(args: SelectSubset<T, SpeciesImageUpsertArgs<ExtArgs>>): Prisma__SpeciesImageClient<$Result.GetResult<Prisma.$SpeciesImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpeciesImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesImageCountArgs} args - Arguments to filter SpeciesImages to count.
     * @example
     * // Count the number of SpeciesImages
     * const count = await prisma.speciesImage.count({
     *   where: {
     *     // ... the filter for the SpeciesImages we want to count
     *   }
     * })
    **/
    count<T extends SpeciesImageCountArgs>(
      args?: Subset<T, SpeciesImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeciesImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpeciesImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeciesImageAggregateArgs>(args: Subset<T, SpeciesImageAggregateArgs>): Prisma.PrismaPromise<GetSpeciesImageAggregateType<T>>

    /**
     * Group by SpeciesImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeciesImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeciesImageGroupByArgs['orderBy'] }
        : { orderBy?: SpeciesImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeciesImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeciesImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpeciesImage model
   */
  readonly fields: SpeciesImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpeciesImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpeciesImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    species<T extends SpeciesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpeciesDefaultArgs<ExtArgs>>): Prisma__SpeciesClient<$Result.GetResult<Prisma.$SpeciesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpeciesImage model
   */
  interface SpeciesImageFieldRefs {
    readonly id: FieldRef<"SpeciesImage", 'String'>
    readonly url: FieldRef<"SpeciesImage", 'String'>
    readonly speciesId: FieldRef<"SpeciesImage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SpeciesImage findUnique
   */
  export type SpeciesImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeciesImage
     */
    select?: SpeciesImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeciesImage
     */
    omit?: SpeciesImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesImageInclude<ExtArgs> | null
    /**
     * Filter, which SpeciesImage to fetch.
     */
    where: SpeciesImageWhereUniqueInput
  }

  /**
   * SpeciesImage findUniqueOrThrow
   */
  export type SpeciesImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeciesImage
     */
    select?: SpeciesImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeciesImage
     */
    omit?: SpeciesImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesImageInclude<ExtArgs> | null
    /**
     * Filter, which SpeciesImage to fetch.
     */
    where: SpeciesImageWhereUniqueInput
  }

  /**
   * SpeciesImage findFirst
   */
  export type SpeciesImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeciesImage
     */
    select?: SpeciesImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeciesImage
     */
    omit?: SpeciesImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesImageInclude<ExtArgs> | null
    /**
     * Filter, which SpeciesImage to fetch.
     */
    where?: SpeciesImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeciesImages to fetch.
     */
    orderBy?: SpeciesImageOrderByWithRelationInput | SpeciesImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeciesImages.
     */
    cursor?: SpeciesImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeciesImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeciesImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeciesImages.
     */
    distinct?: SpeciesImageScalarFieldEnum | SpeciesImageScalarFieldEnum[]
  }

  /**
   * SpeciesImage findFirstOrThrow
   */
  export type SpeciesImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeciesImage
     */
    select?: SpeciesImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeciesImage
     */
    omit?: SpeciesImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesImageInclude<ExtArgs> | null
    /**
     * Filter, which SpeciesImage to fetch.
     */
    where?: SpeciesImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeciesImages to fetch.
     */
    orderBy?: SpeciesImageOrderByWithRelationInput | SpeciesImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeciesImages.
     */
    cursor?: SpeciesImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeciesImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeciesImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeciesImages.
     */
    distinct?: SpeciesImageScalarFieldEnum | SpeciesImageScalarFieldEnum[]
  }

  /**
   * SpeciesImage findMany
   */
  export type SpeciesImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeciesImage
     */
    select?: SpeciesImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeciesImage
     */
    omit?: SpeciesImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesImageInclude<ExtArgs> | null
    /**
     * Filter, which SpeciesImages to fetch.
     */
    where?: SpeciesImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeciesImages to fetch.
     */
    orderBy?: SpeciesImageOrderByWithRelationInput | SpeciesImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpeciesImages.
     */
    cursor?: SpeciesImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeciesImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeciesImages.
     */
    skip?: number
    distinct?: SpeciesImageScalarFieldEnum | SpeciesImageScalarFieldEnum[]
  }

  /**
   * SpeciesImage create
   */
  export type SpeciesImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeciesImage
     */
    select?: SpeciesImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeciesImage
     */
    omit?: SpeciesImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesImageInclude<ExtArgs> | null
    /**
     * The data needed to create a SpeciesImage.
     */
    data: XOR<SpeciesImageCreateInput, SpeciesImageUncheckedCreateInput>
  }

  /**
   * SpeciesImage createMany
   */
  export type SpeciesImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpeciesImages.
     */
    data: SpeciesImageCreateManyInput | SpeciesImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpeciesImage createManyAndReturn
   */
  export type SpeciesImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeciesImage
     */
    select?: SpeciesImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpeciesImage
     */
    omit?: SpeciesImageOmit<ExtArgs> | null
    /**
     * The data used to create many SpeciesImages.
     */
    data: SpeciesImageCreateManyInput | SpeciesImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpeciesImage update
   */
  export type SpeciesImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeciesImage
     */
    select?: SpeciesImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeciesImage
     */
    omit?: SpeciesImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesImageInclude<ExtArgs> | null
    /**
     * The data needed to update a SpeciesImage.
     */
    data: XOR<SpeciesImageUpdateInput, SpeciesImageUncheckedUpdateInput>
    /**
     * Choose, which SpeciesImage to update.
     */
    where: SpeciesImageWhereUniqueInput
  }

  /**
   * SpeciesImage updateMany
   */
  export type SpeciesImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpeciesImages.
     */
    data: XOR<SpeciesImageUpdateManyMutationInput, SpeciesImageUncheckedUpdateManyInput>
    /**
     * Filter which SpeciesImages to update
     */
    where?: SpeciesImageWhereInput
    /**
     * Limit how many SpeciesImages to update.
     */
    limit?: number
  }

  /**
   * SpeciesImage updateManyAndReturn
   */
  export type SpeciesImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeciesImage
     */
    select?: SpeciesImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpeciesImage
     */
    omit?: SpeciesImageOmit<ExtArgs> | null
    /**
     * The data used to update SpeciesImages.
     */
    data: XOR<SpeciesImageUpdateManyMutationInput, SpeciesImageUncheckedUpdateManyInput>
    /**
     * Filter which SpeciesImages to update
     */
    where?: SpeciesImageWhereInput
    /**
     * Limit how many SpeciesImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpeciesImage upsert
   */
  export type SpeciesImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeciesImage
     */
    select?: SpeciesImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeciesImage
     */
    omit?: SpeciesImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesImageInclude<ExtArgs> | null
    /**
     * The filter to search for the SpeciesImage to update in case it exists.
     */
    where: SpeciesImageWhereUniqueInput
    /**
     * In case the SpeciesImage found by the `where` argument doesn't exist, create a new SpeciesImage with this data.
     */
    create: XOR<SpeciesImageCreateInput, SpeciesImageUncheckedCreateInput>
    /**
     * In case the SpeciesImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpeciesImageUpdateInput, SpeciesImageUncheckedUpdateInput>
  }

  /**
   * SpeciesImage delete
   */
  export type SpeciesImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeciesImage
     */
    select?: SpeciesImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeciesImage
     */
    omit?: SpeciesImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesImageInclude<ExtArgs> | null
    /**
     * Filter which SpeciesImage to delete.
     */
    where: SpeciesImageWhereUniqueInput
  }

  /**
   * SpeciesImage deleteMany
   */
  export type SpeciesImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeciesImages to delete
     */
    where?: SpeciesImageWhereInput
    /**
     * Limit how many SpeciesImages to delete.
     */
    limit?: number
  }

  /**
   * SpeciesImage without action
   */
  export type SpeciesImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeciesImage
     */
    select?: SpeciesImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeciesImage
     */
    omit?: SpeciesImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeciesImageInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    zone: $Enums.ZoneType | null
    table: $Enums.TableType | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    zone: $Enums.ZoneType | null
    table: $Enums.TableType | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    zone: number
    table: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    zone?: true
    table?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    zone?: true
    table?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    zone?: true
    table?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    zone: $Enums.ZoneType
    table: $Enums.TableType
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zone?: boolean
    table?: boolean
    plants?: boolean | Location$plantsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zone?: boolean
    table?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zone?: boolean
    table?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    zone?: boolean
    table?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "zone" | "table", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plants?: boolean | Location$plantsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      plants: Prisma.$PlantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      zone: $Enums.ZoneType
      table: $Enums.TableType
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plants<T extends Location$plantsArgs<ExtArgs> = {}>(args?: Subset<T, Location$plantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly zone: FieldRef<"Location", 'ZoneType'>
    readonly table: FieldRef<"Location", 'TableType'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.plants
   */
  export type Location$plantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    where?: PlantWhereInput
    orderBy?: PlantOrderByWithRelationInput | PlantOrderByWithRelationInput[]
    cursor?: PlantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlantScalarFieldEnum | PlantScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Plant
   */

  export type AggregatePlant = {
    _count: PlantCountAggregateOutputType | null
    _min: PlantMinAggregateOutputType | null
    _max: PlantMaxAggregateOutputType | null
  }

  export type PlantMinAggregateOutputType = {
    id: string | null
    pottingDate: Date | null
    speciesId: string | null
    locationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlantMaxAggregateOutputType = {
    id: string | null
    pottingDate: Date | null
    speciesId: string | null
    locationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlantCountAggregateOutputType = {
    id: number
    pottingDate: number
    speciesId: number
    locationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlantMinAggregateInputType = {
    id?: true
    pottingDate?: true
    speciesId?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlantMaxAggregateInputType = {
    id?: true
    pottingDate?: true
    speciesId?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlantCountAggregateInputType = {
    id?: true
    pottingDate?: true
    speciesId?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plant to aggregate.
     */
    where?: PlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plants to fetch.
     */
    orderBy?: PlantOrderByWithRelationInput | PlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plants
    **/
    _count?: true | PlantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlantMaxAggregateInputType
  }

  export type GetPlantAggregateType<T extends PlantAggregateArgs> = {
        [P in keyof T & keyof AggregatePlant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlant[P]>
      : GetScalarType<T[P], AggregatePlant[P]>
  }




  export type PlantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantWhereInput
    orderBy?: PlantOrderByWithAggregationInput | PlantOrderByWithAggregationInput[]
    by: PlantScalarFieldEnum[] | PlantScalarFieldEnum
    having?: PlantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlantCountAggregateInputType | true
    _min?: PlantMinAggregateInputType
    _max?: PlantMaxAggregateInputType
  }

  export type PlantGroupByOutputType = {
    id: string
    pottingDate: Date | null
    speciesId: string
    locationId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PlantCountAggregateOutputType | null
    _min: PlantMinAggregateOutputType | null
    _max: PlantMaxAggregateOutputType | null
  }

  type GetPlantGroupByPayload<T extends PlantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlantGroupByOutputType[P]>
            : GetScalarType<T[P], PlantGroupByOutputType[P]>
        }
      >
    >


  export type PlantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pottingDate?: boolean
    speciesId?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    species?: boolean | SpeciesDefaultArgs<ExtArgs>
    location?: boolean | Plant$locationArgs<ExtArgs>
  }, ExtArgs["result"]["plant"]>

  export type PlantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pottingDate?: boolean
    speciesId?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    species?: boolean | SpeciesDefaultArgs<ExtArgs>
    location?: boolean | Plant$locationArgs<ExtArgs>
  }, ExtArgs["result"]["plant"]>

  export type PlantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pottingDate?: boolean
    speciesId?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    species?: boolean | SpeciesDefaultArgs<ExtArgs>
    location?: boolean | Plant$locationArgs<ExtArgs>
  }, ExtArgs["result"]["plant"]>

  export type PlantSelectScalar = {
    id?: boolean
    pottingDate?: boolean
    speciesId?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pottingDate" | "speciesId" | "locationId" | "createdAt" | "updatedAt", ExtArgs["result"]["plant"]>
  export type PlantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    species?: boolean | SpeciesDefaultArgs<ExtArgs>
    location?: boolean | Plant$locationArgs<ExtArgs>
  }
  export type PlantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    species?: boolean | SpeciesDefaultArgs<ExtArgs>
    location?: boolean | Plant$locationArgs<ExtArgs>
  }
  export type PlantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    species?: boolean | SpeciesDefaultArgs<ExtArgs>
    location?: boolean | Plant$locationArgs<ExtArgs>
  }

  export type $PlantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plant"
    objects: {
      species: Prisma.$SpeciesPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pottingDate: Date | null
      speciesId: string
      locationId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plant"]>
    composites: {}
  }

  type PlantGetPayload<S extends boolean | null | undefined | PlantDefaultArgs> = $Result.GetResult<Prisma.$PlantPayload, S>

  type PlantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlantCountAggregateInputType | true
    }

  export interface PlantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plant'], meta: { name: 'Plant' } }
    /**
     * Find zero or one Plant that matches the filter.
     * @param {PlantFindUniqueArgs} args - Arguments to find a Plant
     * @example
     * // Get one Plant
     * const plant = await prisma.plant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlantFindUniqueArgs>(args: SelectSubset<T, PlantFindUniqueArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlantFindUniqueOrThrowArgs} args - Arguments to find a Plant
     * @example
     * // Get one Plant
     * const plant = await prisma.plant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlantFindUniqueOrThrowArgs>(args: SelectSubset<T, PlantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantFindFirstArgs} args - Arguments to find a Plant
     * @example
     * // Get one Plant
     * const plant = await prisma.plant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlantFindFirstArgs>(args?: SelectSubset<T, PlantFindFirstArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantFindFirstOrThrowArgs} args - Arguments to find a Plant
     * @example
     * // Get one Plant
     * const plant = await prisma.plant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlantFindFirstOrThrowArgs>(args?: SelectSubset<T, PlantFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plants
     * const plants = await prisma.plant.findMany()
     * 
     * // Get first 10 Plants
     * const plants = await prisma.plant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plantWithIdOnly = await prisma.plant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlantFindManyArgs>(args?: SelectSubset<T, PlantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plant.
     * @param {PlantCreateArgs} args - Arguments to create a Plant.
     * @example
     * // Create one Plant
     * const Plant = await prisma.plant.create({
     *   data: {
     *     // ... data to create a Plant
     *   }
     * })
     * 
     */
    create<T extends PlantCreateArgs>(args: SelectSubset<T, PlantCreateArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plants.
     * @param {PlantCreateManyArgs} args - Arguments to create many Plants.
     * @example
     * // Create many Plants
     * const plant = await prisma.plant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlantCreateManyArgs>(args?: SelectSubset<T, PlantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plants and returns the data saved in the database.
     * @param {PlantCreateManyAndReturnArgs} args - Arguments to create many Plants.
     * @example
     * // Create many Plants
     * const plant = await prisma.plant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plants and only return the `id`
     * const plantWithIdOnly = await prisma.plant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlantCreateManyAndReturnArgs>(args?: SelectSubset<T, PlantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plant.
     * @param {PlantDeleteArgs} args - Arguments to delete one Plant.
     * @example
     * // Delete one Plant
     * const Plant = await prisma.plant.delete({
     *   where: {
     *     // ... filter to delete one Plant
     *   }
     * })
     * 
     */
    delete<T extends PlantDeleteArgs>(args: SelectSubset<T, PlantDeleteArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plant.
     * @param {PlantUpdateArgs} args - Arguments to update one Plant.
     * @example
     * // Update one Plant
     * const plant = await prisma.plant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlantUpdateArgs>(args: SelectSubset<T, PlantUpdateArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plants.
     * @param {PlantDeleteManyArgs} args - Arguments to filter Plants to delete.
     * @example
     * // Delete a few Plants
     * const { count } = await prisma.plant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlantDeleteManyArgs>(args?: SelectSubset<T, PlantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plants
     * const plant = await prisma.plant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlantUpdateManyArgs>(args: SelectSubset<T, PlantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plants and returns the data updated in the database.
     * @param {PlantUpdateManyAndReturnArgs} args - Arguments to update many Plants.
     * @example
     * // Update many Plants
     * const plant = await prisma.plant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plants and only return the `id`
     * const plantWithIdOnly = await prisma.plant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlantUpdateManyAndReturnArgs>(args: SelectSubset<T, PlantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plant.
     * @param {PlantUpsertArgs} args - Arguments to update or create a Plant.
     * @example
     * // Update or create a Plant
     * const plant = await prisma.plant.upsert({
     *   create: {
     *     // ... data to create a Plant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plant we want to update
     *   }
     * })
     */
    upsert<T extends PlantUpsertArgs>(args: SelectSubset<T, PlantUpsertArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCountArgs} args - Arguments to filter Plants to count.
     * @example
     * // Count the number of Plants
     * const count = await prisma.plant.count({
     *   where: {
     *     // ... the filter for the Plants we want to count
     *   }
     * })
    **/
    count<T extends PlantCountArgs>(
      args?: Subset<T, PlantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlantAggregateArgs>(args: Subset<T, PlantAggregateArgs>): Prisma.PrismaPromise<GetPlantAggregateType<T>>

    /**
     * Group by Plant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlantGroupByArgs['orderBy'] }
        : { orderBy?: PlantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plant model
   */
  readonly fields: PlantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    species<T extends SpeciesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpeciesDefaultArgs<ExtArgs>>): Prisma__SpeciesClient<$Result.GetResult<Prisma.$SpeciesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends Plant$locationArgs<ExtArgs> = {}>(args?: Subset<T, Plant$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plant model
   */
  interface PlantFieldRefs {
    readonly id: FieldRef<"Plant", 'String'>
    readonly pottingDate: FieldRef<"Plant", 'DateTime'>
    readonly speciesId: FieldRef<"Plant", 'String'>
    readonly locationId: FieldRef<"Plant", 'String'>
    readonly createdAt: FieldRef<"Plant", 'DateTime'>
    readonly updatedAt: FieldRef<"Plant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plant findUnique
   */
  export type PlantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter, which Plant to fetch.
     */
    where: PlantWhereUniqueInput
  }

  /**
   * Plant findUniqueOrThrow
   */
  export type PlantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter, which Plant to fetch.
     */
    where: PlantWhereUniqueInput
  }

  /**
   * Plant findFirst
   */
  export type PlantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter, which Plant to fetch.
     */
    where?: PlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plants to fetch.
     */
    orderBy?: PlantOrderByWithRelationInput | PlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plants.
     */
    cursor?: PlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plants.
     */
    distinct?: PlantScalarFieldEnum | PlantScalarFieldEnum[]
  }

  /**
   * Plant findFirstOrThrow
   */
  export type PlantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter, which Plant to fetch.
     */
    where?: PlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plants to fetch.
     */
    orderBy?: PlantOrderByWithRelationInput | PlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plants.
     */
    cursor?: PlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plants.
     */
    distinct?: PlantScalarFieldEnum | PlantScalarFieldEnum[]
  }

  /**
   * Plant findMany
   */
  export type PlantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter, which Plants to fetch.
     */
    where?: PlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plants to fetch.
     */
    orderBy?: PlantOrderByWithRelationInput | PlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plants.
     */
    cursor?: PlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plants.
     */
    skip?: number
    distinct?: PlantScalarFieldEnum | PlantScalarFieldEnum[]
  }

  /**
   * Plant create
   */
  export type PlantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * The data needed to create a Plant.
     */
    data: XOR<PlantCreateInput, PlantUncheckedCreateInput>
  }

  /**
   * Plant createMany
   */
  export type PlantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plants.
     */
    data: PlantCreateManyInput | PlantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plant createManyAndReturn
   */
  export type PlantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * The data used to create many Plants.
     */
    data: PlantCreateManyInput | PlantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Plant update
   */
  export type PlantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * The data needed to update a Plant.
     */
    data: XOR<PlantUpdateInput, PlantUncheckedUpdateInput>
    /**
     * Choose, which Plant to update.
     */
    where: PlantWhereUniqueInput
  }

  /**
   * Plant updateMany
   */
  export type PlantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plants.
     */
    data: XOR<PlantUpdateManyMutationInput, PlantUncheckedUpdateManyInput>
    /**
     * Filter which Plants to update
     */
    where?: PlantWhereInput
    /**
     * Limit how many Plants to update.
     */
    limit?: number
  }

  /**
   * Plant updateManyAndReturn
   */
  export type PlantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * The data used to update Plants.
     */
    data: XOR<PlantUpdateManyMutationInput, PlantUncheckedUpdateManyInput>
    /**
     * Filter which Plants to update
     */
    where?: PlantWhereInput
    /**
     * Limit how many Plants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Plant upsert
   */
  export type PlantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * The filter to search for the Plant to update in case it exists.
     */
    where: PlantWhereUniqueInput
    /**
     * In case the Plant found by the `where` argument doesn't exist, create a new Plant with this data.
     */
    create: XOR<PlantCreateInput, PlantUncheckedCreateInput>
    /**
     * In case the Plant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlantUpdateInput, PlantUncheckedUpdateInput>
  }

  /**
   * Plant delete
   */
  export type PlantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter which Plant to delete.
     */
    where: PlantWhereUniqueInput
  }

  /**
   * Plant deleteMany
   */
  export type PlantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plants to delete
     */
    where?: PlantWhereInput
    /**
     * Limit how many Plants to delete.
     */
    limit?: number
  }

  /**
   * Plant.location
   */
  export type Plant$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Plant without action
   */
  export type PlantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plant
     */
    omit?: PlantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
  }


  /**
   * Model Agrochemical
   */

  export type AggregateAgrochemical = {
    _count: AgrochemicalCountAggregateOutputType | null
    _min: AgrochemicalMinAggregateOutputType | null
    _max: AgrochemicalMaxAggregateOutputType | null
  }

  export type AgrochemicalMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.AgrochemicalType | null
    porpose: $Enums.AgrochemicalPorpose | null
    preparation: string | null
  }

  export type AgrochemicalMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.AgrochemicalType | null
    porpose: $Enums.AgrochemicalPorpose | null
    preparation: string | null
  }

  export type AgrochemicalCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    porpose: number
    preparation: number
    _all: number
  }


  export type AgrochemicalMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    porpose?: true
    preparation?: true
  }

  export type AgrochemicalMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    porpose?: true
    preparation?: true
  }

  export type AgrochemicalCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    porpose?: true
    preparation?: true
    _all?: true
  }

  export type AgrochemicalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agrochemical to aggregate.
     */
    where?: AgrochemicalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agrochemicals to fetch.
     */
    orderBy?: AgrochemicalOrderByWithRelationInput | AgrochemicalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgrochemicalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agrochemicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agrochemicals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agrochemicals
    **/
    _count?: true | AgrochemicalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgrochemicalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgrochemicalMaxAggregateInputType
  }

  export type GetAgrochemicalAggregateType<T extends AgrochemicalAggregateArgs> = {
        [P in keyof T & keyof AggregateAgrochemical]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgrochemical[P]>
      : GetScalarType<T[P], AggregateAgrochemical[P]>
  }




  export type AgrochemicalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgrochemicalWhereInput
    orderBy?: AgrochemicalOrderByWithAggregationInput | AgrochemicalOrderByWithAggregationInput[]
    by: AgrochemicalScalarFieldEnum[] | AgrochemicalScalarFieldEnum
    having?: AgrochemicalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgrochemicalCountAggregateInputType | true
    _min?: AgrochemicalMinAggregateInputType
    _max?: AgrochemicalMaxAggregateInputType
  }

  export type AgrochemicalGroupByOutputType = {
    id: string
    name: string
    description: string
    type: $Enums.AgrochemicalType
    porpose: $Enums.AgrochemicalPorpose
    preparation: string
    _count: AgrochemicalCountAggregateOutputType | null
    _min: AgrochemicalMinAggregateOutputType | null
    _max: AgrochemicalMaxAggregateOutputType | null
  }

  type GetAgrochemicalGroupByPayload<T extends AgrochemicalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgrochemicalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgrochemicalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgrochemicalGroupByOutputType[P]>
            : GetScalarType<T[P], AgrochemicalGroupByOutputType[P]>
        }
      >
    >


  export type AgrochemicalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    porpose?: boolean
    preparation?: boolean
    fertilizationCycles?: boolean | Agrochemical$fertilizationCyclesArgs<ExtArgs>
    fertilizationTasks?: boolean | Agrochemical$fertilizationTasksArgs<ExtArgs>
    phytosanitaryCycles?: boolean | Agrochemical$phytosanitaryCyclesArgs<ExtArgs>
    phytosanitaryTasks?: boolean | Agrochemical$phytosanitaryTasksArgs<ExtArgs>
    _count?: boolean | AgrochemicalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agrochemical"]>

  export type AgrochemicalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    porpose?: boolean
    preparation?: boolean
  }, ExtArgs["result"]["agrochemical"]>

  export type AgrochemicalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    porpose?: boolean
    preparation?: boolean
  }, ExtArgs["result"]["agrochemical"]>

  export type AgrochemicalSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    porpose?: boolean
    preparation?: boolean
  }

  export type AgrochemicalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "porpose" | "preparation", ExtArgs["result"]["agrochemical"]>
  export type AgrochemicalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fertilizationCycles?: boolean | Agrochemical$fertilizationCyclesArgs<ExtArgs>
    fertilizationTasks?: boolean | Agrochemical$fertilizationTasksArgs<ExtArgs>
    phytosanitaryCycles?: boolean | Agrochemical$phytosanitaryCyclesArgs<ExtArgs>
    phytosanitaryTasks?: boolean | Agrochemical$phytosanitaryTasksArgs<ExtArgs>
    _count?: boolean | AgrochemicalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgrochemicalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AgrochemicalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AgrochemicalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agrochemical"
    objects: {
      fertilizationCycles: Prisma.$FertilizationCyclePayload<ExtArgs>[]
      fertilizationTasks: Prisma.$FertilizationTaskPayload<ExtArgs>[]
      phytosanitaryCycles: Prisma.$PhytosanitaryCyclePayload<ExtArgs>[]
      phytosanitaryTasks: Prisma.$PhytosanitaryTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      type: $Enums.AgrochemicalType
      porpose: $Enums.AgrochemicalPorpose
      preparation: string
    }, ExtArgs["result"]["agrochemical"]>
    composites: {}
  }

  type AgrochemicalGetPayload<S extends boolean | null | undefined | AgrochemicalDefaultArgs> = $Result.GetResult<Prisma.$AgrochemicalPayload, S>

  type AgrochemicalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgrochemicalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgrochemicalCountAggregateInputType | true
    }

  export interface AgrochemicalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agrochemical'], meta: { name: 'Agrochemical' } }
    /**
     * Find zero or one Agrochemical that matches the filter.
     * @param {AgrochemicalFindUniqueArgs} args - Arguments to find a Agrochemical
     * @example
     * // Get one Agrochemical
     * const agrochemical = await prisma.agrochemical.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgrochemicalFindUniqueArgs>(args: SelectSubset<T, AgrochemicalFindUniqueArgs<ExtArgs>>): Prisma__AgrochemicalClient<$Result.GetResult<Prisma.$AgrochemicalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agrochemical that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgrochemicalFindUniqueOrThrowArgs} args - Arguments to find a Agrochemical
     * @example
     * // Get one Agrochemical
     * const agrochemical = await prisma.agrochemical.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgrochemicalFindUniqueOrThrowArgs>(args: SelectSubset<T, AgrochemicalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgrochemicalClient<$Result.GetResult<Prisma.$AgrochemicalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agrochemical that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgrochemicalFindFirstArgs} args - Arguments to find a Agrochemical
     * @example
     * // Get one Agrochemical
     * const agrochemical = await prisma.agrochemical.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgrochemicalFindFirstArgs>(args?: SelectSubset<T, AgrochemicalFindFirstArgs<ExtArgs>>): Prisma__AgrochemicalClient<$Result.GetResult<Prisma.$AgrochemicalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agrochemical that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgrochemicalFindFirstOrThrowArgs} args - Arguments to find a Agrochemical
     * @example
     * // Get one Agrochemical
     * const agrochemical = await prisma.agrochemical.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgrochemicalFindFirstOrThrowArgs>(args?: SelectSubset<T, AgrochemicalFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgrochemicalClient<$Result.GetResult<Prisma.$AgrochemicalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agrochemicals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgrochemicalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agrochemicals
     * const agrochemicals = await prisma.agrochemical.findMany()
     * 
     * // Get first 10 Agrochemicals
     * const agrochemicals = await prisma.agrochemical.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agrochemicalWithIdOnly = await prisma.agrochemical.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgrochemicalFindManyArgs>(args?: SelectSubset<T, AgrochemicalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgrochemicalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agrochemical.
     * @param {AgrochemicalCreateArgs} args - Arguments to create a Agrochemical.
     * @example
     * // Create one Agrochemical
     * const Agrochemical = await prisma.agrochemical.create({
     *   data: {
     *     // ... data to create a Agrochemical
     *   }
     * })
     * 
     */
    create<T extends AgrochemicalCreateArgs>(args: SelectSubset<T, AgrochemicalCreateArgs<ExtArgs>>): Prisma__AgrochemicalClient<$Result.GetResult<Prisma.$AgrochemicalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agrochemicals.
     * @param {AgrochemicalCreateManyArgs} args - Arguments to create many Agrochemicals.
     * @example
     * // Create many Agrochemicals
     * const agrochemical = await prisma.agrochemical.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgrochemicalCreateManyArgs>(args?: SelectSubset<T, AgrochemicalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agrochemicals and returns the data saved in the database.
     * @param {AgrochemicalCreateManyAndReturnArgs} args - Arguments to create many Agrochemicals.
     * @example
     * // Create many Agrochemicals
     * const agrochemical = await prisma.agrochemical.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agrochemicals and only return the `id`
     * const agrochemicalWithIdOnly = await prisma.agrochemical.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgrochemicalCreateManyAndReturnArgs>(args?: SelectSubset<T, AgrochemicalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgrochemicalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agrochemical.
     * @param {AgrochemicalDeleteArgs} args - Arguments to delete one Agrochemical.
     * @example
     * // Delete one Agrochemical
     * const Agrochemical = await prisma.agrochemical.delete({
     *   where: {
     *     // ... filter to delete one Agrochemical
     *   }
     * })
     * 
     */
    delete<T extends AgrochemicalDeleteArgs>(args: SelectSubset<T, AgrochemicalDeleteArgs<ExtArgs>>): Prisma__AgrochemicalClient<$Result.GetResult<Prisma.$AgrochemicalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agrochemical.
     * @param {AgrochemicalUpdateArgs} args - Arguments to update one Agrochemical.
     * @example
     * // Update one Agrochemical
     * const agrochemical = await prisma.agrochemical.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgrochemicalUpdateArgs>(args: SelectSubset<T, AgrochemicalUpdateArgs<ExtArgs>>): Prisma__AgrochemicalClient<$Result.GetResult<Prisma.$AgrochemicalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agrochemicals.
     * @param {AgrochemicalDeleteManyArgs} args - Arguments to filter Agrochemicals to delete.
     * @example
     * // Delete a few Agrochemicals
     * const { count } = await prisma.agrochemical.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgrochemicalDeleteManyArgs>(args?: SelectSubset<T, AgrochemicalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agrochemicals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgrochemicalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agrochemicals
     * const agrochemical = await prisma.agrochemical.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgrochemicalUpdateManyArgs>(args: SelectSubset<T, AgrochemicalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agrochemicals and returns the data updated in the database.
     * @param {AgrochemicalUpdateManyAndReturnArgs} args - Arguments to update many Agrochemicals.
     * @example
     * // Update many Agrochemicals
     * const agrochemical = await prisma.agrochemical.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agrochemicals and only return the `id`
     * const agrochemicalWithIdOnly = await prisma.agrochemical.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgrochemicalUpdateManyAndReturnArgs>(args: SelectSubset<T, AgrochemicalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgrochemicalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agrochemical.
     * @param {AgrochemicalUpsertArgs} args - Arguments to update or create a Agrochemical.
     * @example
     * // Update or create a Agrochemical
     * const agrochemical = await prisma.agrochemical.upsert({
     *   create: {
     *     // ... data to create a Agrochemical
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agrochemical we want to update
     *   }
     * })
     */
    upsert<T extends AgrochemicalUpsertArgs>(args: SelectSubset<T, AgrochemicalUpsertArgs<ExtArgs>>): Prisma__AgrochemicalClient<$Result.GetResult<Prisma.$AgrochemicalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agrochemicals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgrochemicalCountArgs} args - Arguments to filter Agrochemicals to count.
     * @example
     * // Count the number of Agrochemicals
     * const count = await prisma.agrochemical.count({
     *   where: {
     *     // ... the filter for the Agrochemicals we want to count
     *   }
     * })
    **/
    count<T extends AgrochemicalCountArgs>(
      args?: Subset<T, AgrochemicalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgrochemicalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agrochemical.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgrochemicalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgrochemicalAggregateArgs>(args: Subset<T, AgrochemicalAggregateArgs>): Prisma.PrismaPromise<GetAgrochemicalAggregateType<T>>

    /**
     * Group by Agrochemical.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgrochemicalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgrochemicalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgrochemicalGroupByArgs['orderBy'] }
        : { orderBy?: AgrochemicalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgrochemicalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgrochemicalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agrochemical model
   */
  readonly fields: AgrochemicalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agrochemical.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgrochemicalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fertilizationCycles<T extends Agrochemical$fertilizationCyclesArgs<ExtArgs> = {}>(args?: Subset<T, Agrochemical$fertilizationCyclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FertilizationCyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fertilizationTasks<T extends Agrochemical$fertilizationTasksArgs<ExtArgs> = {}>(args?: Subset<T, Agrochemical$fertilizationTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FertilizationTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    phytosanitaryCycles<T extends Agrochemical$phytosanitaryCyclesArgs<ExtArgs> = {}>(args?: Subset<T, Agrochemical$phytosanitaryCyclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhytosanitaryCyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    phytosanitaryTasks<T extends Agrochemical$phytosanitaryTasksArgs<ExtArgs> = {}>(args?: Subset<T, Agrochemical$phytosanitaryTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhytosanitaryTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agrochemical model
   */
  interface AgrochemicalFieldRefs {
    readonly id: FieldRef<"Agrochemical", 'String'>
    readonly name: FieldRef<"Agrochemical", 'String'>
    readonly description: FieldRef<"Agrochemical", 'String'>
    readonly type: FieldRef<"Agrochemical", 'AgrochemicalType'>
    readonly porpose: FieldRef<"Agrochemical", 'AgrochemicalPorpose'>
    readonly preparation: FieldRef<"Agrochemical", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Agrochemical findUnique
   */
  export type AgrochemicalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrochemical
     */
    select?: AgrochemicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrochemical
     */
    omit?: AgrochemicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrochemicalInclude<ExtArgs> | null
    /**
     * Filter, which Agrochemical to fetch.
     */
    where: AgrochemicalWhereUniqueInput
  }

  /**
   * Agrochemical findUniqueOrThrow
   */
  export type AgrochemicalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrochemical
     */
    select?: AgrochemicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrochemical
     */
    omit?: AgrochemicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrochemicalInclude<ExtArgs> | null
    /**
     * Filter, which Agrochemical to fetch.
     */
    where: AgrochemicalWhereUniqueInput
  }

  /**
   * Agrochemical findFirst
   */
  export type AgrochemicalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrochemical
     */
    select?: AgrochemicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrochemical
     */
    omit?: AgrochemicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrochemicalInclude<ExtArgs> | null
    /**
     * Filter, which Agrochemical to fetch.
     */
    where?: AgrochemicalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agrochemicals to fetch.
     */
    orderBy?: AgrochemicalOrderByWithRelationInput | AgrochemicalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agrochemicals.
     */
    cursor?: AgrochemicalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agrochemicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agrochemicals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agrochemicals.
     */
    distinct?: AgrochemicalScalarFieldEnum | AgrochemicalScalarFieldEnum[]
  }

  /**
   * Agrochemical findFirstOrThrow
   */
  export type AgrochemicalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrochemical
     */
    select?: AgrochemicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrochemical
     */
    omit?: AgrochemicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrochemicalInclude<ExtArgs> | null
    /**
     * Filter, which Agrochemical to fetch.
     */
    where?: AgrochemicalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agrochemicals to fetch.
     */
    orderBy?: AgrochemicalOrderByWithRelationInput | AgrochemicalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agrochemicals.
     */
    cursor?: AgrochemicalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agrochemicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agrochemicals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agrochemicals.
     */
    distinct?: AgrochemicalScalarFieldEnum | AgrochemicalScalarFieldEnum[]
  }

  /**
   * Agrochemical findMany
   */
  export type AgrochemicalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrochemical
     */
    select?: AgrochemicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrochemical
     */
    omit?: AgrochemicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrochemicalInclude<ExtArgs> | null
    /**
     * Filter, which Agrochemicals to fetch.
     */
    where?: AgrochemicalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agrochemicals to fetch.
     */
    orderBy?: AgrochemicalOrderByWithRelationInput | AgrochemicalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agrochemicals.
     */
    cursor?: AgrochemicalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agrochemicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agrochemicals.
     */
    skip?: number
    distinct?: AgrochemicalScalarFieldEnum | AgrochemicalScalarFieldEnum[]
  }

  /**
   * Agrochemical create
   */
  export type AgrochemicalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrochemical
     */
    select?: AgrochemicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrochemical
     */
    omit?: AgrochemicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrochemicalInclude<ExtArgs> | null
    /**
     * The data needed to create a Agrochemical.
     */
    data: XOR<AgrochemicalCreateInput, AgrochemicalUncheckedCreateInput>
  }

  /**
   * Agrochemical createMany
   */
  export type AgrochemicalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agrochemicals.
     */
    data: AgrochemicalCreateManyInput | AgrochemicalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agrochemical createManyAndReturn
   */
  export type AgrochemicalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrochemical
     */
    select?: AgrochemicalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agrochemical
     */
    omit?: AgrochemicalOmit<ExtArgs> | null
    /**
     * The data used to create many Agrochemicals.
     */
    data: AgrochemicalCreateManyInput | AgrochemicalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agrochemical update
   */
  export type AgrochemicalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrochemical
     */
    select?: AgrochemicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrochemical
     */
    omit?: AgrochemicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrochemicalInclude<ExtArgs> | null
    /**
     * The data needed to update a Agrochemical.
     */
    data: XOR<AgrochemicalUpdateInput, AgrochemicalUncheckedUpdateInput>
    /**
     * Choose, which Agrochemical to update.
     */
    where: AgrochemicalWhereUniqueInput
  }

  /**
   * Agrochemical updateMany
   */
  export type AgrochemicalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agrochemicals.
     */
    data: XOR<AgrochemicalUpdateManyMutationInput, AgrochemicalUncheckedUpdateManyInput>
    /**
     * Filter which Agrochemicals to update
     */
    where?: AgrochemicalWhereInput
    /**
     * Limit how many Agrochemicals to update.
     */
    limit?: number
  }

  /**
   * Agrochemical updateManyAndReturn
   */
  export type AgrochemicalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrochemical
     */
    select?: AgrochemicalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agrochemical
     */
    omit?: AgrochemicalOmit<ExtArgs> | null
    /**
     * The data used to update Agrochemicals.
     */
    data: XOR<AgrochemicalUpdateManyMutationInput, AgrochemicalUncheckedUpdateManyInput>
    /**
     * Filter which Agrochemicals to update
     */
    where?: AgrochemicalWhereInput
    /**
     * Limit how many Agrochemicals to update.
     */
    limit?: number
  }

  /**
   * Agrochemical upsert
   */
  export type AgrochemicalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrochemical
     */
    select?: AgrochemicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrochemical
     */
    omit?: AgrochemicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrochemicalInclude<ExtArgs> | null
    /**
     * The filter to search for the Agrochemical to update in case it exists.
     */
    where: AgrochemicalWhereUniqueInput
    /**
     * In case the Agrochemical found by the `where` argument doesn't exist, create a new Agrochemical with this data.
     */
    create: XOR<AgrochemicalCreateInput, AgrochemicalUncheckedCreateInput>
    /**
     * In case the Agrochemical was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgrochemicalUpdateInput, AgrochemicalUncheckedUpdateInput>
  }

  /**
   * Agrochemical delete
   */
  export type AgrochemicalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrochemical
     */
    select?: AgrochemicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrochemical
     */
    omit?: AgrochemicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrochemicalInclude<ExtArgs> | null
    /**
     * Filter which Agrochemical to delete.
     */
    where: AgrochemicalWhereUniqueInput
  }

  /**
   * Agrochemical deleteMany
   */
  export type AgrochemicalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agrochemicals to delete
     */
    where?: AgrochemicalWhereInput
    /**
     * Limit how many Agrochemicals to delete.
     */
    limit?: number
  }

  /**
   * Agrochemical.fertilizationCycles
   */
  export type Agrochemical$fertilizationCyclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycle
     */
    select?: FertilizationCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationCycle
     */
    omit?: FertilizationCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationCycleInclude<ExtArgs> | null
    where?: FertilizationCycleWhereInput
    orderBy?: FertilizationCycleOrderByWithRelationInput | FertilizationCycleOrderByWithRelationInput[]
    cursor?: FertilizationCycleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FertilizationCycleScalarFieldEnum | FertilizationCycleScalarFieldEnum[]
  }

  /**
   * Agrochemical.fertilizationTasks
   */
  export type Agrochemical$fertilizationTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationTask
     */
    select?: FertilizationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationTask
     */
    omit?: FertilizationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationTaskInclude<ExtArgs> | null
    where?: FertilizationTaskWhereInput
    orderBy?: FertilizationTaskOrderByWithRelationInput | FertilizationTaskOrderByWithRelationInput[]
    cursor?: FertilizationTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FertilizationTaskScalarFieldEnum | FertilizationTaskScalarFieldEnum[]
  }

  /**
   * Agrochemical.phytosanitaryCycles
   */
  export type Agrochemical$phytosanitaryCyclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycle
     */
    select?: PhytosanitaryCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryCycle
     */
    omit?: PhytosanitaryCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryCycleInclude<ExtArgs> | null
    where?: PhytosanitaryCycleWhereInput
    orderBy?: PhytosanitaryCycleOrderByWithRelationInput | PhytosanitaryCycleOrderByWithRelationInput[]
    cursor?: PhytosanitaryCycleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhytosanitaryCycleScalarFieldEnum | PhytosanitaryCycleScalarFieldEnum[]
  }

  /**
   * Agrochemical.phytosanitaryTasks
   */
  export type Agrochemical$phytosanitaryTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryTask
     */
    select?: PhytosanitaryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryTask
     */
    omit?: PhytosanitaryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryTaskInclude<ExtArgs> | null
    where?: PhytosanitaryTaskWhereInput
    orderBy?: PhytosanitaryTaskOrderByWithRelationInput | PhytosanitaryTaskOrderByWithRelationInput[]
    cursor?: PhytosanitaryTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhytosanitaryTaskScalarFieldEnum | PhytosanitaryTaskScalarFieldEnum[]
  }

  /**
   * Agrochemical without action
   */
  export type AgrochemicalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrochemical
     */
    select?: AgrochemicalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrochemical
     */
    omit?: AgrochemicalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrochemicalInclude<ExtArgs> | null
  }


  /**
   * Model FertilizationProgram
   */

  export type AggregateFertilizationProgram = {
    _count: FertilizationProgramCountAggregateOutputType | null
    _avg: FertilizationProgramAvgAggregateOutputType | null
    _sum: FertilizationProgramSumAggregateOutputType | null
    _min: FertilizationProgramMinAggregateOutputType | null
    _max: FertilizationProgramMaxAggregateOutputType | null
  }

  export type FertilizationProgramAvgAggregateOutputType = {
    weeklyFrequency: number | null
  }

  export type FertilizationProgramSumAggregateOutputType = {
    weeklyFrequency: number | null
  }

  export type FertilizationProgramMinAggregateOutputType = {
    id: string | null
    name: string | null
    weeklyFrequency: number | null
  }

  export type FertilizationProgramMaxAggregateOutputType = {
    id: string | null
    name: string | null
    weeklyFrequency: number | null
  }

  export type FertilizationProgramCountAggregateOutputType = {
    id: number
    name: number
    weeklyFrequency: number
    _all: number
  }


  export type FertilizationProgramAvgAggregateInputType = {
    weeklyFrequency?: true
  }

  export type FertilizationProgramSumAggregateInputType = {
    weeklyFrequency?: true
  }

  export type FertilizationProgramMinAggregateInputType = {
    id?: true
    name?: true
    weeklyFrequency?: true
  }

  export type FertilizationProgramMaxAggregateInputType = {
    id?: true
    name?: true
    weeklyFrequency?: true
  }

  export type FertilizationProgramCountAggregateInputType = {
    id?: true
    name?: true
    weeklyFrequency?: true
    _all?: true
  }

  export type FertilizationProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FertilizationProgram to aggregate.
     */
    where?: FertilizationProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FertilizationPrograms to fetch.
     */
    orderBy?: FertilizationProgramOrderByWithRelationInput | FertilizationProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FertilizationProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FertilizationPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FertilizationPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FertilizationPrograms
    **/
    _count?: true | FertilizationProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FertilizationProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FertilizationProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FertilizationProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FertilizationProgramMaxAggregateInputType
  }

  export type GetFertilizationProgramAggregateType<T extends FertilizationProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateFertilizationProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFertilizationProgram[P]>
      : GetScalarType<T[P], AggregateFertilizationProgram[P]>
  }




  export type FertilizationProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FertilizationProgramWhereInput
    orderBy?: FertilizationProgramOrderByWithAggregationInput | FertilizationProgramOrderByWithAggregationInput[]
    by: FertilizationProgramScalarFieldEnum[] | FertilizationProgramScalarFieldEnum
    having?: FertilizationProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FertilizationProgramCountAggregateInputType | true
    _avg?: FertilizationProgramAvgAggregateInputType
    _sum?: FertilizationProgramSumAggregateInputType
    _min?: FertilizationProgramMinAggregateInputType
    _max?: FertilizationProgramMaxAggregateInputType
  }

  export type FertilizationProgramGroupByOutputType = {
    id: string
    name: string
    weeklyFrequency: number
    _count: FertilizationProgramCountAggregateOutputType | null
    _avg: FertilizationProgramAvgAggregateOutputType | null
    _sum: FertilizationProgramSumAggregateOutputType | null
    _min: FertilizationProgramMinAggregateOutputType | null
    _max: FertilizationProgramMaxAggregateOutputType | null
  }

  type GetFertilizationProgramGroupByPayload<T extends FertilizationProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FertilizationProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FertilizationProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FertilizationProgramGroupByOutputType[P]>
            : GetScalarType<T[P], FertilizationProgramGroupByOutputType[P]>
        }
      >
    >


  export type FertilizationProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weeklyFrequency?: boolean
    productsCycle?: boolean | FertilizationProgram$productsCycleArgs<ExtArgs>
    _count?: boolean | FertilizationProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fertilizationProgram"]>

  export type FertilizationProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weeklyFrequency?: boolean
  }, ExtArgs["result"]["fertilizationProgram"]>

  export type FertilizationProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weeklyFrequency?: boolean
  }, ExtArgs["result"]["fertilizationProgram"]>

  export type FertilizationProgramSelectScalar = {
    id?: boolean
    name?: boolean
    weeklyFrequency?: boolean
  }

  export type FertilizationProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "weeklyFrequency", ExtArgs["result"]["fertilizationProgram"]>
  export type FertilizationProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productsCycle?: boolean | FertilizationProgram$productsCycleArgs<ExtArgs>
    _count?: boolean | FertilizationProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FertilizationProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FertilizationProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FertilizationProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FertilizationProgram"
    objects: {
      productsCycle: Prisma.$FertilizationCyclePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      weeklyFrequency: number
    }, ExtArgs["result"]["fertilizationProgram"]>
    composites: {}
  }

  type FertilizationProgramGetPayload<S extends boolean | null | undefined | FertilizationProgramDefaultArgs> = $Result.GetResult<Prisma.$FertilizationProgramPayload, S>

  type FertilizationProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FertilizationProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FertilizationProgramCountAggregateInputType | true
    }

  export interface FertilizationProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FertilizationProgram'], meta: { name: 'FertilizationProgram' } }
    /**
     * Find zero or one FertilizationProgram that matches the filter.
     * @param {FertilizationProgramFindUniqueArgs} args - Arguments to find a FertilizationProgram
     * @example
     * // Get one FertilizationProgram
     * const fertilizationProgram = await prisma.fertilizationProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FertilizationProgramFindUniqueArgs>(args: SelectSubset<T, FertilizationProgramFindUniqueArgs<ExtArgs>>): Prisma__FertilizationProgramClient<$Result.GetResult<Prisma.$FertilizationProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FertilizationProgram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FertilizationProgramFindUniqueOrThrowArgs} args - Arguments to find a FertilizationProgram
     * @example
     * // Get one FertilizationProgram
     * const fertilizationProgram = await prisma.fertilizationProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FertilizationProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, FertilizationProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FertilizationProgramClient<$Result.GetResult<Prisma.$FertilizationProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FertilizationProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationProgramFindFirstArgs} args - Arguments to find a FertilizationProgram
     * @example
     * // Get one FertilizationProgram
     * const fertilizationProgram = await prisma.fertilizationProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FertilizationProgramFindFirstArgs>(args?: SelectSubset<T, FertilizationProgramFindFirstArgs<ExtArgs>>): Prisma__FertilizationProgramClient<$Result.GetResult<Prisma.$FertilizationProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FertilizationProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationProgramFindFirstOrThrowArgs} args - Arguments to find a FertilizationProgram
     * @example
     * // Get one FertilizationProgram
     * const fertilizationProgram = await prisma.fertilizationProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FertilizationProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, FertilizationProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__FertilizationProgramClient<$Result.GetResult<Prisma.$FertilizationProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FertilizationPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FertilizationPrograms
     * const fertilizationPrograms = await prisma.fertilizationProgram.findMany()
     * 
     * // Get first 10 FertilizationPrograms
     * const fertilizationPrograms = await prisma.fertilizationProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fertilizationProgramWithIdOnly = await prisma.fertilizationProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FertilizationProgramFindManyArgs>(args?: SelectSubset<T, FertilizationProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FertilizationProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FertilizationProgram.
     * @param {FertilizationProgramCreateArgs} args - Arguments to create a FertilizationProgram.
     * @example
     * // Create one FertilizationProgram
     * const FertilizationProgram = await prisma.fertilizationProgram.create({
     *   data: {
     *     // ... data to create a FertilizationProgram
     *   }
     * })
     * 
     */
    create<T extends FertilizationProgramCreateArgs>(args: SelectSubset<T, FertilizationProgramCreateArgs<ExtArgs>>): Prisma__FertilizationProgramClient<$Result.GetResult<Prisma.$FertilizationProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FertilizationPrograms.
     * @param {FertilizationProgramCreateManyArgs} args - Arguments to create many FertilizationPrograms.
     * @example
     * // Create many FertilizationPrograms
     * const fertilizationProgram = await prisma.fertilizationProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FertilizationProgramCreateManyArgs>(args?: SelectSubset<T, FertilizationProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FertilizationPrograms and returns the data saved in the database.
     * @param {FertilizationProgramCreateManyAndReturnArgs} args - Arguments to create many FertilizationPrograms.
     * @example
     * // Create many FertilizationPrograms
     * const fertilizationProgram = await prisma.fertilizationProgram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FertilizationPrograms and only return the `id`
     * const fertilizationProgramWithIdOnly = await prisma.fertilizationProgram.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FertilizationProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, FertilizationProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FertilizationProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FertilizationProgram.
     * @param {FertilizationProgramDeleteArgs} args - Arguments to delete one FertilizationProgram.
     * @example
     * // Delete one FertilizationProgram
     * const FertilizationProgram = await prisma.fertilizationProgram.delete({
     *   where: {
     *     // ... filter to delete one FertilizationProgram
     *   }
     * })
     * 
     */
    delete<T extends FertilizationProgramDeleteArgs>(args: SelectSubset<T, FertilizationProgramDeleteArgs<ExtArgs>>): Prisma__FertilizationProgramClient<$Result.GetResult<Prisma.$FertilizationProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FertilizationProgram.
     * @param {FertilizationProgramUpdateArgs} args - Arguments to update one FertilizationProgram.
     * @example
     * // Update one FertilizationProgram
     * const fertilizationProgram = await prisma.fertilizationProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FertilizationProgramUpdateArgs>(args: SelectSubset<T, FertilizationProgramUpdateArgs<ExtArgs>>): Prisma__FertilizationProgramClient<$Result.GetResult<Prisma.$FertilizationProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FertilizationPrograms.
     * @param {FertilizationProgramDeleteManyArgs} args - Arguments to filter FertilizationPrograms to delete.
     * @example
     * // Delete a few FertilizationPrograms
     * const { count } = await prisma.fertilizationProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FertilizationProgramDeleteManyArgs>(args?: SelectSubset<T, FertilizationProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FertilizationPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FertilizationPrograms
     * const fertilizationProgram = await prisma.fertilizationProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FertilizationProgramUpdateManyArgs>(args: SelectSubset<T, FertilizationProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FertilizationPrograms and returns the data updated in the database.
     * @param {FertilizationProgramUpdateManyAndReturnArgs} args - Arguments to update many FertilizationPrograms.
     * @example
     * // Update many FertilizationPrograms
     * const fertilizationProgram = await prisma.fertilizationProgram.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FertilizationPrograms and only return the `id`
     * const fertilizationProgramWithIdOnly = await prisma.fertilizationProgram.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FertilizationProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, FertilizationProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FertilizationProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FertilizationProgram.
     * @param {FertilizationProgramUpsertArgs} args - Arguments to update or create a FertilizationProgram.
     * @example
     * // Update or create a FertilizationProgram
     * const fertilizationProgram = await prisma.fertilizationProgram.upsert({
     *   create: {
     *     // ... data to create a FertilizationProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FertilizationProgram we want to update
     *   }
     * })
     */
    upsert<T extends FertilizationProgramUpsertArgs>(args: SelectSubset<T, FertilizationProgramUpsertArgs<ExtArgs>>): Prisma__FertilizationProgramClient<$Result.GetResult<Prisma.$FertilizationProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FertilizationPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationProgramCountArgs} args - Arguments to filter FertilizationPrograms to count.
     * @example
     * // Count the number of FertilizationPrograms
     * const count = await prisma.fertilizationProgram.count({
     *   where: {
     *     // ... the filter for the FertilizationPrograms we want to count
     *   }
     * })
    **/
    count<T extends FertilizationProgramCountArgs>(
      args?: Subset<T, FertilizationProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FertilizationProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FertilizationProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FertilizationProgramAggregateArgs>(args: Subset<T, FertilizationProgramAggregateArgs>): Prisma.PrismaPromise<GetFertilizationProgramAggregateType<T>>

    /**
     * Group by FertilizationProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FertilizationProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FertilizationProgramGroupByArgs['orderBy'] }
        : { orderBy?: FertilizationProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FertilizationProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFertilizationProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FertilizationProgram model
   */
  readonly fields: FertilizationProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FertilizationProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FertilizationProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productsCycle<T extends FertilizationProgram$productsCycleArgs<ExtArgs> = {}>(args?: Subset<T, FertilizationProgram$productsCycleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FertilizationCyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FertilizationProgram model
   */
  interface FertilizationProgramFieldRefs {
    readonly id: FieldRef<"FertilizationProgram", 'String'>
    readonly name: FieldRef<"FertilizationProgram", 'String'>
    readonly weeklyFrequency: FieldRef<"FertilizationProgram", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FertilizationProgram findUnique
   */
  export type FertilizationProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationProgram
     */
    select?: FertilizationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationProgram
     */
    omit?: FertilizationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationProgramInclude<ExtArgs> | null
    /**
     * Filter, which FertilizationProgram to fetch.
     */
    where: FertilizationProgramWhereUniqueInput
  }

  /**
   * FertilizationProgram findUniqueOrThrow
   */
  export type FertilizationProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationProgram
     */
    select?: FertilizationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationProgram
     */
    omit?: FertilizationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationProgramInclude<ExtArgs> | null
    /**
     * Filter, which FertilizationProgram to fetch.
     */
    where: FertilizationProgramWhereUniqueInput
  }

  /**
   * FertilizationProgram findFirst
   */
  export type FertilizationProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationProgram
     */
    select?: FertilizationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationProgram
     */
    omit?: FertilizationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationProgramInclude<ExtArgs> | null
    /**
     * Filter, which FertilizationProgram to fetch.
     */
    where?: FertilizationProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FertilizationPrograms to fetch.
     */
    orderBy?: FertilizationProgramOrderByWithRelationInput | FertilizationProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FertilizationPrograms.
     */
    cursor?: FertilizationProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FertilizationPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FertilizationPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FertilizationPrograms.
     */
    distinct?: FertilizationProgramScalarFieldEnum | FertilizationProgramScalarFieldEnum[]
  }

  /**
   * FertilizationProgram findFirstOrThrow
   */
  export type FertilizationProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationProgram
     */
    select?: FertilizationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationProgram
     */
    omit?: FertilizationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationProgramInclude<ExtArgs> | null
    /**
     * Filter, which FertilizationProgram to fetch.
     */
    where?: FertilizationProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FertilizationPrograms to fetch.
     */
    orderBy?: FertilizationProgramOrderByWithRelationInput | FertilizationProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FertilizationPrograms.
     */
    cursor?: FertilizationProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FertilizationPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FertilizationPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FertilizationPrograms.
     */
    distinct?: FertilizationProgramScalarFieldEnum | FertilizationProgramScalarFieldEnum[]
  }

  /**
   * FertilizationProgram findMany
   */
  export type FertilizationProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationProgram
     */
    select?: FertilizationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationProgram
     */
    omit?: FertilizationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationProgramInclude<ExtArgs> | null
    /**
     * Filter, which FertilizationPrograms to fetch.
     */
    where?: FertilizationProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FertilizationPrograms to fetch.
     */
    orderBy?: FertilizationProgramOrderByWithRelationInput | FertilizationProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FertilizationPrograms.
     */
    cursor?: FertilizationProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FertilizationPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FertilizationPrograms.
     */
    skip?: number
    distinct?: FertilizationProgramScalarFieldEnum | FertilizationProgramScalarFieldEnum[]
  }

  /**
   * FertilizationProgram create
   */
  export type FertilizationProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationProgram
     */
    select?: FertilizationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationProgram
     */
    omit?: FertilizationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a FertilizationProgram.
     */
    data: XOR<FertilizationProgramCreateInput, FertilizationProgramUncheckedCreateInput>
  }

  /**
   * FertilizationProgram createMany
   */
  export type FertilizationProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FertilizationPrograms.
     */
    data: FertilizationProgramCreateManyInput | FertilizationProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FertilizationProgram createManyAndReturn
   */
  export type FertilizationProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationProgram
     */
    select?: FertilizationProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationProgram
     */
    omit?: FertilizationProgramOmit<ExtArgs> | null
    /**
     * The data used to create many FertilizationPrograms.
     */
    data: FertilizationProgramCreateManyInput | FertilizationProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FertilizationProgram update
   */
  export type FertilizationProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationProgram
     */
    select?: FertilizationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationProgram
     */
    omit?: FertilizationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a FertilizationProgram.
     */
    data: XOR<FertilizationProgramUpdateInput, FertilizationProgramUncheckedUpdateInput>
    /**
     * Choose, which FertilizationProgram to update.
     */
    where: FertilizationProgramWhereUniqueInput
  }

  /**
   * FertilizationProgram updateMany
   */
  export type FertilizationProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FertilizationPrograms.
     */
    data: XOR<FertilizationProgramUpdateManyMutationInput, FertilizationProgramUncheckedUpdateManyInput>
    /**
     * Filter which FertilizationPrograms to update
     */
    where?: FertilizationProgramWhereInput
    /**
     * Limit how many FertilizationPrograms to update.
     */
    limit?: number
  }

  /**
   * FertilizationProgram updateManyAndReturn
   */
  export type FertilizationProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationProgram
     */
    select?: FertilizationProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationProgram
     */
    omit?: FertilizationProgramOmit<ExtArgs> | null
    /**
     * The data used to update FertilizationPrograms.
     */
    data: XOR<FertilizationProgramUpdateManyMutationInput, FertilizationProgramUncheckedUpdateManyInput>
    /**
     * Filter which FertilizationPrograms to update
     */
    where?: FertilizationProgramWhereInput
    /**
     * Limit how many FertilizationPrograms to update.
     */
    limit?: number
  }

  /**
   * FertilizationProgram upsert
   */
  export type FertilizationProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationProgram
     */
    select?: FertilizationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationProgram
     */
    omit?: FertilizationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the FertilizationProgram to update in case it exists.
     */
    where: FertilizationProgramWhereUniqueInput
    /**
     * In case the FertilizationProgram found by the `where` argument doesn't exist, create a new FertilizationProgram with this data.
     */
    create: XOR<FertilizationProgramCreateInput, FertilizationProgramUncheckedCreateInput>
    /**
     * In case the FertilizationProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FertilizationProgramUpdateInput, FertilizationProgramUncheckedUpdateInput>
  }

  /**
   * FertilizationProgram delete
   */
  export type FertilizationProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationProgram
     */
    select?: FertilizationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationProgram
     */
    omit?: FertilizationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationProgramInclude<ExtArgs> | null
    /**
     * Filter which FertilizationProgram to delete.
     */
    where: FertilizationProgramWhereUniqueInput
  }

  /**
   * FertilizationProgram deleteMany
   */
  export type FertilizationProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FertilizationPrograms to delete
     */
    where?: FertilizationProgramWhereInput
    /**
     * Limit how many FertilizationPrograms to delete.
     */
    limit?: number
  }

  /**
   * FertilizationProgram.productsCycle
   */
  export type FertilizationProgram$productsCycleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycle
     */
    select?: FertilizationCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationCycle
     */
    omit?: FertilizationCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationCycleInclude<ExtArgs> | null
    where?: FertilizationCycleWhereInput
    orderBy?: FertilizationCycleOrderByWithRelationInput | FertilizationCycleOrderByWithRelationInput[]
    cursor?: FertilizationCycleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FertilizationCycleScalarFieldEnum | FertilizationCycleScalarFieldEnum[]
  }

  /**
   * FertilizationProgram without action
   */
  export type FertilizationProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationProgram
     */
    select?: FertilizationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationProgram
     */
    omit?: FertilizationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationProgramInclude<ExtArgs> | null
  }


  /**
   * Model FertilizationCycle
   */

  export type AggregateFertilizationCycle = {
    _count: FertilizationCycleCountAggregateOutputType | null
    _avg: FertilizationCycleAvgAggregateOutputType | null
    _sum: FertilizationCycleSumAggregateOutputType | null
    _min: FertilizationCycleMinAggregateOutputType | null
    _max: FertilizationCycleMaxAggregateOutputType | null
  }

  export type FertilizationCycleAvgAggregateOutputType = {
    sequence: number | null
  }

  export type FertilizationCycleSumAggregateOutputType = {
    sequence: number | null
  }

  export type FertilizationCycleMinAggregateOutputType = {
    id: string | null
    sequence: number | null
    agrochemicalId: string | null
    programId: string | null
  }

  export type FertilizationCycleMaxAggregateOutputType = {
    id: string | null
    sequence: number | null
    agrochemicalId: string | null
    programId: string | null
  }

  export type FertilizationCycleCountAggregateOutputType = {
    id: number
    sequence: number
    agrochemicalId: number
    programId: number
    _all: number
  }


  export type FertilizationCycleAvgAggregateInputType = {
    sequence?: true
  }

  export type FertilizationCycleSumAggregateInputType = {
    sequence?: true
  }

  export type FertilizationCycleMinAggregateInputType = {
    id?: true
    sequence?: true
    agrochemicalId?: true
    programId?: true
  }

  export type FertilizationCycleMaxAggregateInputType = {
    id?: true
    sequence?: true
    agrochemicalId?: true
    programId?: true
  }

  export type FertilizationCycleCountAggregateInputType = {
    id?: true
    sequence?: true
    agrochemicalId?: true
    programId?: true
    _all?: true
  }

  export type FertilizationCycleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FertilizationCycle to aggregate.
     */
    where?: FertilizationCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FertilizationCycles to fetch.
     */
    orderBy?: FertilizationCycleOrderByWithRelationInput | FertilizationCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FertilizationCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FertilizationCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FertilizationCycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FertilizationCycles
    **/
    _count?: true | FertilizationCycleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FertilizationCycleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FertilizationCycleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FertilizationCycleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FertilizationCycleMaxAggregateInputType
  }

  export type GetFertilizationCycleAggregateType<T extends FertilizationCycleAggregateArgs> = {
        [P in keyof T & keyof AggregateFertilizationCycle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFertilizationCycle[P]>
      : GetScalarType<T[P], AggregateFertilizationCycle[P]>
  }




  export type FertilizationCycleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FertilizationCycleWhereInput
    orderBy?: FertilizationCycleOrderByWithAggregationInput | FertilizationCycleOrderByWithAggregationInput[]
    by: FertilizationCycleScalarFieldEnum[] | FertilizationCycleScalarFieldEnum
    having?: FertilizationCycleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FertilizationCycleCountAggregateInputType | true
    _avg?: FertilizationCycleAvgAggregateInputType
    _sum?: FertilizationCycleSumAggregateInputType
    _min?: FertilizationCycleMinAggregateInputType
    _max?: FertilizationCycleMaxAggregateInputType
  }

  export type FertilizationCycleGroupByOutputType = {
    id: string
    sequence: number
    agrochemicalId: string
    programId: string
    _count: FertilizationCycleCountAggregateOutputType | null
    _avg: FertilizationCycleAvgAggregateOutputType | null
    _sum: FertilizationCycleSumAggregateOutputType | null
    _min: FertilizationCycleMinAggregateOutputType | null
    _max: FertilizationCycleMaxAggregateOutputType | null
  }

  type GetFertilizationCycleGroupByPayload<T extends FertilizationCycleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FertilizationCycleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FertilizationCycleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FertilizationCycleGroupByOutputType[P]>
            : GetScalarType<T[P], FertilizationCycleGroupByOutputType[P]>
        }
      >
    >


  export type FertilizationCycleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sequence?: boolean
    agrochemicalId?: boolean
    programId?: boolean
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    program?: boolean | FertilizationProgramDefaultArgs<ExtArgs>
    tasks?: boolean | FertilizationCycle$tasksArgs<ExtArgs>
    _count?: boolean | FertilizationCycleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fertilizationCycle"]>

  export type FertilizationCycleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sequence?: boolean
    agrochemicalId?: boolean
    programId?: boolean
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    program?: boolean | FertilizationProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fertilizationCycle"]>

  export type FertilizationCycleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sequence?: boolean
    agrochemicalId?: boolean
    programId?: boolean
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    program?: boolean | FertilizationProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fertilizationCycle"]>

  export type FertilizationCycleSelectScalar = {
    id?: boolean
    sequence?: boolean
    agrochemicalId?: boolean
    programId?: boolean
  }

  export type FertilizationCycleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sequence" | "agrochemicalId" | "programId", ExtArgs["result"]["fertilizationCycle"]>
  export type FertilizationCycleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    program?: boolean | FertilizationProgramDefaultArgs<ExtArgs>
    tasks?: boolean | FertilizationCycle$tasksArgs<ExtArgs>
    _count?: boolean | FertilizationCycleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FertilizationCycleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    program?: boolean | FertilizationProgramDefaultArgs<ExtArgs>
  }
  export type FertilizationCycleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    program?: boolean | FertilizationProgramDefaultArgs<ExtArgs>
  }

  export type $FertilizationCyclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FertilizationCycle"
    objects: {
      agrochemical: Prisma.$AgrochemicalPayload<ExtArgs>
      program: Prisma.$FertilizationProgramPayload<ExtArgs>
      tasks: Prisma.$FertilizationTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sequence: number
      agrochemicalId: string
      programId: string
    }, ExtArgs["result"]["fertilizationCycle"]>
    composites: {}
  }

  type FertilizationCycleGetPayload<S extends boolean | null | undefined | FertilizationCycleDefaultArgs> = $Result.GetResult<Prisma.$FertilizationCyclePayload, S>

  type FertilizationCycleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FertilizationCycleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FertilizationCycleCountAggregateInputType | true
    }

  export interface FertilizationCycleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FertilizationCycle'], meta: { name: 'FertilizationCycle' } }
    /**
     * Find zero or one FertilizationCycle that matches the filter.
     * @param {FertilizationCycleFindUniqueArgs} args - Arguments to find a FertilizationCycle
     * @example
     * // Get one FertilizationCycle
     * const fertilizationCycle = await prisma.fertilizationCycle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FertilizationCycleFindUniqueArgs>(args: SelectSubset<T, FertilizationCycleFindUniqueArgs<ExtArgs>>): Prisma__FertilizationCycleClient<$Result.GetResult<Prisma.$FertilizationCyclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FertilizationCycle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FertilizationCycleFindUniqueOrThrowArgs} args - Arguments to find a FertilizationCycle
     * @example
     * // Get one FertilizationCycle
     * const fertilizationCycle = await prisma.fertilizationCycle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FertilizationCycleFindUniqueOrThrowArgs>(args: SelectSubset<T, FertilizationCycleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FertilizationCycleClient<$Result.GetResult<Prisma.$FertilizationCyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FertilizationCycle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationCycleFindFirstArgs} args - Arguments to find a FertilizationCycle
     * @example
     * // Get one FertilizationCycle
     * const fertilizationCycle = await prisma.fertilizationCycle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FertilizationCycleFindFirstArgs>(args?: SelectSubset<T, FertilizationCycleFindFirstArgs<ExtArgs>>): Prisma__FertilizationCycleClient<$Result.GetResult<Prisma.$FertilizationCyclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FertilizationCycle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationCycleFindFirstOrThrowArgs} args - Arguments to find a FertilizationCycle
     * @example
     * // Get one FertilizationCycle
     * const fertilizationCycle = await prisma.fertilizationCycle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FertilizationCycleFindFirstOrThrowArgs>(args?: SelectSubset<T, FertilizationCycleFindFirstOrThrowArgs<ExtArgs>>): Prisma__FertilizationCycleClient<$Result.GetResult<Prisma.$FertilizationCyclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FertilizationCycles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationCycleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FertilizationCycles
     * const fertilizationCycles = await prisma.fertilizationCycle.findMany()
     * 
     * // Get first 10 FertilizationCycles
     * const fertilizationCycles = await prisma.fertilizationCycle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fertilizationCycleWithIdOnly = await prisma.fertilizationCycle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FertilizationCycleFindManyArgs>(args?: SelectSubset<T, FertilizationCycleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FertilizationCyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FertilizationCycle.
     * @param {FertilizationCycleCreateArgs} args - Arguments to create a FertilizationCycle.
     * @example
     * // Create one FertilizationCycle
     * const FertilizationCycle = await prisma.fertilizationCycle.create({
     *   data: {
     *     // ... data to create a FertilizationCycle
     *   }
     * })
     * 
     */
    create<T extends FertilizationCycleCreateArgs>(args: SelectSubset<T, FertilizationCycleCreateArgs<ExtArgs>>): Prisma__FertilizationCycleClient<$Result.GetResult<Prisma.$FertilizationCyclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FertilizationCycles.
     * @param {FertilizationCycleCreateManyArgs} args - Arguments to create many FertilizationCycles.
     * @example
     * // Create many FertilizationCycles
     * const fertilizationCycle = await prisma.fertilizationCycle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FertilizationCycleCreateManyArgs>(args?: SelectSubset<T, FertilizationCycleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FertilizationCycles and returns the data saved in the database.
     * @param {FertilizationCycleCreateManyAndReturnArgs} args - Arguments to create many FertilizationCycles.
     * @example
     * // Create many FertilizationCycles
     * const fertilizationCycle = await prisma.fertilizationCycle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FertilizationCycles and only return the `id`
     * const fertilizationCycleWithIdOnly = await prisma.fertilizationCycle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FertilizationCycleCreateManyAndReturnArgs>(args?: SelectSubset<T, FertilizationCycleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FertilizationCyclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FertilizationCycle.
     * @param {FertilizationCycleDeleteArgs} args - Arguments to delete one FertilizationCycle.
     * @example
     * // Delete one FertilizationCycle
     * const FertilizationCycle = await prisma.fertilizationCycle.delete({
     *   where: {
     *     // ... filter to delete one FertilizationCycle
     *   }
     * })
     * 
     */
    delete<T extends FertilizationCycleDeleteArgs>(args: SelectSubset<T, FertilizationCycleDeleteArgs<ExtArgs>>): Prisma__FertilizationCycleClient<$Result.GetResult<Prisma.$FertilizationCyclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FertilizationCycle.
     * @param {FertilizationCycleUpdateArgs} args - Arguments to update one FertilizationCycle.
     * @example
     * // Update one FertilizationCycle
     * const fertilizationCycle = await prisma.fertilizationCycle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FertilizationCycleUpdateArgs>(args: SelectSubset<T, FertilizationCycleUpdateArgs<ExtArgs>>): Prisma__FertilizationCycleClient<$Result.GetResult<Prisma.$FertilizationCyclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FertilizationCycles.
     * @param {FertilizationCycleDeleteManyArgs} args - Arguments to filter FertilizationCycles to delete.
     * @example
     * // Delete a few FertilizationCycles
     * const { count } = await prisma.fertilizationCycle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FertilizationCycleDeleteManyArgs>(args?: SelectSubset<T, FertilizationCycleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FertilizationCycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationCycleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FertilizationCycles
     * const fertilizationCycle = await prisma.fertilizationCycle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FertilizationCycleUpdateManyArgs>(args: SelectSubset<T, FertilizationCycleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FertilizationCycles and returns the data updated in the database.
     * @param {FertilizationCycleUpdateManyAndReturnArgs} args - Arguments to update many FertilizationCycles.
     * @example
     * // Update many FertilizationCycles
     * const fertilizationCycle = await prisma.fertilizationCycle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FertilizationCycles and only return the `id`
     * const fertilizationCycleWithIdOnly = await prisma.fertilizationCycle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FertilizationCycleUpdateManyAndReturnArgs>(args: SelectSubset<T, FertilizationCycleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FertilizationCyclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FertilizationCycle.
     * @param {FertilizationCycleUpsertArgs} args - Arguments to update or create a FertilizationCycle.
     * @example
     * // Update or create a FertilizationCycle
     * const fertilizationCycle = await prisma.fertilizationCycle.upsert({
     *   create: {
     *     // ... data to create a FertilizationCycle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FertilizationCycle we want to update
     *   }
     * })
     */
    upsert<T extends FertilizationCycleUpsertArgs>(args: SelectSubset<T, FertilizationCycleUpsertArgs<ExtArgs>>): Prisma__FertilizationCycleClient<$Result.GetResult<Prisma.$FertilizationCyclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FertilizationCycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationCycleCountArgs} args - Arguments to filter FertilizationCycles to count.
     * @example
     * // Count the number of FertilizationCycles
     * const count = await prisma.fertilizationCycle.count({
     *   where: {
     *     // ... the filter for the FertilizationCycles we want to count
     *   }
     * })
    **/
    count<T extends FertilizationCycleCountArgs>(
      args?: Subset<T, FertilizationCycleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FertilizationCycleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FertilizationCycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationCycleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FertilizationCycleAggregateArgs>(args: Subset<T, FertilizationCycleAggregateArgs>): Prisma.PrismaPromise<GetFertilizationCycleAggregateType<T>>

    /**
     * Group by FertilizationCycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationCycleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FertilizationCycleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FertilizationCycleGroupByArgs['orderBy'] }
        : { orderBy?: FertilizationCycleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FertilizationCycleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFertilizationCycleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FertilizationCycle model
   */
  readonly fields: FertilizationCycleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FertilizationCycle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FertilizationCycleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agrochemical<T extends AgrochemicalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgrochemicalDefaultArgs<ExtArgs>>): Prisma__AgrochemicalClient<$Result.GetResult<Prisma.$AgrochemicalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    program<T extends FertilizationProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FertilizationProgramDefaultArgs<ExtArgs>>): Prisma__FertilizationProgramClient<$Result.GetResult<Prisma.$FertilizationProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends FertilizationCycle$tasksArgs<ExtArgs> = {}>(args?: Subset<T, FertilizationCycle$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FertilizationTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FertilizationCycle model
   */
  interface FertilizationCycleFieldRefs {
    readonly id: FieldRef<"FertilizationCycle", 'String'>
    readonly sequence: FieldRef<"FertilizationCycle", 'Int'>
    readonly agrochemicalId: FieldRef<"FertilizationCycle", 'String'>
    readonly programId: FieldRef<"FertilizationCycle", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FertilizationCycle findUnique
   */
  export type FertilizationCycleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycle
     */
    select?: FertilizationCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationCycle
     */
    omit?: FertilizationCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationCycleInclude<ExtArgs> | null
    /**
     * Filter, which FertilizationCycle to fetch.
     */
    where: FertilizationCycleWhereUniqueInput
  }

  /**
   * FertilizationCycle findUniqueOrThrow
   */
  export type FertilizationCycleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycle
     */
    select?: FertilizationCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationCycle
     */
    omit?: FertilizationCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationCycleInclude<ExtArgs> | null
    /**
     * Filter, which FertilizationCycle to fetch.
     */
    where: FertilizationCycleWhereUniqueInput
  }

  /**
   * FertilizationCycle findFirst
   */
  export type FertilizationCycleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycle
     */
    select?: FertilizationCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationCycle
     */
    omit?: FertilizationCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationCycleInclude<ExtArgs> | null
    /**
     * Filter, which FertilizationCycle to fetch.
     */
    where?: FertilizationCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FertilizationCycles to fetch.
     */
    orderBy?: FertilizationCycleOrderByWithRelationInput | FertilizationCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FertilizationCycles.
     */
    cursor?: FertilizationCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FertilizationCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FertilizationCycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FertilizationCycles.
     */
    distinct?: FertilizationCycleScalarFieldEnum | FertilizationCycleScalarFieldEnum[]
  }

  /**
   * FertilizationCycle findFirstOrThrow
   */
  export type FertilizationCycleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycle
     */
    select?: FertilizationCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationCycle
     */
    omit?: FertilizationCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationCycleInclude<ExtArgs> | null
    /**
     * Filter, which FertilizationCycle to fetch.
     */
    where?: FertilizationCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FertilizationCycles to fetch.
     */
    orderBy?: FertilizationCycleOrderByWithRelationInput | FertilizationCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FertilizationCycles.
     */
    cursor?: FertilizationCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FertilizationCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FertilizationCycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FertilizationCycles.
     */
    distinct?: FertilizationCycleScalarFieldEnum | FertilizationCycleScalarFieldEnum[]
  }

  /**
   * FertilizationCycle findMany
   */
  export type FertilizationCycleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycle
     */
    select?: FertilizationCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationCycle
     */
    omit?: FertilizationCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationCycleInclude<ExtArgs> | null
    /**
     * Filter, which FertilizationCycles to fetch.
     */
    where?: FertilizationCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FertilizationCycles to fetch.
     */
    orderBy?: FertilizationCycleOrderByWithRelationInput | FertilizationCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FertilizationCycles.
     */
    cursor?: FertilizationCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FertilizationCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FertilizationCycles.
     */
    skip?: number
    distinct?: FertilizationCycleScalarFieldEnum | FertilizationCycleScalarFieldEnum[]
  }

  /**
   * FertilizationCycle create
   */
  export type FertilizationCycleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycle
     */
    select?: FertilizationCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationCycle
     */
    omit?: FertilizationCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationCycleInclude<ExtArgs> | null
    /**
     * The data needed to create a FertilizationCycle.
     */
    data: XOR<FertilizationCycleCreateInput, FertilizationCycleUncheckedCreateInput>
  }

  /**
   * FertilizationCycle createMany
   */
  export type FertilizationCycleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FertilizationCycles.
     */
    data: FertilizationCycleCreateManyInput | FertilizationCycleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FertilizationCycle createManyAndReturn
   */
  export type FertilizationCycleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycle
     */
    select?: FertilizationCycleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationCycle
     */
    omit?: FertilizationCycleOmit<ExtArgs> | null
    /**
     * The data used to create many FertilizationCycles.
     */
    data: FertilizationCycleCreateManyInput | FertilizationCycleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationCycleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FertilizationCycle update
   */
  export type FertilizationCycleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycle
     */
    select?: FertilizationCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationCycle
     */
    omit?: FertilizationCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationCycleInclude<ExtArgs> | null
    /**
     * The data needed to update a FertilizationCycle.
     */
    data: XOR<FertilizationCycleUpdateInput, FertilizationCycleUncheckedUpdateInput>
    /**
     * Choose, which FertilizationCycle to update.
     */
    where: FertilizationCycleWhereUniqueInput
  }

  /**
   * FertilizationCycle updateMany
   */
  export type FertilizationCycleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FertilizationCycles.
     */
    data: XOR<FertilizationCycleUpdateManyMutationInput, FertilizationCycleUncheckedUpdateManyInput>
    /**
     * Filter which FertilizationCycles to update
     */
    where?: FertilizationCycleWhereInput
    /**
     * Limit how many FertilizationCycles to update.
     */
    limit?: number
  }

  /**
   * FertilizationCycle updateManyAndReturn
   */
  export type FertilizationCycleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycle
     */
    select?: FertilizationCycleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationCycle
     */
    omit?: FertilizationCycleOmit<ExtArgs> | null
    /**
     * The data used to update FertilizationCycles.
     */
    data: XOR<FertilizationCycleUpdateManyMutationInput, FertilizationCycleUncheckedUpdateManyInput>
    /**
     * Filter which FertilizationCycles to update
     */
    where?: FertilizationCycleWhereInput
    /**
     * Limit how many FertilizationCycles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationCycleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FertilizationCycle upsert
   */
  export type FertilizationCycleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycle
     */
    select?: FertilizationCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationCycle
     */
    omit?: FertilizationCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationCycleInclude<ExtArgs> | null
    /**
     * The filter to search for the FertilizationCycle to update in case it exists.
     */
    where: FertilizationCycleWhereUniqueInput
    /**
     * In case the FertilizationCycle found by the `where` argument doesn't exist, create a new FertilizationCycle with this data.
     */
    create: XOR<FertilizationCycleCreateInput, FertilizationCycleUncheckedCreateInput>
    /**
     * In case the FertilizationCycle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FertilizationCycleUpdateInput, FertilizationCycleUncheckedUpdateInput>
  }

  /**
   * FertilizationCycle delete
   */
  export type FertilizationCycleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycle
     */
    select?: FertilizationCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationCycle
     */
    omit?: FertilizationCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationCycleInclude<ExtArgs> | null
    /**
     * Filter which FertilizationCycle to delete.
     */
    where: FertilizationCycleWhereUniqueInput
  }

  /**
   * FertilizationCycle deleteMany
   */
  export type FertilizationCycleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FertilizationCycles to delete
     */
    where?: FertilizationCycleWhereInput
    /**
     * Limit how many FertilizationCycles to delete.
     */
    limit?: number
  }

  /**
   * FertilizationCycle.tasks
   */
  export type FertilizationCycle$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationTask
     */
    select?: FertilizationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationTask
     */
    omit?: FertilizationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationTaskInclude<ExtArgs> | null
    where?: FertilizationTaskWhereInput
    orderBy?: FertilizationTaskOrderByWithRelationInput | FertilizationTaskOrderByWithRelationInput[]
    cursor?: FertilizationTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FertilizationTaskScalarFieldEnum | FertilizationTaskScalarFieldEnum[]
  }

  /**
   * FertilizationCycle without action
   */
  export type FertilizationCycleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycle
     */
    select?: FertilizationCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationCycle
     */
    omit?: FertilizationCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationCycleInclude<ExtArgs> | null
  }


  /**
   * Model FertilizationTask
   */

  export type AggregateFertilizationTask = {
    _count: FertilizationTaskCountAggregateOutputType | null
    _min: FertilizationTaskMinAggregateOutputType | null
    _max: FertilizationTaskMaxAggregateOutputType | null
  }

  export type FertilizationTaskMinAggregateOutputType = {
    id: string | null
    scheduledDate: Date | null
    executionDate: Date | null
    note: string | null
    status: $Enums.TaskStatus | null
    agrochemicalId: string | null
    productsCycleId: string | null
  }

  export type FertilizationTaskMaxAggregateOutputType = {
    id: string | null
    scheduledDate: Date | null
    executionDate: Date | null
    note: string | null
    status: $Enums.TaskStatus | null
    agrochemicalId: string | null
    productsCycleId: string | null
  }

  export type FertilizationTaskCountAggregateOutputType = {
    id: number
    scheduledDate: number
    executionDate: number
    zones: number
    note: number
    status: number
    agrochemicalId: number
    productsCycleId: number
    _all: number
  }


  export type FertilizationTaskMinAggregateInputType = {
    id?: true
    scheduledDate?: true
    executionDate?: true
    note?: true
    status?: true
    agrochemicalId?: true
    productsCycleId?: true
  }

  export type FertilizationTaskMaxAggregateInputType = {
    id?: true
    scheduledDate?: true
    executionDate?: true
    note?: true
    status?: true
    agrochemicalId?: true
    productsCycleId?: true
  }

  export type FertilizationTaskCountAggregateInputType = {
    id?: true
    scheduledDate?: true
    executionDate?: true
    zones?: true
    note?: true
    status?: true
    agrochemicalId?: true
    productsCycleId?: true
    _all?: true
  }

  export type FertilizationTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FertilizationTask to aggregate.
     */
    where?: FertilizationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FertilizationTasks to fetch.
     */
    orderBy?: FertilizationTaskOrderByWithRelationInput | FertilizationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FertilizationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FertilizationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FertilizationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FertilizationTasks
    **/
    _count?: true | FertilizationTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FertilizationTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FertilizationTaskMaxAggregateInputType
  }

  export type GetFertilizationTaskAggregateType<T extends FertilizationTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateFertilizationTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFertilizationTask[P]>
      : GetScalarType<T[P], AggregateFertilizationTask[P]>
  }




  export type FertilizationTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FertilizationTaskWhereInput
    orderBy?: FertilizationTaskOrderByWithAggregationInput | FertilizationTaskOrderByWithAggregationInput[]
    by: FertilizationTaskScalarFieldEnum[] | FertilizationTaskScalarFieldEnum
    having?: FertilizationTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FertilizationTaskCountAggregateInputType | true
    _min?: FertilizationTaskMinAggregateInputType
    _max?: FertilizationTaskMaxAggregateInputType
  }

  export type FertilizationTaskGroupByOutputType = {
    id: string
    scheduledDate: Date
    executionDate: Date | null
    zones: $Enums.ZoneType[]
    note: string | null
    status: $Enums.TaskStatus
    agrochemicalId: string
    productsCycleId: string | null
    _count: FertilizationTaskCountAggregateOutputType | null
    _min: FertilizationTaskMinAggregateOutputType | null
    _max: FertilizationTaskMaxAggregateOutputType | null
  }

  type GetFertilizationTaskGroupByPayload<T extends FertilizationTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FertilizationTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FertilizationTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FertilizationTaskGroupByOutputType[P]>
            : GetScalarType<T[P], FertilizationTaskGroupByOutputType[P]>
        }
      >
    >


  export type FertilizationTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduledDate?: boolean
    executionDate?: boolean
    zones?: boolean
    note?: boolean
    status?: boolean
    agrochemicalId?: boolean
    productsCycleId?: boolean
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    productsCycle?: boolean | FertilizationTask$productsCycleArgs<ExtArgs>
  }, ExtArgs["result"]["fertilizationTask"]>

  export type FertilizationTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduledDate?: boolean
    executionDate?: boolean
    zones?: boolean
    note?: boolean
    status?: boolean
    agrochemicalId?: boolean
    productsCycleId?: boolean
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    productsCycle?: boolean | FertilizationTask$productsCycleArgs<ExtArgs>
  }, ExtArgs["result"]["fertilizationTask"]>

  export type FertilizationTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduledDate?: boolean
    executionDate?: boolean
    zones?: boolean
    note?: boolean
    status?: boolean
    agrochemicalId?: boolean
    productsCycleId?: boolean
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    productsCycle?: boolean | FertilizationTask$productsCycleArgs<ExtArgs>
  }, ExtArgs["result"]["fertilizationTask"]>

  export type FertilizationTaskSelectScalar = {
    id?: boolean
    scheduledDate?: boolean
    executionDate?: boolean
    zones?: boolean
    note?: boolean
    status?: boolean
    agrochemicalId?: boolean
    productsCycleId?: boolean
  }

  export type FertilizationTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scheduledDate" | "executionDate" | "zones" | "note" | "status" | "agrochemicalId" | "productsCycleId", ExtArgs["result"]["fertilizationTask"]>
  export type FertilizationTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    productsCycle?: boolean | FertilizationTask$productsCycleArgs<ExtArgs>
  }
  export type FertilizationTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    productsCycle?: boolean | FertilizationTask$productsCycleArgs<ExtArgs>
  }
  export type FertilizationTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    productsCycle?: boolean | FertilizationTask$productsCycleArgs<ExtArgs>
  }

  export type $FertilizationTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FertilizationTask"
    objects: {
      agrochemical: Prisma.$AgrochemicalPayload<ExtArgs>
      productsCycle: Prisma.$FertilizationCyclePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scheduledDate: Date
      executionDate: Date | null
      zones: $Enums.ZoneType[]
      note: string | null
      status: $Enums.TaskStatus
      agrochemicalId: string
      productsCycleId: string | null
    }, ExtArgs["result"]["fertilizationTask"]>
    composites: {}
  }

  type FertilizationTaskGetPayload<S extends boolean | null | undefined | FertilizationTaskDefaultArgs> = $Result.GetResult<Prisma.$FertilizationTaskPayload, S>

  type FertilizationTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FertilizationTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FertilizationTaskCountAggregateInputType | true
    }

  export interface FertilizationTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FertilizationTask'], meta: { name: 'FertilizationTask' } }
    /**
     * Find zero or one FertilizationTask that matches the filter.
     * @param {FertilizationTaskFindUniqueArgs} args - Arguments to find a FertilizationTask
     * @example
     * // Get one FertilizationTask
     * const fertilizationTask = await prisma.fertilizationTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FertilizationTaskFindUniqueArgs>(args: SelectSubset<T, FertilizationTaskFindUniqueArgs<ExtArgs>>): Prisma__FertilizationTaskClient<$Result.GetResult<Prisma.$FertilizationTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FertilizationTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FertilizationTaskFindUniqueOrThrowArgs} args - Arguments to find a FertilizationTask
     * @example
     * // Get one FertilizationTask
     * const fertilizationTask = await prisma.fertilizationTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FertilizationTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, FertilizationTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FertilizationTaskClient<$Result.GetResult<Prisma.$FertilizationTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FertilizationTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationTaskFindFirstArgs} args - Arguments to find a FertilizationTask
     * @example
     * // Get one FertilizationTask
     * const fertilizationTask = await prisma.fertilizationTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FertilizationTaskFindFirstArgs>(args?: SelectSubset<T, FertilizationTaskFindFirstArgs<ExtArgs>>): Prisma__FertilizationTaskClient<$Result.GetResult<Prisma.$FertilizationTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FertilizationTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationTaskFindFirstOrThrowArgs} args - Arguments to find a FertilizationTask
     * @example
     * // Get one FertilizationTask
     * const fertilizationTask = await prisma.fertilizationTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FertilizationTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, FertilizationTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__FertilizationTaskClient<$Result.GetResult<Prisma.$FertilizationTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FertilizationTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FertilizationTasks
     * const fertilizationTasks = await prisma.fertilizationTask.findMany()
     * 
     * // Get first 10 FertilizationTasks
     * const fertilizationTasks = await prisma.fertilizationTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fertilizationTaskWithIdOnly = await prisma.fertilizationTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FertilizationTaskFindManyArgs>(args?: SelectSubset<T, FertilizationTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FertilizationTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FertilizationTask.
     * @param {FertilizationTaskCreateArgs} args - Arguments to create a FertilizationTask.
     * @example
     * // Create one FertilizationTask
     * const FertilizationTask = await prisma.fertilizationTask.create({
     *   data: {
     *     // ... data to create a FertilizationTask
     *   }
     * })
     * 
     */
    create<T extends FertilizationTaskCreateArgs>(args: SelectSubset<T, FertilizationTaskCreateArgs<ExtArgs>>): Prisma__FertilizationTaskClient<$Result.GetResult<Prisma.$FertilizationTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FertilizationTasks.
     * @param {FertilizationTaskCreateManyArgs} args - Arguments to create many FertilizationTasks.
     * @example
     * // Create many FertilizationTasks
     * const fertilizationTask = await prisma.fertilizationTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FertilizationTaskCreateManyArgs>(args?: SelectSubset<T, FertilizationTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FertilizationTasks and returns the data saved in the database.
     * @param {FertilizationTaskCreateManyAndReturnArgs} args - Arguments to create many FertilizationTasks.
     * @example
     * // Create many FertilizationTasks
     * const fertilizationTask = await prisma.fertilizationTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FertilizationTasks and only return the `id`
     * const fertilizationTaskWithIdOnly = await prisma.fertilizationTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FertilizationTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, FertilizationTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FertilizationTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FertilizationTask.
     * @param {FertilizationTaskDeleteArgs} args - Arguments to delete one FertilizationTask.
     * @example
     * // Delete one FertilizationTask
     * const FertilizationTask = await prisma.fertilizationTask.delete({
     *   where: {
     *     // ... filter to delete one FertilizationTask
     *   }
     * })
     * 
     */
    delete<T extends FertilizationTaskDeleteArgs>(args: SelectSubset<T, FertilizationTaskDeleteArgs<ExtArgs>>): Prisma__FertilizationTaskClient<$Result.GetResult<Prisma.$FertilizationTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FertilizationTask.
     * @param {FertilizationTaskUpdateArgs} args - Arguments to update one FertilizationTask.
     * @example
     * // Update one FertilizationTask
     * const fertilizationTask = await prisma.fertilizationTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FertilizationTaskUpdateArgs>(args: SelectSubset<T, FertilizationTaskUpdateArgs<ExtArgs>>): Prisma__FertilizationTaskClient<$Result.GetResult<Prisma.$FertilizationTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FertilizationTasks.
     * @param {FertilizationTaskDeleteManyArgs} args - Arguments to filter FertilizationTasks to delete.
     * @example
     * // Delete a few FertilizationTasks
     * const { count } = await prisma.fertilizationTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FertilizationTaskDeleteManyArgs>(args?: SelectSubset<T, FertilizationTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FertilizationTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FertilizationTasks
     * const fertilizationTask = await prisma.fertilizationTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FertilizationTaskUpdateManyArgs>(args: SelectSubset<T, FertilizationTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FertilizationTasks and returns the data updated in the database.
     * @param {FertilizationTaskUpdateManyAndReturnArgs} args - Arguments to update many FertilizationTasks.
     * @example
     * // Update many FertilizationTasks
     * const fertilizationTask = await prisma.fertilizationTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FertilizationTasks and only return the `id`
     * const fertilizationTaskWithIdOnly = await prisma.fertilizationTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FertilizationTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, FertilizationTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FertilizationTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FertilizationTask.
     * @param {FertilizationTaskUpsertArgs} args - Arguments to update or create a FertilizationTask.
     * @example
     * // Update or create a FertilizationTask
     * const fertilizationTask = await prisma.fertilizationTask.upsert({
     *   create: {
     *     // ... data to create a FertilizationTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FertilizationTask we want to update
     *   }
     * })
     */
    upsert<T extends FertilizationTaskUpsertArgs>(args: SelectSubset<T, FertilizationTaskUpsertArgs<ExtArgs>>): Prisma__FertilizationTaskClient<$Result.GetResult<Prisma.$FertilizationTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FertilizationTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationTaskCountArgs} args - Arguments to filter FertilizationTasks to count.
     * @example
     * // Count the number of FertilizationTasks
     * const count = await prisma.fertilizationTask.count({
     *   where: {
     *     // ... the filter for the FertilizationTasks we want to count
     *   }
     * })
    **/
    count<T extends FertilizationTaskCountArgs>(
      args?: Subset<T, FertilizationTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FertilizationTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FertilizationTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FertilizationTaskAggregateArgs>(args: Subset<T, FertilizationTaskAggregateArgs>): Prisma.PrismaPromise<GetFertilizationTaskAggregateType<T>>

    /**
     * Group by FertilizationTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FertilizationTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FertilizationTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FertilizationTaskGroupByArgs['orderBy'] }
        : { orderBy?: FertilizationTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FertilizationTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFertilizationTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FertilizationTask model
   */
  readonly fields: FertilizationTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FertilizationTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FertilizationTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agrochemical<T extends AgrochemicalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgrochemicalDefaultArgs<ExtArgs>>): Prisma__AgrochemicalClient<$Result.GetResult<Prisma.$AgrochemicalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productsCycle<T extends FertilizationTask$productsCycleArgs<ExtArgs> = {}>(args?: Subset<T, FertilizationTask$productsCycleArgs<ExtArgs>>): Prisma__FertilizationCycleClient<$Result.GetResult<Prisma.$FertilizationCyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FertilizationTask model
   */
  interface FertilizationTaskFieldRefs {
    readonly id: FieldRef<"FertilizationTask", 'String'>
    readonly scheduledDate: FieldRef<"FertilizationTask", 'DateTime'>
    readonly executionDate: FieldRef<"FertilizationTask", 'DateTime'>
    readonly zones: FieldRef<"FertilizationTask", 'ZoneType[]'>
    readonly note: FieldRef<"FertilizationTask", 'String'>
    readonly status: FieldRef<"FertilizationTask", 'TaskStatus'>
    readonly agrochemicalId: FieldRef<"FertilizationTask", 'String'>
    readonly productsCycleId: FieldRef<"FertilizationTask", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FertilizationTask findUnique
   */
  export type FertilizationTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationTask
     */
    select?: FertilizationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationTask
     */
    omit?: FertilizationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationTaskInclude<ExtArgs> | null
    /**
     * Filter, which FertilizationTask to fetch.
     */
    where: FertilizationTaskWhereUniqueInput
  }

  /**
   * FertilizationTask findUniqueOrThrow
   */
  export type FertilizationTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationTask
     */
    select?: FertilizationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationTask
     */
    omit?: FertilizationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationTaskInclude<ExtArgs> | null
    /**
     * Filter, which FertilizationTask to fetch.
     */
    where: FertilizationTaskWhereUniqueInput
  }

  /**
   * FertilizationTask findFirst
   */
  export type FertilizationTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationTask
     */
    select?: FertilizationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationTask
     */
    omit?: FertilizationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationTaskInclude<ExtArgs> | null
    /**
     * Filter, which FertilizationTask to fetch.
     */
    where?: FertilizationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FertilizationTasks to fetch.
     */
    orderBy?: FertilizationTaskOrderByWithRelationInput | FertilizationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FertilizationTasks.
     */
    cursor?: FertilizationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FertilizationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FertilizationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FertilizationTasks.
     */
    distinct?: FertilizationTaskScalarFieldEnum | FertilizationTaskScalarFieldEnum[]
  }

  /**
   * FertilizationTask findFirstOrThrow
   */
  export type FertilizationTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationTask
     */
    select?: FertilizationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationTask
     */
    omit?: FertilizationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationTaskInclude<ExtArgs> | null
    /**
     * Filter, which FertilizationTask to fetch.
     */
    where?: FertilizationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FertilizationTasks to fetch.
     */
    orderBy?: FertilizationTaskOrderByWithRelationInput | FertilizationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FertilizationTasks.
     */
    cursor?: FertilizationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FertilizationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FertilizationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FertilizationTasks.
     */
    distinct?: FertilizationTaskScalarFieldEnum | FertilizationTaskScalarFieldEnum[]
  }

  /**
   * FertilizationTask findMany
   */
  export type FertilizationTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationTask
     */
    select?: FertilizationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationTask
     */
    omit?: FertilizationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationTaskInclude<ExtArgs> | null
    /**
     * Filter, which FertilizationTasks to fetch.
     */
    where?: FertilizationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FertilizationTasks to fetch.
     */
    orderBy?: FertilizationTaskOrderByWithRelationInput | FertilizationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FertilizationTasks.
     */
    cursor?: FertilizationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FertilizationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FertilizationTasks.
     */
    skip?: number
    distinct?: FertilizationTaskScalarFieldEnum | FertilizationTaskScalarFieldEnum[]
  }

  /**
   * FertilizationTask create
   */
  export type FertilizationTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationTask
     */
    select?: FertilizationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationTask
     */
    omit?: FertilizationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a FertilizationTask.
     */
    data: XOR<FertilizationTaskCreateInput, FertilizationTaskUncheckedCreateInput>
  }

  /**
   * FertilizationTask createMany
   */
  export type FertilizationTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FertilizationTasks.
     */
    data: FertilizationTaskCreateManyInput | FertilizationTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FertilizationTask createManyAndReturn
   */
  export type FertilizationTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationTask
     */
    select?: FertilizationTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationTask
     */
    omit?: FertilizationTaskOmit<ExtArgs> | null
    /**
     * The data used to create many FertilizationTasks.
     */
    data: FertilizationTaskCreateManyInput | FertilizationTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FertilizationTask update
   */
  export type FertilizationTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationTask
     */
    select?: FertilizationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationTask
     */
    omit?: FertilizationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a FertilizationTask.
     */
    data: XOR<FertilizationTaskUpdateInput, FertilizationTaskUncheckedUpdateInput>
    /**
     * Choose, which FertilizationTask to update.
     */
    where: FertilizationTaskWhereUniqueInput
  }

  /**
   * FertilizationTask updateMany
   */
  export type FertilizationTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FertilizationTasks.
     */
    data: XOR<FertilizationTaskUpdateManyMutationInput, FertilizationTaskUncheckedUpdateManyInput>
    /**
     * Filter which FertilizationTasks to update
     */
    where?: FertilizationTaskWhereInput
    /**
     * Limit how many FertilizationTasks to update.
     */
    limit?: number
  }

  /**
   * FertilizationTask updateManyAndReturn
   */
  export type FertilizationTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationTask
     */
    select?: FertilizationTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationTask
     */
    omit?: FertilizationTaskOmit<ExtArgs> | null
    /**
     * The data used to update FertilizationTasks.
     */
    data: XOR<FertilizationTaskUpdateManyMutationInput, FertilizationTaskUncheckedUpdateManyInput>
    /**
     * Filter which FertilizationTasks to update
     */
    where?: FertilizationTaskWhereInput
    /**
     * Limit how many FertilizationTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FertilizationTask upsert
   */
  export type FertilizationTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationTask
     */
    select?: FertilizationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationTask
     */
    omit?: FertilizationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the FertilizationTask to update in case it exists.
     */
    where: FertilizationTaskWhereUniqueInput
    /**
     * In case the FertilizationTask found by the `where` argument doesn't exist, create a new FertilizationTask with this data.
     */
    create: XOR<FertilizationTaskCreateInput, FertilizationTaskUncheckedCreateInput>
    /**
     * In case the FertilizationTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FertilizationTaskUpdateInput, FertilizationTaskUncheckedUpdateInput>
  }

  /**
   * FertilizationTask delete
   */
  export type FertilizationTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationTask
     */
    select?: FertilizationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationTask
     */
    omit?: FertilizationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationTaskInclude<ExtArgs> | null
    /**
     * Filter which FertilizationTask to delete.
     */
    where: FertilizationTaskWhereUniqueInput
  }

  /**
   * FertilizationTask deleteMany
   */
  export type FertilizationTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FertilizationTasks to delete
     */
    where?: FertilizationTaskWhereInput
    /**
     * Limit how many FertilizationTasks to delete.
     */
    limit?: number
  }

  /**
   * FertilizationTask.productsCycle
   */
  export type FertilizationTask$productsCycleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationCycle
     */
    select?: FertilizationCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationCycle
     */
    omit?: FertilizationCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationCycleInclude<ExtArgs> | null
    where?: FertilizationCycleWhereInput
  }

  /**
   * FertilizationTask without action
   */
  export type FertilizationTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FertilizationTask
     */
    select?: FertilizationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FertilizationTask
     */
    omit?: FertilizationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FertilizationTaskInclude<ExtArgs> | null
  }


  /**
   * Model PhytosanitaryProgram
   */

  export type AggregatePhytosanitaryProgram = {
    _count: PhytosanitaryProgramCountAggregateOutputType | null
    _avg: PhytosanitaryProgramAvgAggregateOutputType | null
    _sum: PhytosanitaryProgramSumAggregateOutputType | null
    _min: PhytosanitaryProgramMinAggregateOutputType | null
    _max: PhytosanitaryProgramMaxAggregateOutputType | null
  }

  export type PhytosanitaryProgramAvgAggregateOutputType = {
    monthlyFrequency: number | null
  }

  export type PhytosanitaryProgramSumAggregateOutputType = {
    monthlyFrequency: number | null
  }

  export type PhytosanitaryProgramMinAggregateOutputType = {
    id: string | null
    name: string | null
    monthlyFrequency: number | null
  }

  export type PhytosanitaryProgramMaxAggregateOutputType = {
    id: string | null
    name: string | null
    monthlyFrequency: number | null
  }

  export type PhytosanitaryProgramCountAggregateOutputType = {
    id: number
    name: number
    monthlyFrequency: number
    _all: number
  }


  export type PhytosanitaryProgramAvgAggregateInputType = {
    monthlyFrequency?: true
  }

  export type PhytosanitaryProgramSumAggregateInputType = {
    monthlyFrequency?: true
  }

  export type PhytosanitaryProgramMinAggregateInputType = {
    id?: true
    name?: true
    monthlyFrequency?: true
  }

  export type PhytosanitaryProgramMaxAggregateInputType = {
    id?: true
    name?: true
    monthlyFrequency?: true
  }

  export type PhytosanitaryProgramCountAggregateInputType = {
    id?: true
    name?: true
    monthlyFrequency?: true
    _all?: true
  }

  export type PhytosanitaryProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhytosanitaryProgram to aggregate.
     */
    where?: PhytosanitaryProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhytosanitaryPrograms to fetch.
     */
    orderBy?: PhytosanitaryProgramOrderByWithRelationInput | PhytosanitaryProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhytosanitaryProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhytosanitaryPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhytosanitaryPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhytosanitaryPrograms
    **/
    _count?: true | PhytosanitaryProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhytosanitaryProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhytosanitaryProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhytosanitaryProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhytosanitaryProgramMaxAggregateInputType
  }

  export type GetPhytosanitaryProgramAggregateType<T extends PhytosanitaryProgramAggregateArgs> = {
        [P in keyof T & keyof AggregatePhytosanitaryProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhytosanitaryProgram[P]>
      : GetScalarType<T[P], AggregatePhytosanitaryProgram[P]>
  }




  export type PhytosanitaryProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhytosanitaryProgramWhereInput
    orderBy?: PhytosanitaryProgramOrderByWithAggregationInput | PhytosanitaryProgramOrderByWithAggregationInput[]
    by: PhytosanitaryProgramScalarFieldEnum[] | PhytosanitaryProgramScalarFieldEnum
    having?: PhytosanitaryProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhytosanitaryProgramCountAggregateInputType | true
    _avg?: PhytosanitaryProgramAvgAggregateInputType
    _sum?: PhytosanitaryProgramSumAggregateInputType
    _min?: PhytosanitaryProgramMinAggregateInputType
    _max?: PhytosanitaryProgramMaxAggregateInputType
  }

  export type PhytosanitaryProgramGroupByOutputType = {
    id: string
    name: string
    monthlyFrequency: number
    _count: PhytosanitaryProgramCountAggregateOutputType | null
    _avg: PhytosanitaryProgramAvgAggregateOutputType | null
    _sum: PhytosanitaryProgramSumAggregateOutputType | null
    _min: PhytosanitaryProgramMinAggregateOutputType | null
    _max: PhytosanitaryProgramMaxAggregateOutputType | null
  }

  type GetPhytosanitaryProgramGroupByPayload<T extends PhytosanitaryProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhytosanitaryProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhytosanitaryProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhytosanitaryProgramGroupByOutputType[P]>
            : GetScalarType<T[P], PhytosanitaryProgramGroupByOutputType[P]>
        }
      >
    >


  export type PhytosanitaryProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    monthlyFrequency?: boolean
    productsCycle?: boolean | PhytosanitaryProgram$productsCycleArgs<ExtArgs>
    _count?: boolean | PhytosanitaryProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phytosanitaryProgram"]>

  export type PhytosanitaryProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    monthlyFrequency?: boolean
  }, ExtArgs["result"]["phytosanitaryProgram"]>

  export type PhytosanitaryProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    monthlyFrequency?: boolean
  }, ExtArgs["result"]["phytosanitaryProgram"]>

  export type PhytosanitaryProgramSelectScalar = {
    id?: boolean
    name?: boolean
    monthlyFrequency?: boolean
  }

  export type PhytosanitaryProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "monthlyFrequency", ExtArgs["result"]["phytosanitaryProgram"]>
  export type PhytosanitaryProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productsCycle?: boolean | PhytosanitaryProgram$productsCycleArgs<ExtArgs>
    _count?: boolean | PhytosanitaryProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PhytosanitaryProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PhytosanitaryProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PhytosanitaryProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhytosanitaryProgram"
    objects: {
      productsCycle: Prisma.$PhytosanitaryCyclePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      monthlyFrequency: number
    }, ExtArgs["result"]["phytosanitaryProgram"]>
    composites: {}
  }

  type PhytosanitaryProgramGetPayload<S extends boolean | null | undefined | PhytosanitaryProgramDefaultArgs> = $Result.GetResult<Prisma.$PhytosanitaryProgramPayload, S>

  type PhytosanitaryProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhytosanitaryProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhytosanitaryProgramCountAggregateInputType | true
    }

  export interface PhytosanitaryProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhytosanitaryProgram'], meta: { name: 'PhytosanitaryProgram' } }
    /**
     * Find zero or one PhytosanitaryProgram that matches the filter.
     * @param {PhytosanitaryProgramFindUniqueArgs} args - Arguments to find a PhytosanitaryProgram
     * @example
     * // Get one PhytosanitaryProgram
     * const phytosanitaryProgram = await prisma.phytosanitaryProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhytosanitaryProgramFindUniqueArgs>(args: SelectSubset<T, PhytosanitaryProgramFindUniqueArgs<ExtArgs>>): Prisma__PhytosanitaryProgramClient<$Result.GetResult<Prisma.$PhytosanitaryProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PhytosanitaryProgram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhytosanitaryProgramFindUniqueOrThrowArgs} args - Arguments to find a PhytosanitaryProgram
     * @example
     * // Get one PhytosanitaryProgram
     * const phytosanitaryProgram = await prisma.phytosanitaryProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhytosanitaryProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, PhytosanitaryProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhytosanitaryProgramClient<$Result.GetResult<Prisma.$PhytosanitaryProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhytosanitaryProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryProgramFindFirstArgs} args - Arguments to find a PhytosanitaryProgram
     * @example
     * // Get one PhytosanitaryProgram
     * const phytosanitaryProgram = await prisma.phytosanitaryProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhytosanitaryProgramFindFirstArgs>(args?: SelectSubset<T, PhytosanitaryProgramFindFirstArgs<ExtArgs>>): Prisma__PhytosanitaryProgramClient<$Result.GetResult<Prisma.$PhytosanitaryProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhytosanitaryProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryProgramFindFirstOrThrowArgs} args - Arguments to find a PhytosanitaryProgram
     * @example
     * // Get one PhytosanitaryProgram
     * const phytosanitaryProgram = await prisma.phytosanitaryProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhytosanitaryProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, PhytosanitaryProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhytosanitaryProgramClient<$Result.GetResult<Prisma.$PhytosanitaryProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PhytosanitaryPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhytosanitaryPrograms
     * const phytosanitaryPrograms = await prisma.phytosanitaryProgram.findMany()
     * 
     * // Get first 10 PhytosanitaryPrograms
     * const phytosanitaryPrograms = await prisma.phytosanitaryProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phytosanitaryProgramWithIdOnly = await prisma.phytosanitaryProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhytosanitaryProgramFindManyArgs>(args?: SelectSubset<T, PhytosanitaryProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhytosanitaryProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PhytosanitaryProgram.
     * @param {PhytosanitaryProgramCreateArgs} args - Arguments to create a PhytosanitaryProgram.
     * @example
     * // Create one PhytosanitaryProgram
     * const PhytosanitaryProgram = await prisma.phytosanitaryProgram.create({
     *   data: {
     *     // ... data to create a PhytosanitaryProgram
     *   }
     * })
     * 
     */
    create<T extends PhytosanitaryProgramCreateArgs>(args: SelectSubset<T, PhytosanitaryProgramCreateArgs<ExtArgs>>): Prisma__PhytosanitaryProgramClient<$Result.GetResult<Prisma.$PhytosanitaryProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PhytosanitaryPrograms.
     * @param {PhytosanitaryProgramCreateManyArgs} args - Arguments to create many PhytosanitaryPrograms.
     * @example
     * // Create many PhytosanitaryPrograms
     * const phytosanitaryProgram = await prisma.phytosanitaryProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhytosanitaryProgramCreateManyArgs>(args?: SelectSubset<T, PhytosanitaryProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PhytosanitaryPrograms and returns the data saved in the database.
     * @param {PhytosanitaryProgramCreateManyAndReturnArgs} args - Arguments to create many PhytosanitaryPrograms.
     * @example
     * // Create many PhytosanitaryPrograms
     * const phytosanitaryProgram = await prisma.phytosanitaryProgram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PhytosanitaryPrograms and only return the `id`
     * const phytosanitaryProgramWithIdOnly = await prisma.phytosanitaryProgram.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhytosanitaryProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, PhytosanitaryProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhytosanitaryProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PhytosanitaryProgram.
     * @param {PhytosanitaryProgramDeleteArgs} args - Arguments to delete one PhytosanitaryProgram.
     * @example
     * // Delete one PhytosanitaryProgram
     * const PhytosanitaryProgram = await prisma.phytosanitaryProgram.delete({
     *   where: {
     *     // ... filter to delete one PhytosanitaryProgram
     *   }
     * })
     * 
     */
    delete<T extends PhytosanitaryProgramDeleteArgs>(args: SelectSubset<T, PhytosanitaryProgramDeleteArgs<ExtArgs>>): Prisma__PhytosanitaryProgramClient<$Result.GetResult<Prisma.$PhytosanitaryProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PhytosanitaryProgram.
     * @param {PhytosanitaryProgramUpdateArgs} args - Arguments to update one PhytosanitaryProgram.
     * @example
     * // Update one PhytosanitaryProgram
     * const phytosanitaryProgram = await prisma.phytosanitaryProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhytosanitaryProgramUpdateArgs>(args: SelectSubset<T, PhytosanitaryProgramUpdateArgs<ExtArgs>>): Prisma__PhytosanitaryProgramClient<$Result.GetResult<Prisma.$PhytosanitaryProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PhytosanitaryPrograms.
     * @param {PhytosanitaryProgramDeleteManyArgs} args - Arguments to filter PhytosanitaryPrograms to delete.
     * @example
     * // Delete a few PhytosanitaryPrograms
     * const { count } = await prisma.phytosanitaryProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhytosanitaryProgramDeleteManyArgs>(args?: SelectSubset<T, PhytosanitaryProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhytosanitaryPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhytosanitaryPrograms
     * const phytosanitaryProgram = await prisma.phytosanitaryProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhytosanitaryProgramUpdateManyArgs>(args: SelectSubset<T, PhytosanitaryProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhytosanitaryPrograms and returns the data updated in the database.
     * @param {PhytosanitaryProgramUpdateManyAndReturnArgs} args - Arguments to update many PhytosanitaryPrograms.
     * @example
     * // Update many PhytosanitaryPrograms
     * const phytosanitaryProgram = await prisma.phytosanitaryProgram.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PhytosanitaryPrograms and only return the `id`
     * const phytosanitaryProgramWithIdOnly = await prisma.phytosanitaryProgram.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PhytosanitaryProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, PhytosanitaryProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhytosanitaryProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PhytosanitaryProgram.
     * @param {PhytosanitaryProgramUpsertArgs} args - Arguments to update or create a PhytosanitaryProgram.
     * @example
     * // Update or create a PhytosanitaryProgram
     * const phytosanitaryProgram = await prisma.phytosanitaryProgram.upsert({
     *   create: {
     *     // ... data to create a PhytosanitaryProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhytosanitaryProgram we want to update
     *   }
     * })
     */
    upsert<T extends PhytosanitaryProgramUpsertArgs>(args: SelectSubset<T, PhytosanitaryProgramUpsertArgs<ExtArgs>>): Prisma__PhytosanitaryProgramClient<$Result.GetResult<Prisma.$PhytosanitaryProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PhytosanitaryPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryProgramCountArgs} args - Arguments to filter PhytosanitaryPrograms to count.
     * @example
     * // Count the number of PhytosanitaryPrograms
     * const count = await prisma.phytosanitaryProgram.count({
     *   where: {
     *     // ... the filter for the PhytosanitaryPrograms we want to count
     *   }
     * })
    **/
    count<T extends PhytosanitaryProgramCountArgs>(
      args?: Subset<T, PhytosanitaryProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhytosanitaryProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhytosanitaryProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhytosanitaryProgramAggregateArgs>(args: Subset<T, PhytosanitaryProgramAggregateArgs>): Prisma.PrismaPromise<GetPhytosanitaryProgramAggregateType<T>>

    /**
     * Group by PhytosanitaryProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhytosanitaryProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhytosanitaryProgramGroupByArgs['orderBy'] }
        : { orderBy?: PhytosanitaryProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhytosanitaryProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhytosanitaryProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhytosanitaryProgram model
   */
  readonly fields: PhytosanitaryProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhytosanitaryProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhytosanitaryProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productsCycle<T extends PhytosanitaryProgram$productsCycleArgs<ExtArgs> = {}>(args?: Subset<T, PhytosanitaryProgram$productsCycleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhytosanitaryCyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhytosanitaryProgram model
   */
  interface PhytosanitaryProgramFieldRefs {
    readonly id: FieldRef<"PhytosanitaryProgram", 'String'>
    readonly name: FieldRef<"PhytosanitaryProgram", 'String'>
    readonly monthlyFrequency: FieldRef<"PhytosanitaryProgram", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PhytosanitaryProgram findUnique
   */
  export type PhytosanitaryProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryProgram
     */
    select?: PhytosanitaryProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryProgram
     */
    omit?: PhytosanitaryProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryProgramInclude<ExtArgs> | null
    /**
     * Filter, which PhytosanitaryProgram to fetch.
     */
    where: PhytosanitaryProgramWhereUniqueInput
  }

  /**
   * PhytosanitaryProgram findUniqueOrThrow
   */
  export type PhytosanitaryProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryProgram
     */
    select?: PhytosanitaryProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryProgram
     */
    omit?: PhytosanitaryProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryProgramInclude<ExtArgs> | null
    /**
     * Filter, which PhytosanitaryProgram to fetch.
     */
    where: PhytosanitaryProgramWhereUniqueInput
  }

  /**
   * PhytosanitaryProgram findFirst
   */
  export type PhytosanitaryProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryProgram
     */
    select?: PhytosanitaryProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryProgram
     */
    omit?: PhytosanitaryProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryProgramInclude<ExtArgs> | null
    /**
     * Filter, which PhytosanitaryProgram to fetch.
     */
    where?: PhytosanitaryProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhytosanitaryPrograms to fetch.
     */
    orderBy?: PhytosanitaryProgramOrderByWithRelationInput | PhytosanitaryProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhytosanitaryPrograms.
     */
    cursor?: PhytosanitaryProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhytosanitaryPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhytosanitaryPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhytosanitaryPrograms.
     */
    distinct?: PhytosanitaryProgramScalarFieldEnum | PhytosanitaryProgramScalarFieldEnum[]
  }

  /**
   * PhytosanitaryProgram findFirstOrThrow
   */
  export type PhytosanitaryProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryProgram
     */
    select?: PhytosanitaryProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryProgram
     */
    omit?: PhytosanitaryProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryProgramInclude<ExtArgs> | null
    /**
     * Filter, which PhytosanitaryProgram to fetch.
     */
    where?: PhytosanitaryProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhytosanitaryPrograms to fetch.
     */
    orderBy?: PhytosanitaryProgramOrderByWithRelationInput | PhytosanitaryProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhytosanitaryPrograms.
     */
    cursor?: PhytosanitaryProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhytosanitaryPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhytosanitaryPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhytosanitaryPrograms.
     */
    distinct?: PhytosanitaryProgramScalarFieldEnum | PhytosanitaryProgramScalarFieldEnum[]
  }

  /**
   * PhytosanitaryProgram findMany
   */
  export type PhytosanitaryProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryProgram
     */
    select?: PhytosanitaryProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryProgram
     */
    omit?: PhytosanitaryProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryProgramInclude<ExtArgs> | null
    /**
     * Filter, which PhytosanitaryPrograms to fetch.
     */
    where?: PhytosanitaryProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhytosanitaryPrograms to fetch.
     */
    orderBy?: PhytosanitaryProgramOrderByWithRelationInput | PhytosanitaryProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhytosanitaryPrograms.
     */
    cursor?: PhytosanitaryProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhytosanitaryPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhytosanitaryPrograms.
     */
    skip?: number
    distinct?: PhytosanitaryProgramScalarFieldEnum | PhytosanitaryProgramScalarFieldEnum[]
  }

  /**
   * PhytosanitaryProgram create
   */
  export type PhytosanitaryProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryProgram
     */
    select?: PhytosanitaryProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryProgram
     */
    omit?: PhytosanitaryProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a PhytosanitaryProgram.
     */
    data: XOR<PhytosanitaryProgramCreateInput, PhytosanitaryProgramUncheckedCreateInput>
  }

  /**
   * PhytosanitaryProgram createMany
   */
  export type PhytosanitaryProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhytosanitaryPrograms.
     */
    data: PhytosanitaryProgramCreateManyInput | PhytosanitaryProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhytosanitaryProgram createManyAndReturn
   */
  export type PhytosanitaryProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryProgram
     */
    select?: PhytosanitaryProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryProgram
     */
    omit?: PhytosanitaryProgramOmit<ExtArgs> | null
    /**
     * The data used to create many PhytosanitaryPrograms.
     */
    data: PhytosanitaryProgramCreateManyInput | PhytosanitaryProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhytosanitaryProgram update
   */
  export type PhytosanitaryProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryProgram
     */
    select?: PhytosanitaryProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryProgram
     */
    omit?: PhytosanitaryProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a PhytosanitaryProgram.
     */
    data: XOR<PhytosanitaryProgramUpdateInput, PhytosanitaryProgramUncheckedUpdateInput>
    /**
     * Choose, which PhytosanitaryProgram to update.
     */
    where: PhytosanitaryProgramWhereUniqueInput
  }

  /**
   * PhytosanitaryProgram updateMany
   */
  export type PhytosanitaryProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhytosanitaryPrograms.
     */
    data: XOR<PhytosanitaryProgramUpdateManyMutationInput, PhytosanitaryProgramUncheckedUpdateManyInput>
    /**
     * Filter which PhytosanitaryPrograms to update
     */
    where?: PhytosanitaryProgramWhereInput
    /**
     * Limit how many PhytosanitaryPrograms to update.
     */
    limit?: number
  }

  /**
   * PhytosanitaryProgram updateManyAndReturn
   */
  export type PhytosanitaryProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryProgram
     */
    select?: PhytosanitaryProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryProgram
     */
    omit?: PhytosanitaryProgramOmit<ExtArgs> | null
    /**
     * The data used to update PhytosanitaryPrograms.
     */
    data: XOR<PhytosanitaryProgramUpdateManyMutationInput, PhytosanitaryProgramUncheckedUpdateManyInput>
    /**
     * Filter which PhytosanitaryPrograms to update
     */
    where?: PhytosanitaryProgramWhereInput
    /**
     * Limit how many PhytosanitaryPrograms to update.
     */
    limit?: number
  }

  /**
   * PhytosanitaryProgram upsert
   */
  export type PhytosanitaryProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryProgram
     */
    select?: PhytosanitaryProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryProgram
     */
    omit?: PhytosanitaryProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the PhytosanitaryProgram to update in case it exists.
     */
    where: PhytosanitaryProgramWhereUniqueInput
    /**
     * In case the PhytosanitaryProgram found by the `where` argument doesn't exist, create a new PhytosanitaryProgram with this data.
     */
    create: XOR<PhytosanitaryProgramCreateInput, PhytosanitaryProgramUncheckedCreateInput>
    /**
     * In case the PhytosanitaryProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhytosanitaryProgramUpdateInput, PhytosanitaryProgramUncheckedUpdateInput>
  }

  /**
   * PhytosanitaryProgram delete
   */
  export type PhytosanitaryProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryProgram
     */
    select?: PhytosanitaryProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryProgram
     */
    omit?: PhytosanitaryProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryProgramInclude<ExtArgs> | null
    /**
     * Filter which PhytosanitaryProgram to delete.
     */
    where: PhytosanitaryProgramWhereUniqueInput
  }

  /**
   * PhytosanitaryProgram deleteMany
   */
  export type PhytosanitaryProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhytosanitaryPrograms to delete
     */
    where?: PhytosanitaryProgramWhereInput
    /**
     * Limit how many PhytosanitaryPrograms to delete.
     */
    limit?: number
  }

  /**
   * PhytosanitaryProgram.productsCycle
   */
  export type PhytosanitaryProgram$productsCycleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycle
     */
    select?: PhytosanitaryCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryCycle
     */
    omit?: PhytosanitaryCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryCycleInclude<ExtArgs> | null
    where?: PhytosanitaryCycleWhereInput
    orderBy?: PhytosanitaryCycleOrderByWithRelationInput | PhytosanitaryCycleOrderByWithRelationInput[]
    cursor?: PhytosanitaryCycleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhytosanitaryCycleScalarFieldEnum | PhytosanitaryCycleScalarFieldEnum[]
  }

  /**
   * PhytosanitaryProgram without action
   */
  export type PhytosanitaryProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryProgram
     */
    select?: PhytosanitaryProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryProgram
     */
    omit?: PhytosanitaryProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryProgramInclude<ExtArgs> | null
  }


  /**
   * Model PhytosanitaryCycle
   */

  export type AggregatePhytosanitaryCycle = {
    _count: PhytosanitaryCycleCountAggregateOutputType | null
    _avg: PhytosanitaryCycleAvgAggregateOutputType | null
    _sum: PhytosanitaryCycleSumAggregateOutputType | null
    _min: PhytosanitaryCycleMinAggregateOutputType | null
    _max: PhytosanitaryCycleMaxAggregateOutputType | null
  }

  export type PhytosanitaryCycleAvgAggregateOutputType = {
    sequence: number | null
  }

  export type PhytosanitaryCycleSumAggregateOutputType = {
    sequence: number | null
  }

  export type PhytosanitaryCycleMinAggregateOutputType = {
    id: string | null
    sequence: number | null
    agrochemicalId: string | null
    programId: string | null
  }

  export type PhytosanitaryCycleMaxAggregateOutputType = {
    id: string | null
    sequence: number | null
    agrochemicalId: string | null
    programId: string | null
  }

  export type PhytosanitaryCycleCountAggregateOutputType = {
    id: number
    sequence: number
    agrochemicalId: number
    programId: number
    _all: number
  }


  export type PhytosanitaryCycleAvgAggregateInputType = {
    sequence?: true
  }

  export type PhytosanitaryCycleSumAggregateInputType = {
    sequence?: true
  }

  export type PhytosanitaryCycleMinAggregateInputType = {
    id?: true
    sequence?: true
    agrochemicalId?: true
    programId?: true
  }

  export type PhytosanitaryCycleMaxAggregateInputType = {
    id?: true
    sequence?: true
    agrochemicalId?: true
    programId?: true
  }

  export type PhytosanitaryCycleCountAggregateInputType = {
    id?: true
    sequence?: true
    agrochemicalId?: true
    programId?: true
    _all?: true
  }

  export type PhytosanitaryCycleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhytosanitaryCycle to aggregate.
     */
    where?: PhytosanitaryCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhytosanitaryCycles to fetch.
     */
    orderBy?: PhytosanitaryCycleOrderByWithRelationInput | PhytosanitaryCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhytosanitaryCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhytosanitaryCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhytosanitaryCycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhytosanitaryCycles
    **/
    _count?: true | PhytosanitaryCycleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhytosanitaryCycleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhytosanitaryCycleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhytosanitaryCycleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhytosanitaryCycleMaxAggregateInputType
  }

  export type GetPhytosanitaryCycleAggregateType<T extends PhytosanitaryCycleAggregateArgs> = {
        [P in keyof T & keyof AggregatePhytosanitaryCycle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhytosanitaryCycle[P]>
      : GetScalarType<T[P], AggregatePhytosanitaryCycle[P]>
  }




  export type PhytosanitaryCycleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhytosanitaryCycleWhereInput
    orderBy?: PhytosanitaryCycleOrderByWithAggregationInput | PhytosanitaryCycleOrderByWithAggregationInput[]
    by: PhytosanitaryCycleScalarFieldEnum[] | PhytosanitaryCycleScalarFieldEnum
    having?: PhytosanitaryCycleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhytosanitaryCycleCountAggregateInputType | true
    _avg?: PhytosanitaryCycleAvgAggregateInputType
    _sum?: PhytosanitaryCycleSumAggregateInputType
    _min?: PhytosanitaryCycleMinAggregateInputType
    _max?: PhytosanitaryCycleMaxAggregateInputType
  }

  export type PhytosanitaryCycleGroupByOutputType = {
    id: string
    sequence: number
    agrochemicalId: string
    programId: string
    _count: PhytosanitaryCycleCountAggregateOutputType | null
    _avg: PhytosanitaryCycleAvgAggregateOutputType | null
    _sum: PhytosanitaryCycleSumAggregateOutputType | null
    _min: PhytosanitaryCycleMinAggregateOutputType | null
    _max: PhytosanitaryCycleMaxAggregateOutputType | null
  }

  type GetPhytosanitaryCycleGroupByPayload<T extends PhytosanitaryCycleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhytosanitaryCycleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhytosanitaryCycleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhytosanitaryCycleGroupByOutputType[P]>
            : GetScalarType<T[P], PhytosanitaryCycleGroupByOutputType[P]>
        }
      >
    >


  export type PhytosanitaryCycleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sequence?: boolean
    agrochemicalId?: boolean
    programId?: boolean
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    program?: boolean | PhytosanitaryProgramDefaultArgs<ExtArgs>
    tasks?: boolean | PhytosanitaryCycle$tasksArgs<ExtArgs>
    _count?: boolean | PhytosanitaryCycleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phytosanitaryCycle"]>

  export type PhytosanitaryCycleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sequence?: boolean
    agrochemicalId?: boolean
    programId?: boolean
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    program?: boolean | PhytosanitaryProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phytosanitaryCycle"]>

  export type PhytosanitaryCycleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sequence?: boolean
    agrochemicalId?: boolean
    programId?: boolean
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    program?: boolean | PhytosanitaryProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phytosanitaryCycle"]>

  export type PhytosanitaryCycleSelectScalar = {
    id?: boolean
    sequence?: boolean
    agrochemicalId?: boolean
    programId?: boolean
  }

  export type PhytosanitaryCycleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sequence" | "agrochemicalId" | "programId", ExtArgs["result"]["phytosanitaryCycle"]>
  export type PhytosanitaryCycleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    program?: boolean | PhytosanitaryProgramDefaultArgs<ExtArgs>
    tasks?: boolean | PhytosanitaryCycle$tasksArgs<ExtArgs>
    _count?: boolean | PhytosanitaryCycleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PhytosanitaryCycleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    program?: boolean | PhytosanitaryProgramDefaultArgs<ExtArgs>
  }
  export type PhytosanitaryCycleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    program?: boolean | PhytosanitaryProgramDefaultArgs<ExtArgs>
  }

  export type $PhytosanitaryCyclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhytosanitaryCycle"
    objects: {
      agrochemical: Prisma.$AgrochemicalPayload<ExtArgs>
      program: Prisma.$PhytosanitaryProgramPayload<ExtArgs>
      tasks: Prisma.$PhytosanitaryTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sequence: number
      agrochemicalId: string
      programId: string
    }, ExtArgs["result"]["phytosanitaryCycle"]>
    composites: {}
  }

  type PhytosanitaryCycleGetPayload<S extends boolean | null | undefined | PhytosanitaryCycleDefaultArgs> = $Result.GetResult<Prisma.$PhytosanitaryCyclePayload, S>

  type PhytosanitaryCycleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhytosanitaryCycleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhytosanitaryCycleCountAggregateInputType | true
    }

  export interface PhytosanitaryCycleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhytosanitaryCycle'], meta: { name: 'PhytosanitaryCycle' } }
    /**
     * Find zero or one PhytosanitaryCycle that matches the filter.
     * @param {PhytosanitaryCycleFindUniqueArgs} args - Arguments to find a PhytosanitaryCycle
     * @example
     * // Get one PhytosanitaryCycle
     * const phytosanitaryCycle = await prisma.phytosanitaryCycle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhytosanitaryCycleFindUniqueArgs>(args: SelectSubset<T, PhytosanitaryCycleFindUniqueArgs<ExtArgs>>): Prisma__PhytosanitaryCycleClient<$Result.GetResult<Prisma.$PhytosanitaryCyclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PhytosanitaryCycle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhytosanitaryCycleFindUniqueOrThrowArgs} args - Arguments to find a PhytosanitaryCycle
     * @example
     * // Get one PhytosanitaryCycle
     * const phytosanitaryCycle = await prisma.phytosanitaryCycle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhytosanitaryCycleFindUniqueOrThrowArgs>(args: SelectSubset<T, PhytosanitaryCycleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhytosanitaryCycleClient<$Result.GetResult<Prisma.$PhytosanitaryCyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhytosanitaryCycle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryCycleFindFirstArgs} args - Arguments to find a PhytosanitaryCycle
     * @example
     * // Get one PhytosanitaryCycle
     * const phytosanitaryCycle = await prisma.phytosanitaryCycle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhytosanitaryCycleFindFirstArgs>(args?: SelectSubset<T, PhytosanitaryCycleFindFirstArgs<ExtArgs>>): Prisma__PhytosanitaryCycleClient<$Result.GetResult<Prisma.$PhytosanitaryCyclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhytosanitaryCycle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryCycleFindFirstOrThrowArgs} args - Arguments to find a PhytosanitaryCycle
     * @example
     * // Get one PhytosanitaryCycle
     * const phytosanitaryCycle = await prisma.phytosanitaryCycle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhytosanitaryCycleFindFirstOrThrowArgs>(args?: SelectSubset<T, PhytosanitaryCycleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhytosanitaryCycleClient<$Result.GetResult<Prisma.$PhytosanitaryCyclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PhytosanitaryCycles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryCycleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhytosanitaryCycles
     * const phytosanitaryCycles = await prisma.phytosanitaryCycle.findMany()
     * 
     * // Get first 10 PhytosanitaryCycles
     * const phytosanitaryCycles = await prisma.phytosanitaryCycle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phytosanitaryCycleWithIdOnly = await prisma.phytosanitaryCycle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhytosanitaryCycleFindManyArgs>(args?: SelectSubset<T, PhytosanitaryCycleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhytosanitaryCyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PhytosanitaryCycle.
     * @param {PhytosanitaryCycleCreateArgs} args - Arguments to create a PhytosanitaryCycle.
     * @example
     * // Create one PhytosanitaryCycle
     * const PhytosanitaryCycle = await prisma.phytosanitaryCycle.create({
     *   data: {
     *     // ... data to create a PhytosanitaryCycle
     *   }
     * })
     * 
     */
    create<T extends PhytosanitaryCycleCreateArgs>(args: SelectSubset<T, PhytosanitaryCycleCreateArgs<ExtArgs>>): Prisma__PhytosanitaryCycleClient<$Result.GetResult<Prisma.$PhytosanitaryCyclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PhytosanitaryCycles.
     * @param {PhytosanitaryCycleCreateManyArgs} args - Arguments to create many PhytosanitaryCycles.
     * @example
     * // Create many PhytosanitaryCycles
     * const phytosanitaryCycle = await prisma.phytosanitaryCycle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhytosanitaryCycleCreateManyArgs>(args?: SelectSubset<T, PhytosanitaryCycleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PhytosanitaryCycles and returns the data saved in the database.
     * @param {PhytosanitaryCycleCreateManyAndReturnArgs} args - Arguments to create many PhytosanitaryCycles.
     * @example
     * // Create many PhytosanitaryCycles
     * const phytosanitaryCycle = await prisma.phytosanitaryCycle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PhytosanitaryCycles and only return the `id`
     * const phytosanitaryCycleWithIdOnly = await prisma.phytosanitaryCycle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhytosanitaryCycleCreateManyAndReturnArgs>(args?: SelectSubset<T, PhytosanitaryCycleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhytosanitaryCyclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PhytosanitaryCycle.
     * @param {PhytosanitaryCycleDeleteArgs} args - Arguments to delete one PhytosanitaryCycle.
     * @example
     * // Delete one PhytosanitaryCycle
     * const PhytosanitaryCycle = await prisma.phytosanitaryCycle.delete({
     *   where: {
     *     // ... filter to delete one PhytosanitaryCycle
     *   }
     * })
     * 
     */
    delete<T extends PhytosanitaryCycleDeleteArgs>(args: SelectSubset<T, PhytosanitaryCycleDeleteArgs<ExtArgs>>): Prisma__PhytosanitaryCycleClient<$Result.GetResult<Prisma.$PhytosanitaryCyclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PhytosanitaryCycle.
     * @param {PhytosanitaryCycleUpdateArgs} args - Arguments to update one PhytosanitaryCycle.
     * @example
     * // Update one PhytosanitaryCycle
     * const phytosanitaryCycle = await prisma.phytosanitaryCycle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhytosanitaryCycleUpdateArgs>(args: SelectSubset<T, PhytosanitaryCycleUpdateArgs<ExtArgs>>): Prisma__PhytosanitaryCycleClient<$Result.GetResult<Prisma.$PhytosanitaryCyclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PhytosanitaryCycles.
     * @param {PhytosanitaryCycleDeleteManyArgs} args - Arguments to filter PhytosanitaryCycles to delete.
     * @example
     * // Delete a few PhytosanitaryCycles
     * const { count } = await prisma.phytosanitaryCycle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhytosanitaryCycleDeleteManyArgs>(args?: SelectSubset<T, PhytosanitaryCycleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhytosanitaryCycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryCycleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhytosanitaryCycles
     * const phytosanitaryCycle = await prisma.phytosanitaryCycle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhytosanitaryCycleUpdateManyArgs>(args: SelectSubset<T, PhytosanitaryCycleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhytosanitaryCycles and returns the data updated in the database.
     * @param {PhytosanitaryCycleUpdateManyAndReturnArgs} args - Arguments to update many PhytosanitaryCycles.
     * @example
     * // Update many PhytosanitaryCycles
     * const phytosanitaryCycle = await prisma.phytosanitaryCycle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PhytosanitaryCycles and only return the `id`
     * const phytosanitaryCycleWithIdOnly = await prisma.phytosanitaryCycle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PhytosanitaryCycleUpdateManyAndReturnArgs>(args: SelectSubset<T, PhytosanitaryCycleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhytosanitaryCyclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PhytosanitaryCycle.
     * @param {PhytosanitaryCycleUpsertArgs} args - Arguments to update or create a PhytosanitaryCycle.
     * @example
     * // Update or create a PhytosanitaryCycle
     * const phytosanitaryCycle = await prisma.phytosanitaryCycle.upsert({
     *   create: {
     *     // ... data to create a PhytosanitaryCycle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhytosanitaryCycle we want to update
     *   }
     * })
     */
    upsert<T extends PhytosanitaryCycleUpsertArgs>(args: SelectSubset<T, PhytosanitaryCycleUpsertArgs<ExtArgs>>): Prisma__PhytosanitaryCycleClient<$Result.GetResult<Prisma.$PhytosanitaryCyclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PhytosanitaryCycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryCycleCountArgs} args - Arguments to filter PhytosanitaryCycles to count.
     * @example
     * // Count the number of PhytosanitaryCycles
     * const count = await prisma.phytosanitaryCycle.count({
     *   where: {
     *     // ... the filter for the PhytosanitaryCycles we want to count
     *   }
     * })
    **/
    count<T extends PhytosanitaryCycleCountArgs>(
      args?: Subset<T, PhytosanitaryCycleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhytosanitaryCycleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhytosanitaryCycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryCycleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhytosanitaryCycleAggregateArgs>(args: Subset<T, PhytosanitaryCycleAggregateArgs>): Prisma.PrismaPromise<GetPhytosanitaryCycleAggregateType<T>>

    /**
     * Group by PhytosanitaryCycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryCycleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhytosanitaryCycleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhytosanitaryCycleGroupByArgs['orderBy'] }
        : { orderBy?: PhytosanitaryCycleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhytosanitaryCycleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhytosanitaryCycleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhytosanitaryCycle model
   */
  readonly fields: PhytosanitaryCycleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhytosanitaryCycle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhytosanitaryCycleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agrochemical<T extends AgrochemicalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgrochemicalDefaultArgs<ExtArgs>>): Prisma__AgrochemicalClient<$Result.GetResult<Prisma.$AgrochemicalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    program<T extends PhytosanitaryProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PhytosanitaryProgramDefaultArgs<ExtArgs>>): Prisma__PhytosanitaryProgramClient<$Result.GetResult<Prisma.$PhytosanitaryProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends PhytosanitaryCycle$tasksArgs<ExtArgs> = {}>(args?: Subset<T, PhytosanitaryCycle$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhytosanitaryTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhytosanitaryCycle model
   */
  interface PhytosanitaryCycleFieldRefs {
    readonly id: FieldRef<"PhytosanitaryCycle", 'String'>
    readonly sequence: FieldRef<"PhytosanitaryCycle", 'Int'>
    readonly agrochemicalId: FieldRef<"PhytosanitaryCycle", 'String'>
    readonly programId: FieldRef<"PhytosanitaryCycle", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PhytosanitaryCycle findUnique
   */
  export type PhytosanitaryCycleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycle
     */
    select?: PhytosanitaryCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryCycle
     */
    omit?: PhytosanitaryCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryCycleInclude<ExtArgs> | null
    /**
     * Filter, which PhytosanitaryCycle to fetch.
     */
    where: PhytosanitaryCycleWhereUniqueInput
  }

  /**
   * PhytosanitaryCycle findUniqueOrThrow
   */
  export type PhytosanitaryCycleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycle
     */
    select?: PhytosanitaryCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryCycle
     */
    omit?: PhytosanitaryCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryCycleInclude<ExtArgs> | null
    /**
     * Filter, which PhytosanitaryCycle to fetch.
     */
    where: PhytosanitaryCycleWhereUniqueInput
  }

  /**
   * PhytosanitaryCycle findFirst
   */
  export type PhytosanitaryCycleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycle
     */
    select?: PhytosanitaryCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryCycle
     */
    omit?: PhytosanitaryCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryCycleInclude<ExtArgs> | null
    /**
     * Filter, which PhytosanitaryCycle to fetch.
     */
    where?: PhytosanitaryCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhytosanitaryCycles to fetch.
     */
    orderBy?: PhytosanitaryCycleOrderByWithRelationInput | PhytosanitaryCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhytosanitaryCycles.
     */
    cursor?: PhytosanitaryCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhytosanitaryCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhytosanitaryCycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhytosanitaryCycles.
     */
    distinct?: PhytosanitaryCycleScalarFieldEnum | PhytosanitaryCycleScalarFieldEnum[]
  }

  /**
   * PhytosanitaryCycle findFirstOrThrow
   */
  export type PhytosanitaryCycleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycle
     */
    select?: PhytosanitaryCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryCycle
     */
    omit?: PhytosanitaryCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryCycleInclude<ExtArgs> | null
    /**
     * Filter, which PhytosanitaryCycle to fetch.
     */
    where?: PhytosanitaryCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhytosanitaryCycles to fetch.
     */
    orderBy?: PhytosanitaryCycleOrderByWithRelationInput | PhytosanitaryCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhytosanitaryCycles.
     */
    cursor?: PhytosanitaryCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhytosanitaryCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhytosanitaryCycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhytosanitaryCycles.
     */
    distinct?: PhytosanitaryCycleScalarFieldEnum | PhytosanitaryCycleScalarFieldEnum[]
  }

  /**
   * PhytosanitaryCycle findMany
   */
  export type PhytosanitaryCycleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycle
     */
    select?: PhytosanitaryCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryCycle
     */
    omit?: PhytosanitaryCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryCycleInclude<ExtArgs> | null
    /**
     * Filter, which PhytosanitaryCycles to fetch.
     */
    where?: PhytosanitaryCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhytosanitaryCycles to fetch.
     */
    orderBy?: PhytosanitaryCycleOrderByWithRelationInput | PhytosanitaryCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhytosanitaryCycles.
     */
    cursor?: PhytosanitaryCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhytosanitaryCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhytosanitaryCycles.
     */
    skip?: number
    distinct?: PhytosanitaryCycleScalarFieldEnum | PhytosanitaryCycleScalarFieldEnum[]
  }

  /**
   * PhytosanitaryCycle create
   */
  export type PhytosanitaryCycleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycle
     */
    select?: PhytosanitaryCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryCycle
     */
    omit?: PhytosanitaryCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryCycleInclude<ExtArgs> | null
    /**
     * The data needed to create a PhytosanitaryCycle.
     */
    data: XOR<PhytosanitaryCycleCreateInput, PhytosanitaryCycleUncheckedCreateInput>
  }

  /**
   * PhytosanitaryCycle createMany
   */
  export type PhytosanitaryCycleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhytosanitaryCycles.
     */
    data: PhytosanitaryCycleCreateManyInput | PhytosanitaryCycleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhytosanitaryCycle createManyAndReturn
   */
  export type PhytosanitaryCycleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycle
     */
    select?: PhytosanitaryCycleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryCycle
     */
    omit?: PhytosanitaryCycleOmit<ExtArgs> | null
    /**
     * The data used to create many PhytosanitaryCycles.
     */
    data: PhytosanitaryCycleCreateManyInput | PhytosanitaryCycleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryCycleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhytosanitaryCycle update
   */
  export type PhytosanitaryCycleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycle
     */
    select?: PhytosanitaryCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryCycle
     */
    omit?: PhytosanitaryCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryCycleInclude<ExtArgs> | null
    /**
     * The data needed to update a PhytosanitaryCycle.
     */
    data: XOR<PhytosanitaryCycleUpdateInput, PhytosanitaryCycleUncheckedUpdateInput>
    /**
     * Choose, which PhytosanitaryCycle to update.
     */
    where: PhytosanitaryCycleWhereUniqueInput
  }

  /**
   * PhytosanitaryCycle updateMany
   */
  export type PhytosanitaryCycleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhytosanitaryCycles.
     */
    data: XOR<PhytosanitaryCycleUpdateManyMutationInput, PhytosanitaryCycleUncheckedUpdateManyInput>
    /**
     * Filter which PhytosanitaryCycles to update
     */
    where?: PhytosanitaryCycleWhereInput
    /**
     * Limit how many PhytosanitaryCycles to update.
     */
    limit?: number
  }

  /**
   * PhytosanitaryCycle updateManyAndReturn
   */
  export type PhytosanitaryCycleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycle
     */
    select?: PhytosanitaryCycleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryCycle
     */
    omit?: PhytosanitaryCycleOmit<ExtArgs> | null
    /**
     * The data used to update PhytosanitaryCycles.
     */
    data: XOR<PhytosanitaryCycleUpdateManyMutationInput, PhytosanitaryCycleUncheckedUpdateManyInput>
    /**
     * Filter which PhytosanitaryCycles to update
     */
    where?: PhytosanitaryCycleWhereInput
    /**
     * Limit how many PhytosanitaryCycles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryCycleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhytosanitaryCycle upsert
   */
  export type PhytosanitaryCycleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycle
     */
    select?: PhytosanitaryCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryCycle
     */
    omit?: PhytosanitaryCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryCycleInclude<ExtArgs> | null
    /**
     * The filter to search for the PhytosanitaryCycle to update in case it exists.
     */
    where: PhytosanitaryCycleWhereUniqueInput
    /**
     * In case the PhytosanitaryCycle found by the `where` argument doesn't exist, create a new PhytosanitaryCycle with this data.
     */
    create: XOR<PhytosanitaryCycleCreateInput, PhytosanitaryCycleUncheckedCreateInput>
    /**
     * In case the PhytosanitaryCycle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhytosanitaryCycleUpdateInput, PhytosanitaryCycleUncheckedUpdateInput>
  }

  /**
   * PhytosanitaryCycle delete
   */
  export type PhytosanitaryCycleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycle
     */
    select?: PhytosanitaryCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryCycle
     */
    omit?: PhytosanitaryCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryCycleInclude<ExtArgs> | null
    /**
     * Filter which PhytosanitaryCycle to delete.
     */
    where: PhytosanitaryCycleWhereUniqueInput
  }

  /**
   * PhytosanitaryCycle deleteMany
   */
  export type PhytosanitaryCycleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhytosanitaryCycles to delete
     */
    where?: PhytosanitaryCycleWhereInput
    /**
     * Limit how many PhytosanitaryCycles to delete.
     */
    limit?: number
  }

  /**
   * PhytosanitaryCycle.tasks
   */
  export type PhytosanitaryCycle$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryTask
     */
    select?: PhytosanitaryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryTask
     */
    omit?: PhytosanitaryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryTaskInclude<ExtArgs> | null
    where?: PhytosanitaryTaskWhereInput
    orderBy?: PhytosanitaryTaskOrderByWithRelationInput | PhytosanitaryTaskOrderByWithRelationInput[]
    cursor?: PhytosanitaryTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhytosanitaryTaskScalarFieldEnum | PhytosanitaryTaskScalarFieldEnum[]
  }

  /**
   * PhytosanitaryCycle without action
   */
  export type PhytosanitaryCycleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycle
     */
    select?: PhytosanitaryCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryCycle
     */
    omit?: PhytosanitaryCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryCycleInclude<ExtArgs> | null
  }


  /**
   * Model PhytosanitaryTask
   */

  export type AggregatePhytosanitaryTask = {
    _count: PhytosanitaryTaskCountAggregateOutputType | null
    _min: PhytosanitaryTaskMinAggregateOutputType | null
    _max: PhytosanitaryTaskMaxAggregateOutputType | null
  }

  export type PhytosanitaryTaskMinAggregateOutputType = {
    id: string | null
    scheduledDate: Date | null
    executionDate: Date | null
    note: string | null
    status: $Enums.TaskStatus | null
    agrochemicalId: string | null
    productsCycleId: string | null
  }

  export type PhytosanitaryTaskMaxAggregateOutputType = {
    id: string | null
    scheduledDate: Date | null
    executionDate: Date | null
    note: string | null
    status: $Enums.TaskStatus | null
    agrochemicalId: string | null
    productsCycleId: string | null
  }

  export type PhytosanitaryTaskCountAggregateOutputType = {
    id: number
    scheduledDate: number
    executionDate: number
    zones: number
    note: number
    status: number
    agrochemicalId: number
    productsCycleId: number
    _all: number
  }


  export type PhytosanitaryTaskMinAggregateInputType = {
    id?: true
    scheduledDate?: true
    executionDate?: true
    note?: true
    status?: true
    agrochemicalId?: true
    productsCycleId?: true
  }

  export type PhytosanitaryTaskMaxAggregateInputType = {
    id?: true
    scheduledDate?: true
    executionDate?: true
    note?: true
    status?: true
    agrochemicalId?: true
    productsCycleId?: true
  }

  export type PhytosanitaryTaskCountAggregateInputType = {
    id?: true
    scheduledDate?: true
    executionDate?: true
    zones?: true
    note?: true
    status?: true
    agrochemicalId?: true
    productsCycleId?: true
    _all?: true
  }

  export type PhytosanitaryTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhytosanitaryTask to aggregate.
     */
    where?: PhytosanitaryTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhytosanitaryTasks to fetch.
     */
    orderBy?: PhytosanitaryTaskOrderByWithRelationInput | PhytosanitaryTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhytosanitaryTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhytosanitaryTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhytosanitaryTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhytosanitaryTasks
    **/
    _count?: true | PhytosanitaryTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhytosanitaryTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhytosanitaryTaskMaxAggregateInputType
  }

  export type GetPhytosanitaryTaskAggregateType<T extends PhytosanitaryTaskAggregateArgs> = {
        [P in keyof T & keyof AggregatePhytosanitaryTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhytosanitaryTask[P]>
      : GetScalarType<T[P], AggregatePhytosanitaryTask[P]>
  }




  export type PhytosanitaryTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhytosanitaryTaskWhereInput
    orderBy?: PhytosanitaryTaskOrderByWithAggregationInput | PhytosanitaryTaskOrderByWithAggregationInput[]
    by: PhytosanitaryTaskScalarFieldEnum[] | PhytosanitaryTaskScalarFieldEnum
    having?: PhytosanitaryTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhytosanitaryTaskCountAggregateInputType | true
    _min?: PhytosanitaryTaskMinAggregateInputType
    _max?: PhytosanitaryTaskMaxAggregateInputType
  }

  export type PhytosanitaryTaskGroupByOutputType = {
    id: string
    scheduledDate: Date
    executionDate: Date | null
    zones: $Enums.ZoneType[]
    note: string | null
    status: $Enums.TaskStatus
    agrochemicalId: string
    productsCycleId: string | null
    _count: PhytosanitaryTaskCountAggregateOutputType | null
    _min: PhytosanitaryTaskMinAggregateOutputType | null
    _max: PhytosanitaryTaskMaxAggregateOutputType | null
  }

  type GetPhytosanitaryTaskGroupByPayload<T extends PhytosanitaryTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhytosanitaryTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhytosanitaryTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhytosanitaryTaskGroupByOutputType[P]>
            : GetScalarType<T[P], PhytosanitaryTaskGroupByOutputType[P]>
        }
      >
    >


  export type PhytosanitaryTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduledDate?: boolean
    executionDate?: boolean
    zones?: boolean
    note?: boolean
    status?: boolean
    agrochemicalId?: boolean
    productsCycleId?: boolean
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    productsCycle?: boolean | PhytosanitaryTask$productsCycleArgs<ExtArgs>
  }, ExtArgs["result"]["phytosanitaryTask"]>

  export type PhytosanitaryTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduledDate?: boolean
    executionDate?: boolean
    zones?: boolean
    note?: boolean
    status?: boolean
    agrochemicalId?: boolean
    productsCycleId?: boolean
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    productsCycle?: boolean | PhytosanitaryTask$productsCycleArgs<ExtArgs>
  }, ExtArgs["result"]["phytosanitaryTask"]>

  export type PhytosanitaryTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduledDate?: boolean
    executionDate?: boolean
    zones?: boolean
    note?: boolean
    status?: boolean
    agrochemicalId?: boolean
    productsCycleId?: boolean
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    productsCycle?: boolean | PhytosanitaryTask$productsCycleArgs<ExtArgs>
  }, ExtArgs["result"]["phytosanitaryTask"]>

  export type PhytosanitaryTaskSelectScalar = {
    id?: boolean
    scheduledDate?: boolean
    executionDate?: boolean
    zones?: boolean
    note?: boolean
    status?: boolean
    agrochemicalId?: boolean
    productsCycleId?: boolean
  }

  export type PhytosanitaryTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scheduledDate" | "executionDate" | "zones" | "note" | "status" | "agrochemicalId" | "productsCycleId", ExtArgs["result"]["phytosanitaryTask"]>
  export type PhytosanitaryTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    productsCycle?: boolean | PhytosanitaryTask$productsCycleArgs<ExtArgs>
  }
  export type PhytosanitaryTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    productsCycle?: boolean | PhytosanitaryTask$productsCycleArgs<ExtArgs>
  }
  export type PhytosanitaryTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agrochemical?: boolean | AgrochemicalDefaultArgs<ExtArgs>
    productsCycle?: boolean | PhytosanitaryTask$productsCycleArgs<ExtArgs>
  }

  export type $PhytosanitaryTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhytosanitaryTask"
    objects: {
      agrochemical: Prisma.$AgrochemicalPayload<ExtArgs>
      productsCycle: Prisma.$PhytosanitaryCyclePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scheduledDate: Date
      executionDate: Date | null
      zones: $Enums.ZoneType[]
      note: string | null
      status: $Enums.TaskStatus
      agrochemicalId: string
      productsCycleId: string | null
    }, ExtArgs["result"]["phytosanitaryTask"]>
    composites: {}
  }

  type PhytosanitaryTaskGetPayload<S extends boolean | null | undefined | PhytosanitaryTaskDefaultArgs> = $Result.GetResult<Prisma.$PhytosanitaryTaskPayload, S>

  type PhytosanitaryTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhytosanitaryTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhytosanitaryTaskCountAggregateInputType | true
    }

  export interface PhytosanitaryTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhytosanitaryTask'], meta: { name: 'PhytosanitaryTask' } }
    /**
     * Find zero or one PhytosanitaryTask that matches the filter.
     * @param {PhytosanitaryTaskFindUniqueArgs} args - Arguments to find a PhytosanitaryTask
     * @example
     * // Get one PhytosanitaryTask
     * const phytosanitaryTask = await prisma.phytosanitaryTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhytosanitaryTaskFindUniqueArgs>(args: SelectSubset<T, PhytosanitaryTaskFindUniqueArgs<ExtArgs>>): Prisma__PhytosanitaryTaskClient<$Result.GetResult<Prisma.$PhytosanitaryTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PhytosanitaryTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhytosanitaryTaskFindUniqueOrThrowArgs} args - Arguments to find a PhytosanitaryTask
     * @example
     * // Get one PhytosanitaryTask
     * const phytosanitaryTask = await prisma.phytosanitaryTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhytosanitaryTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, PhytosanitaryTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhytosanitaryTaskClient<$Result.GetResult<Prisma.$PhytosanitaryTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhytosanitaryTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryTaskFindFirstArgs} args - Arguments to find a PhytosanitaryTask
     * @example
     * // Get one PhytosanitaryTask
     * const phytosanitaryTask = await prisma.phytosanitaryTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhytosanitaryTaskFindFirstArgs>(args?: SelectSubset<T, PhytosanitaryTaskFindFirstArgs<ExtArgs>>): Prisma__PhytosanitaryTaskClient<$Result.GetResult<Prisma.$PhytosanitaryTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhytosanitaryTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryTaskFindFirstOrThrowArgs} args - Arguments to find a PhytosanitaryTask
     * @example
     * // Get one PhytosanitaryTask
     * const phytosanitaryTask = await prisma.phytosanitaryTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhytosanitaryTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, PhytosanitaryTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhytosanitaryTaskClient<$Result.GetResult<Prisma.$PhytosanitaryTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PhytosanitaryTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhytosanitaryTasks
     * const phytosanitaryTasks = await prisma.phytosanitaryTask.findMany()
     * 
     * // Get first 10 PhytosanitaryTasks
     * const phytosanitaryTasks = await prisma.phytosanitaryTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phytosanitaryTaskWithIdOnly = await prisma.phytosanitaryTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhytosanitaryTaskFindManyArgs>(args?: SelectSubset<T, PhytosanitaryTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhytosanitaryTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PhytosanitaryTask.
     * @param {PhytosanitaryTaskCreateArgs} args - Arguments to create a PhytosanitaryTask.
     * @example
     * // Create one PhytosanitaryTask
     * const PhytosanitaryTask = await prisma.phytosanitaryTask.create({
     *   data: {
     *     // ... data to create a PhytosanitaryTask
     *   }
     * })
     * 
     */
    create<T extends PhytosanitaryTaskCreateArgs>(args: SelectSubset<T, PhytosanitaryTaskCreateArgs<ExtArgs>>): Prisma__PhytosanitaryTaskClient<$Result.GetResult<Prisma.$PhytosanitaryTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PhytosanitaryTasks.
     * @param {PhytosanitaryTaskCreateManyArgs} args - Arguments to create many PhytosanitaryTasks.
     * @example
     * // Create many PhytosanitaryTasks
     * const phytosanitaryTask = await prisma.phytosanitaryTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhytosanitaryTaskCreateManyArgs>(args?: SelectSubset<T, PhytosanitaryTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PhytosanitaryTasks and returns the data saved in the database.
     * @param {PhytosanitaryTaskCreateManyAndReturnArgs} args - Arguments to create many PhytosanitaryTasks.
     * @example
     * // Create many PhytosanitaryTasks
     * const phytosanitaryTask = await prisma.phytosanitaryTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PhytosanitaryTasks and only return the `id`
     * const phytosanitaryTaskWithIdOnly = await prisma.phytosanitaryTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhytosanitaryTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, PhytosanitaryTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhytosanitaryTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PhytosanitaryTask.
     * @param {PhytosanitaryTaskDeleteArgs} args - Arguments to delete one PhytosanitaryTask.
     * @example
     * // Delete one PhytosanitaryTask
     * const PhytosanitaryTask = await prisma.phytosanitaryTask.delete({
     *   where: {
     *     // ... filter to delete one PhytosanitaryTask
     *   }
     * })
     * 
     */
    delete<T extends PhytosanitaryTaskDeleteArgs>(args: SelectSubset<T, PhytosanitaryTaskDeleteArgs<ExtArgs>>): Prisma__PhytosanitaryTaskClient<$Result.GetResult<Prisma.$PhytosanitaryTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PhytosanitaryTask.
     * @param {PhytosanitaryTaskUpdateArgs} args - Arguments to update one PhytosanitaryTask.
     * @example
     * // Update one PhytosanitaryTask
     * const phytosanitaryTask = await prisma.phytosanitaryTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhytosanitaryTaskUpdateArgs>(args: SelectSubset<T, PhytosanitaryTaskUpdateArgs<ExtArgs>>): Prisma__PhytosanitaryTaskClient<$Result.GetResult<Prisma.$PhytosanitaryTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PhytosanitaryTasks.
     * @param {PhytosanitaryTaskDeleteManyArgs} args - Arguments to filter PhytosanitaryTasks to delete.
     * @example
     * // Delete a few PhytosanitaryTasks
     * const { count } = await prisma.phytosanitaryTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhytosanitaryTaskDeleteManyArgs>(args?: SelectSubset<T, PhytosanitaryTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhytosanitaryTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhytosanitaryTasks
     * const phytosanitaryTask = await prisma.phytosanitaryTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhytosanitaryTaskUpdateManyArgs>(args: SelectSubset<T, PhytosanitaryTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhytosanitaryTasks and returns the data updated in the database.
     * @param {PhytosanitaryTaskUpdateManyAndReturnArgs} args - Arguments to update many PhytosanitaryTasks.
     * @example
     * // Update many PhytosanitaryTasks
     * const phytosanitaryTask = await prisma.phytosanitaryTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PhytosanitaryTasks and only return the `id`
     * const phytosanitaryTaskWithIdOnly = await prisma.phytosanitaryTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PhytosanitaryTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, PhytosanitaryTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhytosanitaryTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PhytosanitaryTask.
     * @param {PhytosanitaryTaskUpsertArgs} args - Arguments to update or create a PhytosanitaryTask.
     * @example
     * // Update or create a PhytosanitaryTask
     * const phytosanitaryTask = await prisma.phytosanitaryTask.upsert({
     *   create: {
     *     // ... data to create a PhytosanitaryTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhytosanitaryTask we want to update
     *   }
     * })
     */
    upsert<T extends PhytosanitaryTaskUpsertArgs>(args: SelectSubset<T, PhytosanitaryTaskUpsertArgs<ExtArgs>>): Prisma__PhytosanitaryTaskClient<$Result.GetResult<Prisma.$PhytosanitaryTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PhytosanitaryTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryTaskCountArgs} args - Arguments to filter PhytosanitaryTasks to count.
     * @example
     * // Count the number of PhytosanitaryTasks
     * const count = await prisma.phytosanitaryTask.count({
     *   where: {
     *     // ... the filter for the PhytosanitaryTasks we want to count
     *   }
     * })
    **/
    count<T extends PhytosanitaryTaskCountArgs>(
      args?: Subset<T, PhytosanitaryTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhytosanitaryTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhytosanitaryTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhytosanitaryTaskAggregateArgs>(args: Subset<T, PhytosanitaryTaskAggregateArgs>): Prisma.PrismaPromise<GetPhytosanitaryTaskAggregateType<T>>

    /**
     * Group by PhytosanitaryTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhytosanitaryTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhytosanitaryTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhytosanitaryTaskGroupByArgs['orderBy'] }
        : { orderBy?: PhytosanitaryTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhytosanitaryTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhytosanitaryTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhytosanitaryTask model
   */
  readonly fields: PhytosanitaryTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhytosanitaryTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhytosanitaryTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agrochemical<T extends AgrochemicalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgrochemicalDefaultArgs<ExtArgs>>): Prisma__AgrochemicalClient<$Result.GetResult<Prisma.$AgrochemicalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productsCycle<T extends PhytosanitaryTask$productsCycleArgs<ExtArgs> = {}>(args?: Subset<T, PhytosanitaryTask$productsCycleArgs<ExtArgs>>): Prisma__PhytosanitaryCycleClient<$Result.GetResult<Prisma.$PhytosanitaryCyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhytosanitaryTask model
   */
  interface PhytosanitaryTaskFieldRefs {
    readonly id: FieldRef<"PhytosanitaryTask", 'String'>
    readonly scheduledDate: FieldRef<"PhytosanitaryTask", 'DateTime'>
    readonly executionDate: FieldRef<"PhytosanitaryTask", 'DateTime'>
    readonly zones: FieldRef<"PhytosanitaryTask", 'ZoneType[]'>
    readonly note: FieldRef<"PhytosanitaryTask", 'String'>
    readonly status: FieldRef<"PhytosanitaryTask", 'TaskStatus'>
    readonly agrochemicalId: FieldRef<"PhytosanitaryTask", 'String'>
    readonly productsCycleId: FieldRef<"PhytosanitaryTask", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PhytosanitaryTask findUnique
   */
  export type PhytosanitaryTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryTask
     */
    select?: PhytosanitaryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryTask
     */
    omit?: PhytosanitaryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryTaskInclude<ExtArgs> | null
    /**
     * Filter, which PhytosanitaryTask to fetch.
     */
    where: PhytosanitaryTaskWhereUniqueInput
  }

  /**
   * PhytosanitaryTask findUniqueOrThrow
   */
  export type PhytosanitaryTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryTask
     */
    select?: PhytosanitaryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryTask
     */
    omit?: PhytosanitaryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryTaskInclude<ExtArgs> | null
    /**
     * Filter, which PhytosanitaryTask to fetch.
     */
    where: PhytosanitaryTaskWhereUniqueInput
  }

  /**
   * PhytosanitaryTask findFirst
   */
  export type PhytosanitaryTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryTask
     */
    select?: PhytosanitaryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryTask
     */
    omit?: PhytosanitaryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryTaskInclude<ExtArgs> | null
    /**
     * Filter, which PhytosanitaryTask to fetch.
     */
    where?: PhytosanitaryTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhytosanitaryTasks to fetch.
     */
    orderBy?: PhytosanitaryTaskOrderByWithRelationInput | PhytosanitaryTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhytosanitaryTasks.
     */
    cursor?: PhytosanitaryTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhytosanitaryTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhytosanitaryTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhytosanitaryTasks.
     */
    distinct?: PhytosanitaryTaskScalarFieldEnum | PhytosanitaryTaskScalarFieldEnum[]
  }

  /**
   * PhytosanitaryTask findFirstOrThrow
   */
  export type PhytosanitaryTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryTask
     */
    select?: PhytosanitaryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryTask
     */
    omit?: PhytosanitaryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryTaskInclude<ExtArgs> | null
    /**
     * Filter, which PhytosanitaryTask to fetch.
     */
    where?: PhytosanitaryTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhytosanitaryTasks to fetch.
     */
    orderBy?: PhytosanitaryTaskOrderByWithRelationInput | PhytosanitaryTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhytosanitaryTasks.
     */
    cursor?: PhytosanitaryTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhytosanitaryTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhytosanitaryTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhytosanitaryTasks.
     */
    distinct?: PhytosanitaryTaskScalarFieldEnum | PhytosanitaryTaskScalarFieldEnum[]
  }

  /**
   * PhytosanitaryTask findMany
   */
  export type PhytosanitaryTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryTask
     */
    select?: PhytosanitaryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryTask
     */
    omit?: PhytosanitaryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryTaskInclude<ExtArgs> | null
    /**
     * Filter, which PhytosanitaryTasks to fetch.
     */
    where?: PhytosanitaryTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhytosanitaryTasks to fetch.
     */
    orderBy?: PhytosanitaryTaskOrderByWithRelationInput | PhytosanitaryTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhytosanitaryTasks.
     */
    cursor?: PhytosanitaryTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhytosanitaryTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhytosanitaryTasks.
     */
    skip?: number
    distinct?: PhytosanitaryTaskScalarFieldEnum | PhytosanitaryTaskScalarFieldEnum[]
  }

  /**
   * PhytosanitaryTask create
   */
  export type PhytosanitaryTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryTask
     */
    select?: PhytosanitaryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryTask
     */
    omit?: PhytosanitaryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a PhytosanitaryTask.
     */
    data: XOR<PhytosanitaryTaskCreateInput, PhytosanitaryTaskUncheckedCreateInput>
  }

  /**
   * PhytosanitaryTask createMany
   */
  export type PhytosanitaryTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhytosanitaryTasks.
     */
    data: PhytosanitaryTaskCreateManyInput | PhytosanitaryTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhytosanitaryTask createManyAndReturn
   */
  export type PhytosanitaryTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryTask
     */
    select?: PhytosanitaryTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryTask
     */
    omit?: PhytosanitaryTaskOmit<ExtArgs> | null
    /**
     * The data used to create many PhytosanitaryTasks.
     */
    data: PhytosanitaryTaskCreateManyInput | PhytosanitaryTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhytosanitaryTask update
   */
  export type PhytosanitaryTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryTask
     */
    select?: PhytosanitaryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryTask
     */
    omit?: PhytosanitaryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a PhytosanitaryTask.
     */
    data: XOR<PhytosanitaryTaskUpdateInput, PhytosanitaryTaskUncheckedUpdateInput>
    /**
     * Choose, which PhytosanitaryTask to update.
     */
    where: PhytosanitaryTaskWhereUniqueInput
  }

  /**
   * PhytosanitaryTask updateMany
   */
  export type PhytosanitaryTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhytosanitaryTasks.
     */
    data: XOR<PhytosanitaryTaskUpdateManyMutationInput, PhytosanitaryTaskUncheckedUpdateManyInput>
    /**
     * Filter which PhytosanitaryTasks to update
     */
    where?: PhytosanitaryTaskWhereInput
    /**
     * Limit how many PhytosanitaryTasks to update.
     */
    limit?: number
  }

  /**
   * PhytosanitaryTask updateManyAndReturn
   */
  export type PhytosanitaryTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryTask
     */
    select?: PhytosanitaryTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryTask
     */
    omit?: PhytosanitaryTaskOmit<ExtArgs> | null
    /**
     * The data used to update PhytosanitaryTasks.
     */
    data: XOR<PhytosanitaryTaskUpdateManyMutationInput, PhytosanitaryTaskUncheckedUpdateManyInput>
    /**
     * Filter which PhytosanitaryTasks to update
     */
    where?: PhytosanitaryTaskWhereInput
    /**
     * Limit how many PhytosanitaryTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhytosanitaryTask upsert
   */
  export type PhytosanitaryTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryTask
     */
    select?: PhytosanitaryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryTask
     */
    omit?: PhytosanitaryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the PhytosanitaryTask to update in case it exists.
     */
    where: PhytosanitaryTaskWhereUniqueInput
    /**
     * In case the PhytosanitaryTask found by the `where` argument doesn't exist, create a new PhytosanitaryTask with this data.
     */
    create: XOR<PhytosanitaryTaskCreateInput, PhytosanitaryTaskUncheckedCreateInput>
    /**
     * In case the PhytosanitaryTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhytosanitaryTaskUpdateInput, PhytosanitaryTaskUncheckedUpdateInput>
  }

  /**
   * PhytosanitaryTask delete
   */
  export type PhytosanitaryTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryTask
     */
    select?: PhytosanitaryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryTask
     */
    omit?: PhytosanitaryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryTaskInclude<ExtArgs> | null
    /**
     * Filter which PhytosanitaryTask to delete.
     */
    where: PhytosanitaryTaskWhereUniqueInput
  }

  /**
   * PhytosanitaryTask deleteMany
   */
  export type PhytosanitaryTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhytosanitaryTasks to delete
     */
    where?: PhytosanitaryTaskWhereInput
    /**
     * Limit how many PhytosanitaryTasks to delete.
     */
    limit?: number
  }

  /**
   * PhytosanitaryTask.productsCycle
   */
  export type PhytosanitaryTask$productsCycleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryCycle
     */
    select?: PhytosanitaryCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryCycle
     */
    omit?: PhytosanitaryCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryCycleInclude<ExtArgs> | null
    where?: PhytosanitaryCycleWhereInput
  }

  /**
   * PhytosanitaryTask without action
   */
  export type PhytosanitaryTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhytosanitaryTask
     */
    select?: PhytosanitaryTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhytosanitaryTask
     */
    omit?: PhytosanitaryTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhytosanitaryTaskInclude<ExtArgs> | null
  }


  /**
   * Model IrrigationProgram
   */

  export type AggregateIrrigationProgram = {
    _count: IrrigationProgramCountAggregateOutputType | null
    _avg: IrrigationProgramAvgAggregateOutputType | null
    _sum: IrrigationProgramSumAggregateOutputType | null
    _min: IrrigationProgramMinAggregateOutputType | null
    _max: IrrigationProgramMaxAggregateOutputType | null
  }

  export type IrrigationProgramAvgAggregateOutputType = {
    duration: number | null
  }

  export type IrrigationProgramSumAggregateOutputType = {
    duration: number | null
  }

  export type IrrigationProgramMinAggregateOutputType = {
    id: string | null
    name: string | null
    trigger: $Enums.TriggerType | null
    actuator: $Enums.ActuatorType | null
    startTime: string | null
    duration: number | null
  }

  export type IrrigationProgramMaxAggregateOutputType = {
    id: string | null
    name: string | null
    trigger: $Enums.TriggerType | null
    actuator: $Enums.ActuatorType | null
    startTime: string | null
    duration: number | null
  }

  export type IrrigationProgramCountAggregateOutputType = {
    id: number
    name: number
    trigger: number
    actuator: number
    startTime: number
    duration: number
    zones: number
    _all: number
  }


  export type IrrigationProgramAvgAggregateInputType = {
    duration?: true
  }

  export type IrrigationProgramSumAggregateInputType = {
    duration?: true
  }

  export type IrrigationProgramMinAggregateInputType = {
    id?: true
    name?: true
    trigger?: true
    actuator?: true
    startTime?: true
    duration?: true
  }

  export type IrrigationProgramMaxAggregateInputType = {
    id?: true
    name?: true
    trigger?: true
    actuator?: true
    startTime?: true
    duration?: true
  }

  export type IrrigationProgramCountAggregateInputType = {
    id?: true
    name?: true
    trigger?: true
    actuator?: true
    startTime?: true
    duration?: true
    zones?: true
    _all?: true
  }

  export type IrrigationProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationProgram to aggregate.
     */
    where?: IrrigationProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationPrograms to fetch.
     */
    orderBy?: IrrigationProgramOrderByWithRelationInput | IrrigationProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IrrigationProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IrrigationPrograms
    **/
    _count?: true | IrrigationProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IrrigationProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IrrigationProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IrrigationProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IrrigationProgramMaxAggregateInputType
  }

  export type GetIrrigationProgramAggregateType<T extends IrrigationProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateIrrigationProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIrrigationProgram[P]>
      : GetScalarType<T[P], AggregateIrrigationProgram[P]>
  }




  export type IrrigationProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationProgramWhereInput
    orderBy?: IrrigationProgramOrderByWithAggregationInput | IrrigationProgramOrderByWithAggregationInput[]
    by: IrrigationProgramScalarFieldEnum[] | IrrigationProgramScalarFieldEnum
    having?: IrrigationProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IrrigationProgramCountAggregateInputType | true
    _avg?: IrrigationProgramAvgAggregateInputType
    _sum?: IrrigationProgramSumAggregateInputType
    _min?: IrrigationProgramMinAggregateInputType
    _max?: IrrigationProgramMaxAggregateInputType
  }

  export type IrrigationProgramGroupByOutputType = {
    id: string
    name: string
    trigger: $Enums.TriggerType
    actuator: $Enums.ActuatorType
    startTime: string
    duration: number
    zones: $Enums.ZoneType[]
    _count: IrrigationProgramCountAggregateOutputType | null
    _avg: IrrigationProgramAvgAggregateOutputType | null
    _sum: IrrigationProgramSumAggregateOutputType | null
    _min: IrrigationProgramMinAggregateOutputType | null
    _max: IrrigationProgramMaxAggregateOutputType | null
  }

  type GetIrrigationProgramGroupByPayload<T extends IrrigationProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IrrigationProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IrrigationProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IrrigationProgramGroupByOutputType[P]>
            : GetScalarType<T[P], IrrigationProgramGroupByOutputType[P]>
        }
      >
    >


  export type IrrigationProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    trigger?: boolean
    actuator?: boolean
    startTime?: boolean
    duration?: boolean
    zones?: boolean
    tasks?: boolean | IrrigationProgram$tasksArgs<ExtArgs>
    _count?: boolean | IrrigationProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["irrigationProgram"]>

  export type IrrigationProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    trigger?: boolean
    actuator?: boolean
    startTime?: boolean
    duration?: boolean
    zones?: boolean
  }, ExtArgs["result"]["irrigationProgram"]>

  export type IrrigationProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    trigger?: boolean
    actuator?: boolean
    startTime?: boolean
    duration?: boolean
    zones?: boolean
  }, ExtArgs["result"]["irrigationProgram"]>

  export type IrrigationProgramSelectScalar = {
    id?: boolean
    name?: boolean
    trigger?: boolean
    actuator?: boolean
    startTime?: boolean
    duration?: boolean
    zones?: boolean
  }

  export type IrrigationProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "trigger" | "actuator" | "startTime" | "duration" | "zones", ExtArgs["result"]["irrigationProgram"]>
  export type IrrigationProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | IrrigationProgram$tasksArgs<ExtArgs>
    _count?: boolean | IrrigationProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IrrigationProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type IrrigationProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IrrigationProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IrrigationProgram"
    objects: {
      tasks: Prisma.$IrrigationTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      trigger: $Enums.TriggerType
      actuator: $Enums.ActuatorType
      startTime: string
      duration: number
      zones: $Enums.ZoneType[]
    }, ExtArgs["result"]["irrigationProgram"]>
    composites: {}
  }

  type IrrigationProgramGetPayload<S extends boolean | null | undefined | IrrigationProgramDefaultArgs> = $Result.GetResult<Prisma.$IrrigationProgramPayload, S>

  type IrrigationProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IrrigationProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IrrigationProgramCountAggregateInputType | true
    }

  export interface IrrigationProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IrrigationProgram'], meta: { name: 'IrrigationProgram' } }
    /**
     * Find zero or one IrrigationProgram that matches the filter.
     * @param {IrrigationProgramFindUniqueArgs} args - Arguments to find a IrrigationProgram
     * @example
     * // Get one IrrigationProgram
     * const irrigationProgram = await prisma.irrigationProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IrrigationProgramFindUniqueArgs>(args: SelectSubset<T, IrrigationProgramFindUniqueArgs<ExtArgs>>): Prisma__IrrigationProgramClient<$Result.GetResult<Prisma.$IrrigationProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IrrigationProgram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IrrigationProgramFindUniqueOrThrowArgs} args - Arguments to find a IrrigationProgram
     * @example
     * // Get one IrrigationProgram
     * const irrigationProgram = await prisma.irrigationProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IrrigationProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, IrrigationProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IrrigationProgramClient<$Result.GetResult<Prisma.$IrrigationProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationProgramFindFirstArgs} args - Arguments to find a IrrigationProgram
     * @example
     * // Get one IrrigationProgram
     * const irrigationProgram = await prisma.irrigationProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IrrigationProgramFindFirstArgs>(args?: SelectSubset<T, IrrigationProgramFindFirstArgs<ExtArgs>>): Prisma__IrrigationProgramClient<$Result.GetResult<Prisma.$IrrigationProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationProgramFindFirstOrThrowArgs} args - Arguments to find a IrrigationProgram
     * @example
     * // Get one IrrigationProgram
     * const irrigationProgram = await prisma.irrigationProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IrrigationProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, IrrigationProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__IrrigationProgramClient<$Result.GetResult<Prisma.$IrrigationProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IrrigationPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IrrigationPrograms
     * const irrigationPrograms = await prisma.irrigationProgram.findMany()
     * 
     * // Get first 10 IrrigationPrograms
     * const irrigationPrograms = await prisma.irrigationProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const irrigationProgramWithIdOnly = await prisma.irrigationProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IrrigationProgramFindManyArgs>(args?: SelectSubset<T, IrrigationProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IrrigationProgram.
     * @param {IrrigationProgramCreateArgs} args - Arguments to create a IrrigationProgram.
     * @example
     * // Create one IrrigationProgram
     * const IrrigationProgram = await prisma.irrigationProgram.create({
     *   data: {
     *     // ... data to create a IrrigationProgram
     *   }
     * })
     * 
     */
    create<T extends IrrigationProgramCreateArgs>(args: SelectSubset<T, IrrigationProgramCreateArgs<ExtArgs>>): Prisma__IrrigationProgramClient<$Result.GetResult<Prisma.$IrrigationProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IrrigationPrograms.
     * @param {IrrigationProgramCreateManyArgs} args - Arguments to create many IrrigationPrograms.
     * @example
     * // Create many IrrigationPrograms
     * const irrigationProgram = await prisma.irrigationProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IrrigationProgramCreateManyArgs>(args?: SelectSubset<T, IrrigationProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IrrigationPrograms and returns the data saved in the database.
     * @param {IrrigationProgramCreateManyAndReturnArgs} args - Arguments to create many IrrigationPrograms.
     * @example
     * // Create many IrrigationPrograms
     * const irrigationProgram = await prisma.irrigationProgram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IrrigationPrograms and only return the `id`
     * const irrigationProgramWithIdOnly = await prisma.irrigationProgram.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IrrigationProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, IrrigationProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IrrigationProgram.
     * @param {IrrigationProgramDeleteArgs} args - Arguments to delete one IrrigationProgram.
     * @example
     * // Delete one IrrigationProgram
     * const IrrigationProgram = await prisma.irrigationProgram.delete({
     *   where: {
     *     // ... filter to delete one IrrigationProgram
     *   }
     * })
     * 
     */
    delete<T extends IrrigationProgramDeleteArgs>(args: SelectSubset<T, IrrigationProgramDeleteArgs<ExtArgs>>): Prisma__IrrigationProgramClient<$Result.GetResult<Prisma.$IrrigationProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IrrigationProgram.
     * @param {IrrigationProgramUpdateArgs} args - Arguments to update one IrrigationProgram.
     * @example
     * // Update one IrrigationProgram
     * const irrigationProgram = await prisma.irrigationProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IrrigationProgramUpdateArgs>(args: SelectSubset<T, IrrigationProgramUpdateArgs<ExtArgs>>): Prisma__IrrigationProgramClient<$Result.GetResult<Prisma.$IrrigationProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IrrigationPrograms.
     * @param {IrrigationProgramDeleteManyArgs} args - Arguments to filter IrrigationPrograms to delete.
     * @example
     * // Delete a few IrrigationPrograms
     * const { count } = await prisma.irrigationProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IrrigationProgramDeleteManyArgs>(args?: SelectSubset<T, IrrigationProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IrrigationPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IrrigationPrograms
     * const irrigationProgram = await prisma.irrigationProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IrrigationProgramUpdateManyArgs>(args: SelectSubset<T, IrrigationProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IrrigationPrograms and returns the data updated in the database.
     * @param {IrrigationProgramUpdateManyAndReturnArgs} args - Arguments to update many IrrigationPrograms.
     * @example
     * // Update many IrrigationPrograms
     * const irrigationProgram = await prisma.irrigationProgram.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IrrigationPrograms and only return the `id`
     * const irrigationProgramWithIdOnly = await prisma.irrigationProgram.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IrrigationProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, IrrigationProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IrrigationProgram.
     * @param {IrrigationProgramUpsertArgs} args - Arguments to update or create a IrrigationProgram.
     * @example
     * // Update or create a IrrigationProgram
     * const irrigationProgram = await prisma.irrigationProgram.upsert({
     *   create: {
     *     // ... data to create a IrrigationProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IrrigationProgram we want to update
     *   }
     * })
     */
    upsert<T extends IrrigationProgramUpsertArgs>(args: SelectSubset<T, IrrigationProgramUpsertArgs<ExtArgs>>): Prisma__IrrigationProgramClient<$Result.GetResult<Prisma.$IrrigationProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IrrigationPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationProgramCountArgs} args - Arguments to filter IrrigationPrograms to count.
     * @example
     * // Count the number of IrrigationPrograms
     * const count = await prisma.irrigationProgram.count({
     *   where: {
     *     // ... the filter for the IrrigationPrograms we want to count
     *   }
     * })
    **/
    count<T extends IrrigationProgramCountArgs>(
      args?: Subset<T, IrrigationProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IrrigationProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IrrigationProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IrrigationProgramAggregateArgs>(args: Subset<T, IrrigationProgramAggregateArgs>): Prisma.PrismaPromise<GetIrrigationProgramAggregateType<T>>

    /**
     * Group by IrrigationProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IrrigationProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IrrigationProgramGroupByArgs['orderBy'] }
        : { orderBy?: IrrigationProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IrrigationProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIrrigationProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IrrigationProgram model
   */
  readonly fields: IrrigationProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IrrigationProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IrrigationProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tasks<T extends IrrigationProgram$tasksArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationProgram$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IrrigationProgram model
   */
  interface IrrigationProgramFieldRefs {
    readonly id: FieldRef<"IrrigationProgram", 'String'>
    readonly name: FieldRef<"IrrigationProgram", 'String'>
    readonly trigger: FieldRef<"IrrigationProgram", 'TriggerType'>
    readonly actuator: FieldRef<"IrrigationProgram", 'ActuatorType'>
    readonly startTime: FieldRef<"IrrigationProgram", 'String'>
    readonly duration: FieldRef<"IrrigationProgram", 'Int'>
    readonly zones: FieldRef<"IrrigationProgram", 'ZoneType[]'>
  }
    

  // Custom InputTypes
  /**
   * IrrigationProgram findUnique
   */
  export type IrrigationProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationProgram
     */
    select?: IrrigationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationProgram
     */
    omit?: IrrigationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationProgramInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationProgram to fetch.
     */
    where: IrrigationProgramWhereUniqueInput
  }

  /**
   * IrrigationProgram findUniqueOrThrow
   */
  export type IrrigationProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationProgram
     */
    select?: IrrigationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationProgram
     */
    omit?: IrrigationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationProgramInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationProgram to fetch.
     */
    where: IrrigationProgramWhereUniqueInput
  }

  /**
   * IrrigationProgram findFirst
   */
  export type IrrigationProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationProgram
     */
    select?: IrrigationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationProgram
     */
    omit?: IrrigationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationProgramInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationProgram to fetch.
     */
    where?: IrrigationProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationPrograms to fetch.
     */
    orderBy?: IrrigationProgramOrderByWithRelationInput | IrrigationProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationPrograms.
     */
    cursor?: IrrigationProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationPrograms.
     */
    distinct?: IrrigationProgramScalarFieldEnum | IrrigationProgramScalarFieldEnum[]
  }

  /**
   * IrrigationProgram findFirstOrThrow
   */
  export type IrrigationProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationProgram
     */
    select?: IrrigationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationProgram
     */
    omit?: IrrigationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationProgramInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationProgram to fetch.
     */
    where?: IrrigationProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationPrograms to fetch.
     */
    orderBy?: IrrigationProgramOrderByWithRelationInput | IrrigationProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationPrograms.
     */
    cursor?: IrrigationProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationPrograms.
     */
    distinct?: IrrigationProgramScalarFieldEnum | IrrigationProgramScalarFieldEnum[]
  }

  /**
   * IrrigationProgram findMany
   */
  export type IrrigationProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationProgram
     */
    select?: IrrigationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationProgram
     */
    omit?: IrrigationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationProgramInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationPrograms to fetch.
     */
    where?: IrrigationProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationPrograms to fetch.
     */
    orderBy?: IrrigationProgramOrderByWithRelationInput | IrrigationProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IrrigationPrograms.
     */
    cursor?: IrrigationProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationPrograms.
     */
    skip?: number
    distinct?: IrrigationProgramScalarFieldEnum | IrrigationProgramScalarFieldEnum[]
  }

  /**
   * IrrigationProgram create
   */
  export type IrrigationProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationProgram
     */
    select?: IrrigationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationProgram
     */
    omit?: IrrigationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a IrrigationProgram.
     */
    data: XOR<IrrigationProgramCreateInput, IrrigationProgramUncheckedCreateInput>
  }

  /**
   * IrrigationProgram createMany
   */
  export type IrrigationProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IrrigationPrograms.
     */
    data: IrrigationProgramCreateManyInput | IrrigationProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IrrigationProgram createManyAndReturn
   */
  export type IrrigationProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationProgram
     */
    select?: IrrigationProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationProgram
     */
    omit?: IrrigationProgramOmit<ExtArgs> | null
    /**
     * The data used to create many IrrigationPrograms.
     */
    data: IrrigationProgramCreateManyInput | IrrigationProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IrrigationProgram update
   */
  export type IrrigationProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationProgram
     */
    select?: IrrigationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationProgram
     */
    omit?: IrrigationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a IrrigationProgram.
     */
    data: XOR<IrrigationProgramUpdateInput, IrrigationProgramUncheckedUpdateInput>
    /**
     * Choose, which IrrigationProgram to update.
     */
    where: IrrigationProgramWhereUniqueInput
  }

  /**
   * IrrigationProgram updateMany
   */
  export type IrrigationProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IrrigationPrograms.
     */
    data: XOR<IrrigationProgramUpdateManyMutationInput, IrrigationProgramUncheckedUpdateManyInput>
    /**
     * Filter which IrrigationPrograms to update
     */
    where?: IrrigationProgramWhereInput
    /**
     * Limit how many IrrigationPrograms to update.
     */
    limit?: number
  }

  /**
   * IrrigationProgram updateManyAndReturn
   */
  export type IrrigationProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationProgram
     */
    select?: IrrigationProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationProgram
     */
    omit?: IrrigationProgramOmit<ExtArgs> | null
    /**
     * The data used to update IrrigationPrograms.
     */
    data: XOR<IrrigationProgramUpdateManyMutationInput, IrrigationProgramUncheckedUpdateManyInput>
    /**
     * Filter which IrrigationPrograms to update
     */
    where?: IrrigationProgramWhereInput
    /**
     * Limit how many IrrigationPrograms to update.
     */
    limit?: number
  }

  /**
   * IrrigationProgram upsert
   */
  export type IrrigationProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationProgram
     */
    select?: IrrigationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationProgram
     */
    omit?: IrrigationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the IrrigationProgram to update in case it exists.
     */
    where: IrrigationProgramWhereUniqueInput
    /**
     * In case the IrrigationProgram found by the `where` argument doesn't exist, create a new IrrigationProgram with this data.
     */
    create: XOR<IrrigationProgramCreateInput, IrrigationProgramUncheckedCreateInput>
    /**
     * In case the IrrigationProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IrrigationProgramUpdateInput, IrrigationProgramUncheckedUpdateInput>
  }

  /**
   * IrrigationProgram delete
   */
  export type IrrigationProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationProgram
     */
    select?: IrrigationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationProgram
     */
    omit?: IrrigationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationProgramInclude<ExtArgs> | null
    /**
     * Filter which IrrigationProgram to delete.
     */
    where: IrrigationProgramWhereUniqueInput
  }

  /**
   * IrrigationProgram deleteMany
   */
  export type IrrigationProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationPrograms to delete
     */
    where?: IrrigationProgramWhereInput
    /**
     * Limit how many IrrigationPrograms to delete.
     */
    limit?: number
  }

  /**
   * IrrigationProgram.tasks
   */
  export type IrrigationProgram$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationTask
     */
    select?: IrrigationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationTask
     */
    omit?: IrrigationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationTaskInclude<ExtArgs> | null
    where?: IrrigationTaskWhereInput
    orderBy?: IrrigationTaskOrderByWithRelationInput | IrrigationTaskOrderByWithRelationInput[]
    cursor?: IrrigationTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IrrigationTaskScalarFieldEnum | IrrigationTaskScalarFieldEnum[]
  }

  /**
   * IrrigationProgram without action
   */
  export type IrrigationProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationProgram
     */
    select?: IrrigationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationProgram
     */
    omit?: IrrigationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationProgramInclude<ExtArgs> | null
  }


  /**
   * Model IrrigationTask
   */

  export type AggregateIrrigationTask = {
    _count: IrrigationTaskCountAggregateOutputType | null
    _avg: IrrigationTaskAvgAggregateOutputType | null
    _sum: IrrigationTaskSumAggregateOutputType | null
    _min: IrrigationTaskMinAggregateOutputType | null
    _max: IrrigationTaskMaxAggregateOutputType | null
  }

  export type IrrigationTaskAvgAggregateOutputType = {
    duration: number | null
  }

  export type IrrigationTaskSumAggregateOutputType = {
    duration: number | null
  }

  export type IrrigationTaskMinAggregateOutputType = {
    id: string | null
    scheduledDate: Date | null
    executionDate: Date | null
    actuator: $Enums.ActuatorType | null
    duration: number | null
    status: $Enums.TaskStatus | null
    programId: string | null
  }

  export type IrrigationTaskMaxAggregateOutputType = {
    id: string | null
    scheduledDate: Date | null
    executionDate: Date | null
    actuator: $Enums.ActuatorType | null
    duration: number | null
    status: $Enums.TaskStatus | null
    programId: string | null
  }

  export type IrrigationTaskCountAggregateOutputType = {
    id: number
    scheduledDate: number
    executionDate: number
    actuator: number
    duration: number
    zones: number
    status: number
    programId: number
    _all: number
  }


  export type IrrigationTaskAvgAggregateInputType = {
    duration?: true
  }

  export type IrrigationTaskSumAggregateInputType = {
    duration?: true
  }

  export type IrrigationTaskMinAggregateInputType = {
    id?: true
    scheduledDate?: true
    executionDate?: true
    actuator?: true
    duration?: true
    status?: true
    programId?: true
  }

  export type IrrigationTaskMaxAggregateInputType = {
    id?: true
    scheduledDate?: true
    executionDate?: true
    actuator?: true
    duration?: true
    status?: true
    programId?: true
  }

  export type IrrigationTaskCountAggregateInputType = {
    id?: true
    scheduledDate?: true
    executionDate?: true
    actuator?: true
    duration?: true
    zones?: true
    status?: true
    programId?: true
    _all?: true
  }

  export type IrrigationTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationTask to aggregate.
     */
    where?: IrrigationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationTasks to fetch.
     */
    orderBy?: IrrigationTaskOrderByWithRelationInput | IrrigationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IrrigationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IrrigationTasks
    **/
    _count?: true | IrrigationTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IrrigationTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IrrigationTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IrrigationTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IrrigationTaskMaxAggregateInputType
  }

  export type GetIrrigationTaskAggregateType<T extends IrrigationTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateIrrigationTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIrrigationTask[P]>
      : GetScalarType<T[P], AggregateIrrigationTask[P]>
  }




  export type IrrigationTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IrrigationTaskWhereInput
    orderBy?: IrrigationTaskOrderByWithAggregationInput | IrrigationTaskOrderByWithAggregationInput[]
    by: IrrigationTaskScalarFieldEnum[] | IrrigationTaskScalarFieldEnum
    having?: IrrigationTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IrrigationTaskCountAggregateInputType | true
    _avg?: IrrigationTaskAvgAggregateInputType
    _sum?: IrrigationTaskSumAggregateInputType
    _min?: IrrigationTaskMinAggregateInputType
    _max?: IrrigationTaskMaxAggregateInputType
  }

  export type IrrigationTaskGroupByOutputType = {
    id: string
    scheduledDate: Date
    executionDate: Date | null
    actuator: $Enums.ActuatorType
    duration: number
    zones: $Enums.ZoneType[]
    status: $Enums.TaskStatus
    programId: string | null
    _count: IrrigationTaskCountAggregateOutputType | null
    _avg: IrrigationTaskAvgAggregateOutputType | null
    _sum: IrrigationTaskSumAggregateOutputType | null
    _min: IrrigationTaskMinAggregateOutputType | null
    _max: IrrigationTaskMaxAggregateOutputType | null
  }

  type GetIrrigationTaskGroupByPayload<T extends IrrigationTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IrrigationTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IrrigationTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IrrigationTaskGroupByOutputType[P]>
            : GetScalarType<T[P], IrrigationTaskGroupByOutputType[P]>
        }
      >
    >


  export type IrrigationTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduledDate?: boolean
    executionDate?: boolean
    actuator?: boolean
    duration?: boolean
    zones?: boolean
    status?: boolean
    programId?: boolean
    program?: boolean | IrrigationTask$programArgs<ExtArgs>
  }, ExtArgs["result"]["irrigationTask"]>

  export type IrrigationTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduledDate?: boolean
    executionDate?: boolean
    actuator?: boolean
    duration?: boolean
    zones?: boolean
    status?: boolean
    programId?: boolean
    program?: boolean | IrrigationTask$programArgs<ExtArgs>
  }, ExtArgs["result"]["irrigationTask"]>

  export type IrrigationTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduledDate?: boolean
    executionDate?: boolean
    actuator?: boolean
    duration?: boolean
    zones?: boolean
    status?: boolean
    programId?: boolean
    program?: boolean | IrrigationTask$programArgs<ExtArgs>
  }, ExtArgs["result"]["irrigationTask"]>

  export type IrrigationTaskSelectScalar = {
    id?: boolean
    scheduledDate?: boolean
    executionDate?: boolean
    actuator?: boolean
    duration?: boolean
    zones?: boolean
    status?: boolean
    programId?: boolean
  }

  export type IrrigationTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scheduledDate" | "executionDate" | "actuator" | "duration" | "zones" | "status" | "programId", ExtArgs["result"]["irrigationTask"]>
  export type IrrigationTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | IrrigationTask$programArgs<ExtArgs>
  }
  export type IrrigationTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | IrrigationTask$programArgs<ExtArgs>
  }
  export type IrrigationTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | IrrigationTask$programArgs<ExtArgs>
  }

  export type $IrrigationTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IrrigationTask"
    objects: {
      program: Prisma.$IrrigationProgramPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scheduledDate: Date
      executionDate: Date | null
      actuator: $Enums.ActuatorType
      duration: number
      zones: $Enums.ZoneType[]
      status: $Enums.TaskStatus
      programId: string | null
    }, ExtArgs["result"]["irrigationTask"]>
    composites: {}
  }

  type IrrigationTaskGetPayload<S extends boolean | null | undefined | IrrigationTaskDefaultArgs> = $Result.GetResult<Prisma.$IrrigationTaskPayload, S>

  type IrrigationTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IrrigationTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IrrigationTaskCountAggregateInputType | true
    }

  export interface IrrigationTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IrrigationTask'], meta: { name: 'IrrigationTask' } }
    /**
     * Find zero or one IrrigationTask that matches the filter.
     * @param {IrrigationTaskFindUniqueArgs} args - Arguments to find a IrrigationTask
     * @example
     * // Get one IrrigationTask
     * const irrigationTask = await prisma.irrigationTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IrrigationTaskFindUniqueArgs>(args: SelectSubset<T, IrrigationTaskFindUniqueArgs<ExtArgs>>): Prisma__IrrigationTaskClient<$Result.GetResult<Prisma.$IrrigationTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IrrigationTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IrrigationTaskFindUniqueOrThrowArgs} args - Arguments to find a IrrigationTask
     * @example
     * // Get one IrrigationTask
     * const irrigationTask = await prisma.irrigationTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IrrigationTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, IrrigationTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IrrigationTaskClient<$Result.GetResult<Prisma.$IrrigationTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationTaskFindFirstArgs} args - Arguments to find a IrrigationTask
     * @example
     * // Get one IrrigationTask
     * const irrigationTask = await prisma.irrigationTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IrrigationTaskFindFirstArgs>(args?: SelectSubset<T, IrrigationTaskFindFirstArgs<ExtArgs>>): Prisma__IrrigationTaskClient<$Result.GetResult<Prisma.$IrrigationTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IrrigationTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationTaskFindFirstOrThrowArgs} args - Arguments to find a IrrigationTask
     * @example
     * // Get one IrrigationTask
     * const irrigationTask = await prisma.irrigationTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IrrigationTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, IrrigationTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__IrrigationTaskClient<$Result.GetResult<Prisma.$IrrigationTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IrrigationTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IrrigationTasks
     * const irrigationTasks = await prisma.irrigationTask.findMany()
     * 
     * // Get first 10 IrrigationTasks
     * const irrigationTasks = await prisma.irrigationTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const irrigationTaskWithIdOnly = await prisma.irrigationTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IrrigationTaskFindManyArgs>(args?: SelectSubset<T, IrrigationTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IrrigationTask.
     * @param {IrrigationTaskCreateArgs} args - Arguments to create a IrrigationTask.
     * @example
     * // Create one IrrigationTask
     * const IrrigationTask = await prisma.irrigationTask.create({
     *   data: {
     *     // ... data to create a IrrigationTask
     *   }
     * })
     * 
     */
    create<T extends IrrigationTaskCreateArgs>(args: SelectSubset<T, IrrigationTaskCreateArgs<ExtArgs>>): Prisma__IrrigationTaskClient<$Result.GetResult<Prisma.$IrrigationTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IrrigationTasks.
     * @param {IrrigationTaskCreateManyArgs} args - Arguments to create many IrrigationTasks.
     * @example
     * // Create many IrrigationTasks
     * const irrigationTask = await prisma.irrigationTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IrrigationTaskCreateManyArgs>(args?: SelectSubset<T, IrrigationTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IrrigationTasks and returns the data saved in the database.
     * @param {IrrigationTaskCreateManyAndReturnArgs} args - Arguments to create many IrrigationTasks.
     * @example
     * // Create many IrrigationTasks
     * const irrigationTask = await prisma.irrigationTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IrrigationTasks and only return the `id`
     * const irrigationTaskWithIdOnly = await prisma.irrigationTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IrrigationTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, IrrigationTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IrrigationTask.
     * @param {IrrigationTaskDeleteArgs} args - Arguments to delete one IrrigationTask.
     * @example
     * // Delete one IrrigationTask
     * const IrrigationTask = await prisma.irrigationTask.delete({
     *   where: {
     *     // ... filter to delete one IrrigationTask
     *   }
     * })
     * 
     */
    delete<T extends IrrigationTaskDeleteArgs>(args: SelectSubset<T, IrrigationTaskDeleteArgs<ExtArgs>>): Prisma__IrrigationTaskClient<$Result.GetResult<Prisma.$IrrigationTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IrrigationTask.
     * @param {IrrigationTaskUpdateArgs} args - Arguments to update one IrrigationTask.
     * @example
     * // Update one IrrigationTask
     * const irrigationTask = await prisma.irrigationTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IrrigationTaskUpdateArgs>(args: SelectSubset<T, IrrigationTaskUpdateArgs<ExtArgs>>): Prisma__IrrigationTaskClient<$Result.GetResult<Prisma.$IrrigationTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IrrigationTasks.
     * @param {IrrigationTaskDeleteManyArgs} args - Arguments to filter IrrigationTasks to delete.
     * @example
     * // Delete a few IrrigationTasks
     * const { count } = await prisma.irrigationTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IrrigationTaskDeleteManyArgs>(args?: SelectSubset<T, IrrigationTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IrrigationTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IrrigationTasks
     * const irrigationTask = await prisma.irrigationTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IrrigationTaskUpdateManyArgs>(args: SelectSubset<T, IrrigationTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IrrigationTasks and returns the data updated in the database.
     * @param {IrrigationTaskUpdateManyAndReturnArgs} args - Arguments to update many IrrigationTasks.
     * @example
     * // Update many IrrigationTasks
     * const irrigationTask = await prisma.irrigationTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IrrigationTasks and only return the `id`
     * const irrigationTaskWithIdOnly = await prisma.irrigationTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IrrigationTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, IrrigationTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IrrigationTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IrrigationTask.
     * @param {IrrigationTaskUpsertArgs} args - Arguments to update or create a IrrigationTask.
     * @example
     * // Update or create a IrrigationTask
     * const irrigationTask = await prisma.irrigationTask.upsert({
     *   create: {
     *     // ... data to create a IrrigationTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IrrigationTask we want to update
     *   }
     * })
     */
    upsert<T extends IrrigationTaskUpsertArgs>(args: SelectSubset<T, IrrigationTaskUpsertArgs<ExtArgs>>): Prisma__IrrigationTaskClient<$Result.GetResult<Prisma.$IrrigationTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IrrigationTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationTaskCountArgs} args - Arguments to filter IrrigationTasks to count.
     * @example
     * // Count the number of IrrigationTasks
     * const count = await prisma.irrigationTask.count({
     *   where: {
     *     // ... the filter for the IrrigationTasks we want to count
     *   }
     * })
    **/
    count<T extends IrrigationTaskCountArgs>(
      args?: Subset<T, IrrigationTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IrrigationTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IrrigationTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IrrigationTaskAggregateArgs>(args: Subset<T, IrrigationTaskAggregateArgs>): Prisma.PrismaPromise<GetIrrigationTaskAggregateType<T>>

    /**
     * Group by IrrigationTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IrrigationTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IrrigationTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IrrigationTaskGroupByArgs['orderBy'] }
        : { orderBy?: IrrigationTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IrrigationTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIrrigationTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IrrigationTask model
   */
  readonly fields: IrrigationTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IrrigationTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IrrigationTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends IrrigationTask$programArgs<ExtArgs> = {}>(args?: Subset<T, IrrigationTask$programArgs<ExtArgs>>): Prisma__IrrigationProgramClient<$Result.GetResult<Prisma.$IrrigationProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IrrigationTask model
   */
  interface IrrigationTaskFieldRefs {
    readonly id: FieldRef<"IrrigationTask", 'String'>
    readonly scheduledDate: FieldRef<"IrrigationTask", 'DateTime'>
    readonly executionDate: FieldRef<"IrrigationTask", 'DateTime'>
    readonly actuator: FieldRef<"IrrigationTask", 'ActuatorType'>
    readonly duration: FieldRef<"IrrigationTask", 'Int'>
    readonly zones: FieldRef<"IrrigationTask", 'ZoneType[]'>
    readonly status: FieldRef<"IrrigationTask", 'TaskStatus'>
    readonly programId: FieldRef<"IrrigationTask", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IrrigationTask findUnique
   */
  export type IrrigationTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationTask
     */
    select?: IrrigationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationTask
     */
    omit?: IrrigationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationTaskInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationTask to fetch.
     */
    where: IrrigationTaskWhereUniqueInput
  }

  /**
   * IrrigationTask findUniqueOrThrow
   */
  export type IrrigationTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationTask
     */
    select?: IrrigationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationTask
     */
    omit?: IrrigationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationTaskInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationTask to fetch.
     */
    where: IrrigationTaskWhereUniqueInput
  }

  /**
   * IrrigationTask findFirst
   */
  export type IrrigationTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationTask
     */
    select?: IrrigationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationTask
     */
    omit?: IrrigationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationTaskInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationTask to fetch.
     */
    where?: IrrigationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationTasks to fetch.
     */
    orderBy?: IrrigationTaskOrderByWithRelationInput | IrrigationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationTasks.
     */
    cursor?: IrrigationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationTasks.
     */
    distinct?: IrrigationTaskScalarFieldEnum | IrrigationTaskScalarFieldEnum[]
  }

  /**
   * IrrigationTask findFirstOrThrow
   */
  export type IrrigationTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationTask
     */
    select?: IrrigationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationTask
     */
    omit?: IrrigationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationTaskInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationTask to fetch.
     */
    where?: IrrigationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationTasks to fetch.
     */
    orderBy?: IrrigationTaskOrderByWithRelationInput | IrrigationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IrrigationTasks.
     */
    cursor?: IrrigationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IrrigationTasks.
     */
    distinct?: IrrigationTaskScalarFieldEnum | IrrigationTaskScalarFieldEnum[]
  }

  /**
   * IrrigationTask findMany
   */
  export type IrrigationTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationTask
     */
    select?: IrrigationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationTask
     */
    omit?: IrrigationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationTaskInclude<ExtArgs> | null
    /**
     * Filter, which IrrigationTasks to fetch.
     */
    where?: IrrigationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IrrigationTasks to fetch.
     */
    orderBy?: IrrigationTaskOrderByWithRelationInput | IrrigationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IrrigationTasks.
     */
    cursor?: IrrigationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IrrigationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IrrigationTasks.
     */
    skip?: number
    distinct?: IrrigationTaskScalarFieldEnum | IrrigationTaskScalarFieldEnum[]
  }

  /**
   * IrrigationTask create
   */
  export type IrrigationTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationTask
     */
    select?: IrrigationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationTask
     */
    omit?: IrrigationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a IrrigationTask.
     */
    data: XOR<IrrigationTaskCreateInput, IrrigationTaskUncheckedCreateInput>
  }

  /**
   * IrrigationTask createMany
   */
  export type IrrigationTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IrrigationTasks.
     */
    data: IrrigationTaskCreateManyInput | IrrigationTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IrrigationTask createManyAndReturn
   */
  export type IrrigationTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationTask
     */
    select?: IrrigationTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationTask
     */
    omit?: IrrigationTaskOmit<ExtArgs> | null
    /**
     * The data used to create many IrrigationTasks.
     */
    data: IrrigationTaskCreateManyInput | IrrigationTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IrrigationTask update
   */
  export type IrrigationTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationTask
     */
    select?: IrrigationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationTask
     */
    omit?: IrrigationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a IrrigationTask.
     */
    data: XOR<IrrigationTaskUpdateInput, IrrigationTaskUncheckedUpdateInput>
    /**
     * Choose, which IrrigationTask to update.
     */
    where: IrrigationTaskWhereUniqueInput
  }

  /**
   * IrrigationTask updateMany
   */
  export type IrrigationTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IrrigationTasks.
     */
    data: XOR<IrrigationTaskUpdateManyMutationInput, IrrigationTaskUncheckedUpdateManyInput>
    /**
     * Filter which IrrigationTasks to update
     */
    where?: IrrigationTaskWhereInput
    /**
     * Limit how many IrrigationTasks to update.
     */
    limit?: number
  }

  /**
   * IrrigationTask updateManyAndReturn
   */
  export type IrrigationTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationTask
     */
    select?: IrrigationTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationTask
     */
    omit?: IrrigationTaskOmit<ExtArgs> | null
    /**
     * The data used to update IrrigationTasks.
     */
    data: XOR<IrrigationTaskUpdateManyMutationInput, IrrigationTaskUncheckedUpdateManyInput>
    /**
     * Filter which IrrigationTasks to update
     */
    where?: IrrigationTaskWhereInput
    /**
     * Limit how many IrrigationTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IrrigationTask upsert
   */
  export type IrrigationTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationTask
     */
    select?: IrrigationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationTask
     */
    omit?: IrrigationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the IrrigationTask to update in case it exists.
     */
    where: IrrigationTaskWhereUniqueInput
    /**
     * In case the IrrigationTask found by the `where` argument doesn't exist, create a new IrrigationTask with this data.
     */
    create: XOR<IrrigationTaskCreateInput, IrrigationTaskUncheckedCreateInput>
    /**
     * In case the IrrigationTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IrrigationTaskUpdateInput, IrrigationTaskUncheckedUpdateInput>
  }

  /**
   * IrrigationTask delete
   */
  export type IrrigationTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationTask
     */
    select?: IrrigationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationTask
     */
    omit?: IrrigationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationTaskInclude<ExtArgs> | null
    /**
     * Filter which IrrigationTask to delete.
     */
    where: IrrigationTaskWhereUniqueInput
  }

  /**
   * IrrigationTask deleteMany
   */
  export type IrrigationTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IrrigationTasks to delete
     */
    where?: IrrigationTaskWhereInput
    /**
     * Limit how many IrrigationTasks to delete.
     */
    limit?: number
  }

  /**
   * IrrigationTask.program
   */
  export type IrrigationTask$programArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationProgram
     */
    select?: IrrigationProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationProgram
     */
    omit?: IrrigationProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationProgramInclude<ExtArgs> | null
    where?: IrrigationProgramWhereInput
  }

  /**
   * IrrigationTask without action
   */
  export type IrrigationTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IrrigationTask
     */
    select?: IrrigationTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IrrigationTask
     */
    omit?: IrrigationTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IrrigationTaskInclude<ExtArgs> | null
  }


  /**
   * Model SensorReading
   */

  export type AggregateSensorReading = {
    _count: SensorReadingCountAggregateOutputType | null
    _avg: SensorReadingAvgAggregateOutputType | null
    _sum: SensorReadingSumAggregateOutputType | null
    _min: SensorReadingMinAggregateOutputType | null
    _max: SensorReadingMaxAggregateOutputType | null
  }

  export type SensorReadingAvgAggregateOutputType = {
    value: number | null
  }

  export type SensorReadingSumAggregateOutputType = {
    value: number | null
  }

  export type SensorReadingMinAggregateOutputType = {
    id: string | null
    zone: $Enums.ZoneType | null
    sensorType: $Enums.SensorType | null
    value: number | null
    timestamp: Date | null
  }

  export type SensorReadingMaxAggregateOutputType = {
    id: string | null
    zone: $Enums.ZoneType | null
    sensorType: $Enums.SensorType | null
    value: number | null
    timestamp: Date | null
  }

  export type SensorReadingCountAggregateOutputType = {
    id: number
    zone: number
    sensorType: number
    value: number
    timestamp: number
    _all: number
  }


  export type SensorReadingAvgAggregateInputType = {
    value?: true
  }

  export type SensorReadingSumAggregateInputType = {
    value?: true
  }

  export type SensorReadingMinAggregateInputType = {
    id?: true
    zone?: true
    sensorType?: true
    value?: true
    timestamp?: true
  }

  export type SensorReadingMaxAggregateInputType = {
    id?: true
    zone?: true
    sensorType?: true
    value?: true
    timestamp?: true
  }

  export type SensorReadingCountAggregateInputType = {
    id?: true
    zone?: true
    sensorType?: true
    value?: true
    timestamp?: true
    _all?: true
  }

  export type SensorReadingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SensorReading to aggregate.
     */
    where?: SensorReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SensorReadings to fetch.
     */
    orderBy?: SensorReadingOrderByWithRelationInput | SensorReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SensorReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SensorReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SensorReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SensorReadings
    **/
    _count?: true | SensorReadingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SensorReadingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SensorReadingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SensorReadingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SensorReadingMaxAggregateInputType
  }

  export type GetSensorReadingAggregateType<T extends SensorReadingAggregateArgs> = {
        [P in keyof T & keyof AggregateSensorReading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSensorReading[P]>
      : GetScalarType<T[P], AggregateSensorReading[P]>
  }




  export type SensorReadingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SensorReadingWhereInput
    orderBy?: SensorReadingOrderByWithAggregationInput | SensorReadingOrderByWithAggregationInput[]
    by: SensorReadingScalarFieldEnum[] | SensorReadingScalarFieldEnum
    having?: SensorReadingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SensorReadingCountAggregateInputType | true
    _avg?: SensorReadingAvgAggregateInputType
    _sum?: SensorReadingSumAggregateInputType
    _min?: SensorReadingMinAggregateInputType
    _max?: SensorReadingMaxAggregateInputType
  }

  export type SensorReadingGroupByOutputType = {
    id: string
    zone: $Enums.ZoneType
    sensorType: $Enums.SensorType
    value: number
    timestamp: Date
    _count: SensorReadingCountAggregateOutputType | null
    _avg: SensorReadingAvgAggregateOutputType | null
    _sum: SensorReadingSumAggregateOutputType | null
    _min: SensorReadingMinAggregateOutputType | null
    _max: SensorReadingMaxAggregateOutputType | null
  }

  type GetSensorReadingGroupByPayload<T extends SensorReadingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SensorReadingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SensorReadingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SensorReadingGroupByOutputType[P]>
            : GetScalarType<T[P], SensorReadingGroupByOutputType[P]>
        }
      >
    >


  export type SensorReadingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zone?: boolean
    sensorType?: boolean
    value?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["sensorReading"]>

  export type SensorReadingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zone?: boolean
    sensorType?: boolean
    value?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["sensorReading"]>

  export type SensorReadingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zone?: boolean
    sensorType?: boolean
    value?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["sensorReading"]>

  export type SensorReadingSelectScalar = {
    id?: boolean
    zone?: boolean
    sensorType?: boolean
    value?: boolean
    timestamp?: boolean
  }

  export type SensorReadingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "zone" | "sensorType" | "value" | "timestamp", ExtArgs["result"]["sensorReading"]>

  export type $SensorReadingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SensorReading"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      zone: $Enums.ZoneType
      sensorType: $Enums.SensorType
      value: number
      timestamp: Date
    }, ExtArgs["result"]["sensorReading"]>
    composites: {}
  }

  type SensorReadingGetPayload<S extends boolean | null | undefined | SensorReadingDefaultArgs> = $Result.GetResult<Prisma.$SensorReadingPayload, S>

  type SensorReadingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SensorReadingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SensorReadingCountAggregateInputType | true
    }

  export interface SensorReadingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SensorReading'], meta: { name: 'SensorReading' } }
    /**
     * Find zero or one SensorReading that matches the filter.
     * @param {SensorReadingFindUniqueArgs} args - Arguments to find a SensorReading
     * @example
     * // Get one SensorReading
     * const sensorReading = await prisma.sensorReading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SensorReadingFindUniqueArgs>(args: SelectSubset<T, SensorReadingFindUniqueArgs<ExtArgs>>): Prisma__SensorReadingClient<$Result.GetResult<Prisma.$SensorReadingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SensorReading that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SensorReadingFindUniqueOrThrowArgs} args - Arguments to find a SensorReading
     * @example
     * // Get one SensorReading
     * const sensorReading = await prisma.sensorReading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SensorReadingFindUniqueOrThrowArgs>(args: SelectSubset<T, SensorReadingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SensorReadingClient<$Result.GetResult<Prisma.$SensorReadingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SensorReading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorReadingFindFirstArgs} args - Arguments to find a SensorReading
     * @example
     * // Get one SensorReading
     * const sensorReading = await prisma.sensorReading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SensorReadingFindFirstArgs>(args?: SelectSubset<T, SensorReadingFindFirstArgs<ExtArgs>>): Prisma__SensorReadingClient<$Result.GetResult<Prisma.$SensorReadingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SensorReading that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorReadingFindFirstOrThrowArgs} args - Arguments to find a SensorReading
     * @example
     * // Get one SensorReading
     * const sensorReading = await prisma.sensorReading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SensorReadingFindFirstOrThrowArgs>(args?: SelectSubset<T, SensorReadingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SensorReadingClient<$Result.GetResult<Prisma.$SensorReadingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SensorReadings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorReadingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SensorReadings
     * const sensorReadings = await prisma.sensorReading.findMany()
     * 
     * // Get first 10 SensorReadings
     * const sensorReadings = await prisma.sensorReading.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sensorReadingWithIdOnly = await prisma.sensorReading.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SensorReadingFindManyArgs>(args?: SelectSubset<T, SensorReadingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorReadingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SensorReading.
     * @param {SensorReadingCreateArgs} args - Arguments to create a SensorReading.
     * @example
     * // Create one SensorReading
     * const SensorReading = await prisma.sensorReading.create({
     *   data: {
     *     // ... data to create a SensorReading
     *   }
     * })
     * 
     */
    create<T extends SensorReadingCreateArgs>(args: SelectSubset<T, SensorReadingCreateArgs<ExtArgs>>): Prisma__SensorReadingClient<$Result.GetResult<Prisma.$SensorReadingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SensorReadings.
     * @param {SensorReadingCreateManyArgs} args - Arguments to create many SensorReadings.
     * @example
     * // Create many SensorReadings
     * const sensorReading = await prisma.sensorReading.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SensorReadingCreateManyArgs>(args?: SelectSubset<T, SensorReadingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SensorReadings and returns the data saved in the database.
     * @param {SensorReadingCreateManyAndReturnArgs} args - Arguments to create many SensorReadings.
     * @example
     * // Create many SensorReadings
     * const sensorReading = await prisma.sensorReading.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SensorReadings and only return the `id`
     * const sensorReadingWithIdOnly = await prisma.sensorReading.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SensorReadingCreateManyAndReturnArgs>(args?: SelectSubset<T, SensorReadingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorReadingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SensorReading.
     * @param {SensorReadingDeleteArgs} args - Arguments to delete one SensorReading.
     * @example
     * // Delete one SensorReading
     * const SensorReading = await prisma.sensorReading.delete({
     *   where: {
     *     // ... filter to delete one SensorReading
     *   }
     * })
     * 
     */
    delete<T extends SensorReadingDeleteArgs>(args: SelectSubset<T, SensorReadingDeleteArgs<ExtArgs>>): Prisma__SensorReadingClient<$Result.GetResult<Prisma.$SensorReadingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SensorReading.
     * @param {SensorReadingUpdateArgs} args - Arguments to update one SensorReading.
     * @example
     * // Update one SensorReading
     * const sensorReading = await prisma.sensorReading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SensorReadingUpdateArgs>(args: SelectSubset<T, SensorReadingUpdateArgs<ExtArgs>>): Prisma__SensorReadingClient<$Result.GetResult<Prisma.$SensorReadingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SensorReadings.
     * @param {SensorReadingDeleteManyArgs} args - Arguments to filter SensorReadings to delete.
     * @example
     * // Delete a few SensorReadings
     * const { count } = await prisma.sensorReading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SensorReadingDeleteManyArgs>(args?: SelectSubset<T, SensorReadingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SensorReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorReadingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SensorReadings
     * const sensorReading = await prisma.sensorReading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SensorReadingUpdateManyArgs>(args: SelectSubset<T, SensorReadingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SensorReadings and returns the data updated in the database.
     * @param {SensorReadingUpdateManyAndReturnArgs} args - Arguments to update many SensorReadings.
     * @example
     * // Update many SensorReadings
     * const sensorReading = await prisma.sensorReading.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SensorReadings and only return the `id`
     * const sensorReadingWithIdOnly = await prisma.sensorReading.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SensorReadingUpdateManyAndReturnArgs>(args: SelectSubset<T, SensorReadingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorReadingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SensorReading.
     * @param {SensorReadingUpsertArgs} args - Arguments to update or create a SensorReading.
     * @example
     * // Update or create a SensorReading
     * const sensorReading = await prisma.sensorReading.upsert({
     *   create: {
     *     // ... data to create a SensorReading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SensorReading we want to update
     *   }
     * })
     */
    upsert<T extends SensorReadingUpsertArgs>(args: SelectSubset<T, SensorReadingUpsertArgs<ExtArgs>>): Prisma__SensorReadingClient<$Result.GetResult<Prisma.$SensorReadingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SensorReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorReadingCountArgs} args - Arguments to filter SensorReadings to count.
     * @example
     * // Count the number of SensorReadings
     * const count = await prisma.sensorReading.count({
     *   where: {
     *     // ... the filter for the SensorReadings we want to count
     *   }
     * })
    **/
    count<T extends SensorReadingCountArgs>(
      args?: Subset<T, SensorReadingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SensorReadingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SensorReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorReadingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SensorReadingAggregateArgs>(args: Subset<T, SensorReadingAggregateArgs>): Prisma.PrismaPromise<GetSensorReadingAggregateType<T>>

    /**
     * Group by SensorReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorReadingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SensorReadingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SensorReadingGroupByArgs['orderBy'] }
        : { orderBy?: SensorReadingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SensorReadingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSensorReadingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SensorReading model
   */
  readonly fields: SensorReadingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SensorReading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SensorReadingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SensorReading model
   */
  interface SensorReadingFieldRefs {
    readonly id: FieldRef<"SensorReading", 'String'>
    readonly zone: FieldRef<"SensorReading", 'ZoneType'>
    readonly sensorType: FieldRef<"SensorReading", 'SensorType'>
    readonly value: FieldRef<"SensorReading", 'Float'>
    readonly timestamp: FieldRef<"SensorReading", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SensorReading findUnique
   */
  export type SensorReadingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorReading
     */
    select?: SensorReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SensorReading
     */
    omit?: SensorReadingOmit<ExtArgs> | null
    /**
     * Filter, which SensorReading to fetch.
     */
    where: SensorReadingWhereUniqueInput
  }

  /**
   * SensorReading findUniqueOrThrow
   */
  export type SensorReadingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorReading
     */
    select?: SensorReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SensorReading
     */
    omit?: SensorReadingOmit<ExtArgs> | null
    /**
     * Filter, which SensorReading to fetch.
     */
    where: SensorReadingWhereUniqueInput
  }

  /**
   * SensorReading findFirst
   */
  export type SensorReadingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorReading
     */
    select?: SensorReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SensorReading
     */
    omit?: SensorReadingOmit<ExtArgs> | null
    /**
     * Filter, which SensorReading to fetch.
     */
    where?: SensorReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SensorReadings to fetch.
     */
    orderBy?: SensorReadingOrderByWithRelationInput | SensorReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SensorReadings.
     */
    cursor?: SensorReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SensorReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SensorReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SensorReadings.
     */
    distinct?: SensorReadingScalarFieldEnum | SensorReadingScalarFieldEnum[]
  }

  /**
   * SensorReading findFirstOrThrow
   */
  export type SensorReadingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorReading
     */
    select?: SensorReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SensorReading
     */
    omit?: SensorReadingOmit<ExtArgs> | null
    /**
     * Filter, which SensorReading to fetch.
     */
    where?: SensorReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SensorReadings to fetch.
     */
    orderBy?: SensorReadingOrderByWithRelationInput | SensorReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SensorReadings.
     */
    cursor?: SensorReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SensorReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SensorReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SensorReadings.
     */
    distinct?: SensorReadingScalarFieldEnum | SensorReadingScalarFieldEnum[]
  }

  /**
   * SensorReading findMany
   */
  export type SensorReadingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorReading
     */
    select?: SensorReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SensorReading
     */
    omit?: SensorReadingOmit<ExtArgs> | null
    /**
     * Filter, which SensorReadings to fetch.
     */
    where?: SensorReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SensorReadings to fetch.
     */
    orderBy?: SensorReadingOrderByWithRelationInput | SensorReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SensorReadings.
     */
    cursor?: SensorReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SensorReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SensorReadings.
     */
    skip?: number
    distinct?: SensorReadingScalarFieldEnum | SensorReadingScalarFieldEnum[]
  }

  /**
   * SensorReading create
   */
  export type SensorReadingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorReading
     */
    select?: SensorReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SensorReading
     */
    omit?: SensorReadingOmit<ExtArgs> | null
    /**
     * The data needed to create a SensorReading.
     */
    data: XOR<SensorReadingCreateInput, SensorReadingUncheckedCreateInput>
  }

  /**
   * SensorReading createMany
   */
  export type SensorReadingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SensorReadings.
     */
    data: SensorReadingCreateManyInput | SensorReadingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SensorReading createManyAndReturn
   */
  export type SensorReadingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorReading
     */
    select?: SensorReadingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SensorReading
     */
    omit?: SensorReadingOmit<ExtArgs> | null
    /**
     * The data used to create many SensorReadings.
     */
    data: SensorReadingCreateManyInput | SensorReadingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SensorReading update
   */
  export type SensorReadingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorReading
     */
    select?: SensorReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SensorReading
     */
    omit?: SensorReadingOmit<ExtArgs> | null
    /**
     * The data needed to update a SensorReading.
     */
    data: XOR<SensorReadingUpdateInput, SensorReadingUncheckedUpdateInput>
    /**
     * Choose, which SensorReading to update.
     */
    where: SensorReadingWhereUniqueInput
  }

  /**
   * SensorReading updateMany
   */
  export type SensorReadingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SensorReadings.
     */
    data: XOR<SensorReadingUpdateManyMutationInput, SensorReadingUncheckedUpdateManyInput>
    /**
     * Filter which SensorReadings to update
     */
    where?: SensorReadingWhereInput
    /**
     * Limit how many SensorReadings to update.
     */
    limit?: number
  }

  /**
   * SensorReading updateManyAndReturn
   */
  export type SensorReadingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorReading
     */
    select?: SensorReadingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SensorReading
     */
    omit?: SensorReadingOmit<ExtArgs> | null
    /**
     * The data used to update SensorReadings.
     */
    data: XOR<SensorReadingUpdateManyMutationInput, SensorReadingUncheckedUpdateManyInput>
    /**
     * Filter which SensorReadings to update
     */
    where?: SensorReadingWhereInput
    /**
     * Limit how many SensorReadings to update.
     */
    limit?: number
  }

  /**
   * SensorReading upsert
   */
  export type SensorReadingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorReading
     */
    select?: SensorReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SensorReading
     */
    omit?: SensorReadingOmit<ExtArgs> | null
    /**
     * The filter to search for the SensorReading to update in case it exists.
     */
    where: SensorReadingWhereUniqueInput
    /**
     * In case the SensorReading found by the `where` argument doesn't exist, create a new SensorReading with this data.
     */
    create: XOR<SensorReadingCreateInput, SensorReadingUncheckedCreateInput>
    /**
     * In case the SensorReading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SensorReadingUpdateInput, SensorReadingUncheckedUpdateInput>
  }

  /**
   * SensorReading delete
   */
  export type SensorReadingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorReading
     */
    select?: SensorReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SensorReading
     */
    omit?: SensorReadingOmit<ExtArgs> | null
    /**
     * Filter which SensorReading to delete.
     */
    where: SensorReadingWhereUniqueInput
  }

  /**
   * SensorReading deleteMany
   */
  export type SensorReadingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SensorReadings to delete
     */
    where?: SensorReadingWhereInput
    /**
     * Limit how many SensorReadings to delete.
     */
    limit?: number
  }

  /**
   * SensorReading without action
   */
  export type SensorReadingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SensorReading
     */
    select?: SensorReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SensorReading
     */
    omit?: SensorReadingOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const StockScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    available: 'available'
  };

  export type StockScalarFieldEnum = (typeof StockScalarFieldEnum)[keyof typeof StockScalarFieldEnum]


  export const GenusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type'
  };

  export type GenusScalarFieldEnum = (typeof GenusScalarFieldEnum)[keyof typeof GenusScalarFieldEnum]


  export const SpeciesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    slug: 'slug',
    description: 'description',
    genusId: 'genusId',
    stockId: 'stockId'
  };

  export type SpeciesScalarFieldEnum = (typeof SpeciesScalarFieldEnum)[keyof typeof SpeciesScalarFieldEnum]


  export const SpeciesImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    speciesId: 'speciesId'
  };

  export type SpeciesImageScalarFieldEnum = (typeof SpeciesImageScalarFieldEnum)[keyof typeof SpeciesImageScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    zone: 'zone',
    table: 'table'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const PlantScalarFieldEnum: {
    id: 'id',
    pottingDate: 'pottingDate',
    speciesId: 'speciesId',
    locationId: 'locationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlantScalarFieldEnum = (typeof PlantScalarFieldEnum)[keyof typeof PlantScalarFieldEnum]


  export const AgrochemicalScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    porpose: 'porpose',
    preparation: 'preparation'
  };

  export type AgrochemicalScalarFieldEnum = (typeof AgrochemicalScalarFieldEnum)[keyof typeof AgrochemicalScalarFieldEnum]


  export const FertilizationProgramScalarFieldEnum: {
    id: 'id',
    name: 'name',
    weeklyFrequency: 'weeklyFrequency'
  };

  export type FertilizationProgramScalarFieldEnum = (typeof FertilizationProgramScalarFieldEnum)[keyof typeof FertilizationProgramScalarFieldEnum]


  export const FertilizationCycleScalarFieldEnum: {
    id: 'id',
    sequence: 'sequence',
    agrochemicalId: 'agrochemicalId',
    programId: 'programId'
  };

  export type FertilizationCycleScalarFieldEnum = (typeof FertilizationCycleScalarFieldEnum)[keyof typeof FertilizationCycleScalarFieldEnum]


  export const FertilizationTaskScalarFieldEnum: {
    id: 'id',
    scheduledDate: 'scheduledDate',
    executionDate: 'executionDate',
    zones: 'zones',
    note: 'note',
    status: 'status',
    agrochemicalId: 'agrochemicalId',
    productsCycleId: 'productsCycleId'
  };

  export type FertilizationTaskScalarFieldEnum = (typeof FertilizationTaskScalarFieldEnum)[keyof typeof FertilizationTaskScalarFieldEnum]


  export const PhytosanitaryProgramScalarFieldEnum: {
    id: 'id',
    name: 'name',
    monthlyFrequency: 'monthlyFrequency'
  };

  export type PhytosanitaryProgramScalarFieldEnum = (typeof PhytosanitaryProgramScalarFieldEnum)[keyof typeof PhytosanitaryProgramScalarFieldEnum]


  export const PhytosanitaryCycleScalarFieldEnum: {
    id: 'id',
    sequence: 'sequence',
    agrochemicalId: 'agrochemicalId',
    programId: 'programId'
  };

  export type PhytosanitaryCycleScalarFieldEnum = (typeof PhytosanitaryCycleScalarFieldEnum)[keyof typeof PhytosanitaryCycleScalarFieldEnum]


  export const PhytosanitaryTaskScalarFieldEnum: {
    id: 'id',
    scheduledDate: 'scheduledDate',
    executionDate: 'executionDate',
    zones: 'zones',
    note: 'note',
    status: 'status',
    agrochemicalId: 'agrochemicalId',
    productsCycleId: 'productsCycleId'
  };

  export type PhytosanitaryTaskScalarFieldEnum = (typeof PhytosanitaryTaskScalarFieldEnum)[keyof typeof PhytosanitaryTaskScalarFieldEnum]


  export const IrrigationProgramScalarFieldEnum: {
    id: 'id',
    name: 'name',
    trigger: 'trigger',
    actuator: 'actuator',
    startTime: 'startTime',
    duration: 'duration',
    zones: 'zones'
  };

  export type IrrigationProgramScalarFieldEnum = (typeof IrrigationProgramScalarFieldEnum)[keyof typeof IrrigationProgramScalarFieldEnum]


  export const IrrigationTaskScalarFieldEnum: {
    id: 'id',
    scheduledDate: 'scheduledDate',
    executionDate: 'executionDate',
    actuator: 'actuator',
    duration: 'duration',
    zones: 'zones',
    status: 'status',
    programId: 'programId'
  };

  export type IrrigationTaskScalarFieldEnum = (typeof IrrigationTaskScalarFieldEnum)[keyof typeof IrrigationTaskScalarFieldEnum]


  export const SensorReadingScalarFieldEnum: {
    id: 'id',
    zone: 'zone',
    sensorType: 'sensorType',
    value: 'value',
    timestamp: 'timestamp'
  };

  export type SensorReadingScalarFieldEnum = (typeof SensorReadingScalarFieldEnum)[keyof typeof SensorReadingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'PlantType'
   */
  export type EnumPlantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlantType'>
    


  /**
   * Reference to a field of type 'PlantType[]'
   */
  export type ListEnumPlantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlantType[]'>
    


  /**
   * Reference to a field of type 'ZoneType'
   */
  export type EnumZoneTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ZoneType'>
    


  /**
   * Reference to a field of type 'ZoneType[]'
   */
  export type ListEnumZoneTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ZoneType[]'>
    


  /**
   * Reference to a field of type 'TableType'
   */
  export type EnumTableTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TableType'>
    


  /**
   * Reference to a field of type 'TableType[]'
   */
  export type ListEnumTableTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TableType[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AgrochemicalType'
   */
  export type EnumAgrochemicalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgrochemicalType'>
    


  /**
   * Reference to a field of type 'AgrochemicalType[]'
   */
  export type ListEnumAgrochemicalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgrochemicalType[]'>
    


  /**
   * Reference to a field of type 'AgrochemicalPorpose'
   */
  export type EnumAgrochemicalPorposeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgrochemicalPorpose'>
    


  /**
   * Reference to a field of type 'AgrochemicalPorpose[]'
   */
  export type ListEnumAgrochemicalPorposeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgrochemicalPorpose[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'TriggerType'
   */
  export type EnumTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerType'>
    


  /**
   * Reference to a field of type 'TriggerType[]'
   */
  export type ListEnumTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerType[]'>
    


  /**
   * Reference to a field of type 'ActuatorType'
   */
  export type EnumActuatorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActuatorType'>
    


  /**
   * Reference to a field of type 'ActuatorType[]'
   */
  export type ListEnumActuatorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActuatorType[]'>
    


  /**
   * Reference to a field of type 'SensorType'
   */
  export type EnumSensorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SensorType'>
    


  /**
   * Reference to a field of type 'SensorType[]'
   */
  export type ListEnumSensorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SensorType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type StockWhereInput = {
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    id?: StringFilter<"Stock"> | string
    quantity?: IntFilter<"Stock"> | number
    available?: BoolFilter<"Stock"> | boolean
    species?: SpeciesListRelationFilter
  }

  export type StockOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    available?: SortOrder
    species?: SpeciesOrderByRelationAggregateInput
  }

  export type StockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    quantity?: IntFilter<"Stock"> | number
    available?: BoolFilter<"Stock"> | boolean
    species?: SpeciesListRelationFilter
  }, "id">

  export type StockOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    available?: SortOrder
    _count?: StockCountOrderByAggregateInput
    _avg?: StockAvgOrderByAggregateInput
    _max?: StockMaxOrderByAggregateInput
    _min?: StockMinOrderByAggregateInput
    _sum?: StockSumOrderByAggregateInput
  }

  export type StockScalarWhereWithAggregatesInput = {
    AND?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    OR?: StockScalarWhereWithAggregatesInput[]
    NOT?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Stock"> | string
    quantity?: IntWithAggregatesFilter<"Stock"> | number
    available?: BoolWithAggregatesFilter<"Stock"> | boolean
  }

  export type GenusWhereInput = {
    AND?: GenusWhereInput | GenusWhereInput[]
    OR?: GenusWhereInput[]
    NOT?: GenusWhereInput | GenusWhereInput[]
    id?: StringFilter<"Genus"> | string
    name?: StringFilter<"Genus"> | string
    type?: EnumPlantTypeFilter<"Genus"> | $Enums.PlantType
    species?: SpeciesListRelationFilter
  }

  export type GenusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    species?: SpeciesOrderByRelationAggregateInput
  }

  export type GenusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: GenusWhereInput | GenusWhereInput[]
    OR?: GenusWhereInput[]
    NOT?: GenusWhereInput | GenusWhereInput[]
    type?: EnumPlantTypeFilter<"Genus"> | $Enums.PlantType
    species?: SpeciesListRelationFilter
  }, "id" | "name">

  export type GenusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    _count?: GenusCountOrderByAggregateInput
    _max?: GenusMaxOrderByAggregateInput
    _min?: GenusMinOrderByAggregateInput
  }

  export type GenusScalarWhereWithAggregatesInput = {
    AND?: GenusScalarWhereWithAggregatesInput | GenusScalarWhereWithAggregatesInput[]
    OR?: GenusScalarWhereWithAggregatesInput[]
    NOT?: GenusScalarWhereWithAggregatesInput | GenusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Genus"> | string
    name?: StringWithAggregatesFilter<"Genus"> | string
    type?: EnumPlantTypeWithAggregatesFilter<"Genus"> | $Enums.PlantType
  }

  export type SpeciesWhereInput = {
    AND?: SpeciesWhereInput | SpeciesWhereInput[]
    OR?: SpeciesWhereInput[]
    NOT?: SpeciesWhereInput | SpeciesWhereInput[]
    id?: StringFilter<"Species"> | string
    name?: StringFilter<"Species"> | string
    price?: IntFilter<"Species"> | number
    slug?: StringFilter<"Species"> | string
    description?: StringNullableFilter<"Species"> | string | null
    genusId?: StringFilter<"Species"> | string
    stockId?: StringFilter<"Species"> | string
    genus?: XOR<GenusScalarRelationFilter, GenusWhereInput>
    stock?: XOR<StockScalarRelationFilter, StockWhereInput>
    plants?: PlantListRelationFilter
    images?: SpeciesImageListRelationFilter
  }

  export type SpeciesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    genusId?: SortOrder
    stockId?: SortOrder
    genus?: GenusOrderByWithRelationInput
    stock?: StockOrderByWithRelationInput
    plants?: PlantOrderByRelationAggregateInput
    images?: SpeciesImageOrderByRelationAggregateInput
  }

  export type SpeciesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: SpeciesWhereInput | SpeciesWhereInput[]
    OR?: SpeciesWhereInput[]
    NOT?: SpeciesWhereInput | SpeciesWhereInput[]
    price?: IntFilter<"Species"> | number
    description?: StringNullableFilter<"Species"> | string | null
    genusId?: StringFilter<"Species"> | string
    stockId?: StringFilter<"Species"> | string
    genus?: XOR<GenusScalarRelationFilter, GenusWhereInput>
    stock?: XOR<StockScalarRelationFilter, StockWhereInput>
    plants?: PlantListRelationFilter
    images?: SpeciesImageListRelationFilter
  }, "id" | "name" | "slug">

  export type SpeciesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    genusId?: SortOrder
    stockId?: SortOrder
    _count?: SpeciesCountOrderByAggregateInput
    _avg?: SpeciesAvgOrderByAggregateInput
    _max?: SpeciesMaxOrderByAggregateInput
    _min?: SpeciesMinOrderByAggregateInput
    _sum?: SpeciesSumOrderByAggregateInput
  }

  export type SpeciesScalarWhereWithAggregatesInput = {
    AND?: SpeciesScalarWhereWithAggregatesInput | SpeciesScalarWhereWithAggregatesInput[]
    OR?: SpeciesScalarWhereWithAggregatesInput[]
    NOT?: SpeciesScalarWhereWithAggregatesInput | SpeciesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Species"> | string
    name?: StringWithAggregatesFilter<"Species"> | string
    price?: IntWithAggregatesFilter<"Species"> | number
    slug?: StringWithAggregatesFilter<"Species"> | string
    description?: StringNullableWithAggregatesFilter<"Species"> | string | null
    genusId?: StringWithAggregatesFilter<"Species"> | string
    stockId?: StringWithAggregatesFilter<"Species"> | string
  }

  export type SpeciesImageWhereInput = {
    AND?: SpeciesImageWhereInput | SpeciesImageWhereInput[]
    OR?: SpeciesImageWhereInput[]
    NOT?: SpeciesImageWhereInput | SpeciesImageWhereInput[]
    id?: StringFilter<"SpeciesImage"> | string
    url?: StringFilter<"SpeciesImage"> | string
    speciesId?: StringFilter<"SpeciesImage"> | string
    species?: XOR<SpeciesScalarRelationFilter, SpeciesWhereInput>
  }

  export type SpeciesImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    speciesId?: SortOrder
    species?: SpeciesOrderByWithRelationInput
  }

  export type SpeciesImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    url?: string
    AND?: SpeciesImageWhereInput | SpeciesImageWhereInput[]
    OR?: SpeciesImageWhereInput[]
    NOT?: SpeciesImageWhereInput | SpeciesImageWhereInput[]
    speciesId?: StringFilter<"SpeciesImage"> | string
    species?: XOR<SpeciesScalarRelationFilter, SpeciesWhereInput>
  }, "id" | "url">

  export type SpeciesImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    speciesId?: SortOrder
    _count?: SpeciesImageCountOrderByAggregateInput
    _max?: SpeciesImageMaxOrderByAggregateInput
    _min?: SpeciesImageMinOrderByAggregateInput
  }

  export type SpeciesImageScalarWhereWithAggregatesInput = {
    AND?: SpeciesImageScalarWhereWithAggregatesInput | SpeciesImageScalarWhereWithAggregatesInput[]
    OR?: SpeciesImageScalarWhereWithAggregatesInput[]
    NOT?: SpeciesImageScalarWhereWithAggregatesInput | SpeciesImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpeciesImage"> | string
    url?: StringWithAggregatesFilter<"SpeciesImage"> | string
    speciesId?: StringWithAggregatesFilter<"SpeciesImage"> | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    zone?: EnumZoneTypeFilter<"Location"> | $Enums.ZoneType
    table?: EnumTableTypeFilter<"Location"> | $Enums.TableType
    plants?: PlantListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    zone?: SortOrder
    table?: SortOrder
    plants?: PlantOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    zone?: EnumZoneTypeFilter<"Location"> | $Enums.ZoneType
    table?: EnumTableTypeFilter<"Location"> | $Enums.TableType
    plants?: PlantListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    zone?: SortOrder
    table?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    zone?: EnumZoneTypeWithAggregatesFilter<"Location"> | $Enums.ZoneType
    table?: EnumTableTypeWithAggregatesFilter<"Location"> | $Enums.TableType
  }

  export type PlantWhereInput = {
    AND?: PlantWhereInput | PlantWhereInput[]
    OR?: PlantWhereInput[]
    NOT?: PlantWhereInput | PlantWhereInput[]
    id?: StringFilter<"Plant"> | string
    pottingDate?: DateTimeNullableFilter<"Plant"> | Date | string | null
    speciesId?: StringFilter<"Plant"> | string
    locationId?: StringNullableFilter<"Plant"> | string | null
    createdAt?: DateTimeFilter<"Plant"> | Date | string
    updatedAt?: DateTimeFilter<"Plant"> | Date | string
    species?: XOR<SpeciesScalarRelationFilter, SpeciesWhereInput>
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }

  export type PlantOrderByWithRelationInput = {
    id?: SortOrder
    pottingDate?: SortOrderInput | SortOrder
    speciesId?: SortOrder
    locationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    species?: SpeciesOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type PlantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlantWhereInput | PlantWhereInput[]
    OR?: PlantWhereInput[]
    NOT?: PlantWhereInput | PlantWhereInput[]
    pottingDate?: DateTimeNullableFilter<"Plant"> | Date | string | null
    speciesId?: StringFilter<"Plant"> | string
    locationId?: StringNullableFilter<"Plant"> | string | null
    createdAt?: DateTimeFilter<"Plant"> | Date | string
    updatedAt?: DateTimeFilter<"Plant"> | Date | string
    species?: XOR<SpeciesScalarRelationFilter, SpeciesWhereInput>
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }, "id">

  export type PlantOrderByWithAggregationInput = {
    id?: SortOrder
    pottingDate?: SortOrderInput | SortOrder
    speciesId?: SortOrder
    locationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlantCountOrderByAggregateInput
    _max?: PlantMaxOrderByAggregateInput
    _min?: PlantMinOrderByAggregateInput
  }

  export type PlantScalarWhereWithAggregatesInput = {
    AND?: PlantScalarWhereWithAggregatesInput | PlantScalarWhereWithAggregatesInput[]
    OR?: PlantScalarWhereWithAggregatesInput[]
    NOT?: PlantScalarWhereWithAggregatesInput | PlantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plant"> | string
    pottingDate?: DateTimeNullableWithAggregatesFilter<"Plant"> | Date | string | null
    speciesId?: StringWithAggregatesFilter<"Plant"> | string
    locationId?: StringNullableWithAggregatesFilter<"Plant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Plant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plant"> | Date | string
  }

  export type AgrochemicalWhereInput = {
    AND?: AgrochemicalWhereInput | AgrochemicalWhereInput[]
    OR?: AgrochemicalWhereInput[]
    NOT?: AgrochemicalWhereInput | AgrochemicalWhereInput[]
    id?: StringFilter<"Agrochemical"> | string
    name?: StringFilter<"Agrochemical"> | string
    description?: StringFilter<"Agrochemical"> | string
    type?: EnumAgrochemicalTypeFilter<"Agrochemical"> | $Enums.AgrochemicalType
    porpose?: EnumAgrochemicalPorposeFilter<"Agrochemical"> | $Enums.AgrochemicalPorpose
    preparation?: StringFilter<"Agrochemical"> | string
    fertilizationCycles?: FertilizationCycleListRelationFilter
    fertilizationTasks?: FertilizationTaskListRelationFilter
    phytosanitaryCycles?: PhytosanitaryCycleListRelationFilter
    phytosanitaryTasks?: PhytosanitaryTaskListRelationFilter
  }

  export type AgrochemicalOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    porpose?: SortOrder
    preparation?: SortOrder
    fertilizationCycles?: FertilizationCycleOrderByRelationAggregateInput
    fertilizationTasks?: FertilizationTaskOrderByRelationAggregateInput
    phytosanitaryCycles?: PhytosanitaryCycleOrderByRelationAggregateInput
    phytosanitaryTasks?: PhytosanitaryTaskOrderByRelationAggregateInput
  }

  export type AgrochemicalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AgrochemicalWhereInput | AgrochemicalWhereInput[]
    OR?: AgrochemicalWhereInput[]
    NOT?: AgrochemicalWhereInput | AgrochemicalWhereInput[]
    description?: StringFilter<"Agrochemical"> | string
    type?: EnumAgrochemicalTypeFilter<"Agrochemical"> | $Enums.AgrochemicalType
    porpose?: EnumAgrochemicalPorposeFilter<"Agrochemical"> | $Enums.AgrochemicalPorpose
    preparation?: StringFilter<"Agrochemical"> | string
    fertilizationCycles?: FertilizationCycleListRelationFilter
    fertilizationTasks?: FertilizationTaskListRelationFilter
    phytosanitaryCycles?: PhytosanitaryCycleListRelationFilter
    phytosanitaryTasks?: PhytosanitaryTaskListRelationFilter
  }, "id" | "name">

  export type AgrochemicalOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    porpose?: SortOrder
    preparation?: SortOrder
    _count?: AgrochemicalCountOrderByAggregateInput
    _max?: AgrochemicalMaxOrderByAggregateInput
    _min?: AgrochemicalMinOrderByAggregateInput
  }

  export type AgrochemicalScalarWhereWithAggregatesInput = {
    AND?: AgrochemicalScalarWhereWithAggregatesInput | AgrochemicalScalarWhereWithAggregatesInput[]
    OR?: AgrochemicalScalarWhereWithAggregatesInput[]
    NOT?: AgrochemicalScalarWhereWithAggregatesInput | AgrochemicalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agrochemical"> | string
    name?: StringWithAggregatesFilter<"Agrochemical"> | string
    description?: StringWithAggregatesFilter<"Agrochemical"> | string
    type?: EnumAgrochemicalTypeWithAggregatesFilter<"Agrochemical"> | $Enums.AgrochemicalType
    porpose?: EnumAgrochemicalPorposeWithAggregatesFilter<"Agrochemical"> | $Enums.AgrochemicalPorpose
    preparation?: StringWithAggregatesFilter<"Agrochemical"> | string
  }

  export type FertilizationProgramWhereInput = {
    AND?: FertilizationProgramWhereInput | FertilizationProgramWhereInput[]
    OR?: FertilizationProgramWhereInput[]
    NOT?: FertilizationProgramWhereInput | FertilizationProgramWhereInput[]
    id?: StringFilter<"FertilizationProgram"> | string
    name?: StringFilter<"FertilizationProgram"> | string
    weeklyFrequency?: IntFilter<"FertilizationProgram"> | number
    productsCycle?: FertilizationCycleListRelationFilter
  }

  export type FertilizationProgramOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    weeklyFrequency?: SortOrder
    productsCycle?: FertilizationCycleOrderByRelationAggregateInput
  }

  export type FertilizationProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: FertilizationProgramWhereInput | FertilizationProgramWhereInput[]
    OR?: FertilizationProgramWhereInput[]
    NOT?: FertilizationProgramWhereInput | FertilizationProgramWhereInput[]
    weeklyFrequency?: IntFilter<"FertilizationProgram"> | number
    productsCycle?: FertilizationCycleListRelationFilter
  }, "id" | "name">

  export type FertilizationProgramOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    weeklyFrequency?: SortOrder
    _count?: FertilizationProgramCountOrderByAggregateInput
    _avg?: FertilizationProgramAvgOrderByAggregateInput
    _max?: FertilizationProgramMaxOrderByAggregateInput
    _min?: FertilizationProgramMinOrderByAggregateInput
    _sum?: FertilizationProgramSumOrderByAggregateInput
  }

  export type FertilizationProgramScalarWhereWithAggregatesInput = {
    AND?: FertilizationProgramScalarWhereWithAggregatesInput | FertilizationProgramScalarWhereWithAggregatesInput[]
    OR?: FertilizationProgramScalarWhereWithAggregatesInput[]
    NOT?: FertilizationProgramScalarWhereWithAggregatesInput | FertilizationProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FertilizationProgram"> | string
    name?: StringWithAggregatesFilter<"FertilizationProgram"> | string
    weeklyFrequency?: IntWithAggregatesFilter<"FertilizationProgram"> | number
  }

  export type FertilizationCycleWhereInput = {
    AND?: FertilizationCycleWhereInput | FertilizationCycleWhereInput[]
    OR?: FertilizationCycleWhereInput[]
    NOT?: FertilizationCycleWhereInput | FertilizationCycleWhereInput[]
    id?: StringFilter<"FertilizationCycle"> | string
    sequence?: IntFilter<"FertilizationCycle"> | number
    agrochemicalId?: StringFilter<"FertilizationCycle"> | string
    programId?: StringFilter<"FertilizationCycle"> | string
    agrochemical?: XOR<AgrochemicalScalarRelationFilter, AgrochemicalWhereInput>
    program?: XOR<FertilizationProgramScalarRelationFilter, FertilizationProgramWhereInput>
    tasks?: FertilizationTaskListRelationFilter
  }

  export type FertilizationCycleOrderByWithRelationInput = {
    id?: SortOrder
    sequence?: SortOrder
    agrochemicalId?: SortOrder
    programId?: SortOrder
    agrochemical?: AgrochemicalOrderByWithRelationInput
    program?: FertilizationProgramOrderByWithRelationInput
    tasks?: FertilizationTaskOrderByRelationAggregateInput
  }

  export type FertilizationCycleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FertilizationCycleWhereInput | FertilizationCycleWhereInput[]
    OR?: FertilizationCycleWhereInput[]
    NOT?: FertilizationCycleWhereInput | FertilizationCycleWhereInput[]
    sequence?: IntFilter<"FertilizationCycle"> | number
    agrochemicalId?: StringFilter<"FertilizationCycle"> | string
    programId?: StringFilter<"FertilizationCycle"> | string
    agrochemical?: XOR<AgrochemicalScalarRelationFilter, AgrochemicalWhereInput>
    program?: XOR<FertilizationProgramScalarRelationFilter, FertilizationProgramWhereInput>
    tasks?: FertilizationTaskListRelationFilter
  }, "id">

  export type FertilizationCycleOrderByWithAggregationInput = {
    id?: SortOrder
    sequence?: SortOrder
    agrochemicalId?: SortOrder
    programId?: SortOrder
    _count?: FertilizationCycleCountOrderByAggregateInput
    _avg?: FertilizationCycleAvgOrderByAggregateInput
    _max?: FertilizationCycleMaxOrderByAggregateInput
    _min?: FertilizationCycleMinOrderByAggregateInput
    _sum?: FertilizationCycleSumOrderByAggregateInput
  }

  export type FertilizationCycleScalarWhereWithAggregatesInput = {
    AND?: FertilizationCycleScalarWhereWithAggregatesInput | FertilizationCycleScalarWhereWithAggregatesInput[]
    OR?: FertilizationCycleScalarWhereWithAggregatesInput[]
    NOT?: FertilizationCycleScalarWhereWithAggregatesInput | FertilizationCycleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FertilizationCycle"> | string
    sequence?: IntWithAggregatesFilter<"FertilizationCycle"> | number
    agrochemicalId?: StringWithAggregatesFilter<"FertilizationCycle"> | string
    programId?: StringWithAggregatesFilter<"FertilizationCycle"> | string
  }

  export type FertilizationTaskWhereInput = {
    AND?: FertilizationTaskWhereInput | FertilizationTaskWhereInput[]
    OR?: FertilizationTaskWhereInput[]
    NOT?: FertilizationTaskWhereInput | FertilizationTaskWhereInput[]
    id?: StringFilter<"FertilizationTask"> | string
    scheduledDate?: DateTimeFilter<"FertilizationTask"> | Date | string
    executionDate?: DateTimeNullableFilter<"FertilizationTask"> | Date | string | null
    zones?: EnumZoneTypeNullableListFilter<"FertilizationTask">
    note?: StringNullableFilter<"FertilizationTask"> | string | null
    status?: EnumTaskStatusFilter<"FertilizationTask"> | $Enums.TaskStatus
    agrochemicalId?: StringFilter<"FertilizationTask"> | string
    productsCycleId?: StringNullableFilter<"FertilizationTask"> | string | null
    agrochemical?: XOR<AgrochemicalScalarRelationFilter, AgrochemicalWhereInput>
    productsCycle?: XOR<FertilizationCycleNullableScalarRelationFilter, FertilizationCycleWhereInput> | null
  }

  export type FertilizationTaskOrderByWithRelationInput = {
    id?: SortOrder
    scheduledDate?: SortOrder
    executionDate?: SortOrderInput | SortOrder
    zones?: SortOrder
    note?: SortOrderInput | SortOrder
    status?: SortOrder
    agrochemicalId?: SortOrder
    productsCycleId?: SortOrderInput | SortOrder
    agrochemical?: AgrochemicalOrderByWithRelationInput
    productsCycle?: FertilizationCycleOrderByWithRelationInput
  }

  export type FertilizationTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FertilizationTaskWhereInput | FertilizationTaskWhereInput[]
    OR?: FertilizationTaskWhereInput[]
    NOT?: FertilizationTaskWhereInput | FertilizationTaskWhereInput[]
    scheduledDate?: DateTimeFilter<"FertilizationTask"> | Date | string
    executionDate?: DateTimeNullableFilter<"FertilizationTask"> | Date | string | null
    zones?: EnumZoneTypeNullableListFilter<"FertilizationTask">
    note?: StringNullableFilter<"FertilizationTask"> | string | null
    status?: EnumTaskStatusFilter<"FertilizationTask"> | $Enums.TaskStatus
    agrochemicalId?: StringFilter<"FertilizationTask"> | string
    productsCycleId?: StringNullableFilter<"FertilizationTask"> | string | null
    agrochemical?: XOR<AgrochemicalScalarRelationFilter, AgrochemicalWhereInput>
    productsCycle?: XOR<FertilizationCycleNullableScalarRelationFilter, FertilizationCycleWhereInput> | null
  }, "id">

  export type FertilizationTaskOrderByWithAggregationInput = {
    id?: SortOrder
    scheduledDate?: SortOrder
    executionDate?: SortOrderInput | SortOrder
    zones?: SortOrder
    note?: SortOrderInput | SortOrder
    status?: SortOrder
    agrochemicalId?: SortOrder
    productsCycleId?: SortOrderInput | SortOrder
    _count?: FertilizationTaskCountOrderByAggregateInput
    _max?: FertilizationTaskMaxOrderByAggregateInput
    _min?: FertilizationTaskMinOrderByAggregateInput
  }

  export type FertilizationTaskScalarWhereWithAggregatesInput = {
    AND?: FertilizationTaskScalarWhereWithAggregatesInput | FertilizationTaskScalarWhereWithAggregatesInput[]
    OR?: FertilizationTaskScalarWhereWithAggregatesInput[]
    NOT?: FertilizationTaskScalarWhereWithAggregatesInput | FertilizationTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FertilizationTask"> | string
    scheduledDate?: DateTimeWithAggregatesFilter<"FertilizationTask"> | Date | string
    executionDate?: DateTimeNullableWithAggregatesFilter<"FertilizationTask"> | Date | string | null
    zones?: EnumZoneTypeNullableListFilter<"FertilizationTask">
    note?: StringNullableWithAggregatesFilter<"FertilizationTask"> | string | null
    status?: EnumTaskStatusWithAggregatesFilter<"FertilizationTask"> | $Enums.TaskStatus
    agrochemicalId?: StringWithAggregatesFilter<"FertilizationTask"> | string
    productsCycleId?: StringNullableWithAggregatesFilter<"FertilizationTask"> | string | null
  }

  export type PhytosanitaryProgramWhereInput = {
    AND?: PhytosanitaryProgramWhereInput | PhytosanitaryProgramWhereInput[]
    OR?: PhytosanitaryProgramWhereInput[]
    NOT?: PhytosanitaryProgramWhereInput | PhytosanitaryProgramWhereInput[]
    id?: StringFilter<"PhytosanitaryProgram"> | string
    name?: StringFilter<"PhytosanitaryProgram"> | string
    monthlyFrequency?: IntFilter<"PhytosanitaryProgram"> | number
    productsCycle?: PhytosanitaryCycleListRelationFilter
  }

  export type PhytosanitaryProgramOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    monthlyFrequency?: SortOrder
    productsCycle?: PhytosanitaryCycleOrderByRelationAggregateInput
  }

  export type PhytosanitaryProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PhytosanitaryProgramWhereInput | PhytosanitaryProgramWhereInput[]
    OR?: PhytosanitaryProgramWhereInput[]
    NOT?: PhytosanitaryProgramWhereInput | PhytosanitaryProgramWhereInput[]
    monthlyFrequency?: IntFilter<"PhytosanitaryProgram"> | number
    productsCycle?: PhytosanitaryCycleListRelationFilter
  }, "id" | "name">

  export type PhytosanitaryProgramOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    monthlyFrequency?: SortOrder
    _count?: PhytosanitaryProgramCountOrderByAggregateInput
    _avg?: PhytosanitaryProgramAvgOrderByAggregateInput
    _max?: PhytosanitaryProgramMaxOrderByAggregateInput
    _min?: PhytosanitaryProgramMinOrderByAggregateInput
    _sum?: PhytosanitaryProgramSumOrderByAggregateInput
  }

  export type PhytosanitaryProgramScalarWhereWithAggregatesInput = {
    AND?: PhytosanitaryProgramScalarWhereWithAggregatesInput | PhytosanitaryProgramScalarWhereWithAggregatesInput[]
    OR?: PhytosanitaryProgramScalarWhereWithAggregatesInput[]
    NOT?: PhytosanitaryProgramScalarWhereWithAggregatesInput | PhytosanitaryProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PhytosanitaryProgram"> | string
    name?: StringWithAggregatesFilter<"PhytosanitaryProgram"> | string
    monthlyFrequency?: IntWithAggregatesFilter<"PhytosanitaryProgram"> | number
  }

  export type PhytosanitaryCycleWhereInput = {
    AND?: PhytosanitaryCycleWhereInput | PhytosanitaryCycleWhereInput[]
    OR?: PhytosanitaryCycleWhereInput[]
    NOT?: PhytosanitaryCycleWhereInput | PhytosanitaryCycleWhereInput[]
    id?: StringFilter<"PhytosanitaryCycle"> | string
    sequence?: IntFilter<"PhytosanitaryCycle"> | number
    agrochemicalId?: StringFilter<"PhytosanitaryCycle"> | string
    programId?: StringFilter<"PhytosanitaryCycle"> | string
    agrochemical?: XOR<AgrochemicalScalarRelationFilter, AgrochemicalWhereInput>
    program?: XOR<PhytosanitaryProgramScalarRelationFilter, PhytosanitaryProgramWhereInput>
    tasks?: PhytosanitaryTaskListRelationFilter
  }

  export type PhytosanitaryCycleOrderByWithRelationInput = {
    id?: SortOrder
    sequence?: SortOrder
    agrochemicalId?: SortOrder
    programId?: SortOrder
    agrochemical?: AgrochemicalOrderByWithRelationInput
    program?: PhytosanitaryProgramOrderByWithRelationInput
    tasks?: PhytosanitaryTaskOrderByRelationAggregateInput
  }

  export type PhytosanitaryCycleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PhytosanitaryCycleWhereInput | PhytosanitaryCycleWhereInput[]
    OR?: PhytosanitaryCycleWhereInput[]
    NOT?: PhytosanitaryCycleWhereInput | PhytosanitaryCycleWhereInput[]
    sequence?: IntFilter<"PhytosanitaryCycle"> | number
    agrochemicalId?: StringFilter<"PhytosanitaryCycle"> | string
    programId?: StringFilter<"PhytosanitaryCycle"> | string
    agrochemical?: XOR<AgrochemicalScalarRelationFilter, AgrochemicalWhereInput>
    program?: XOR<PhytosanitaryProgramScalarRelationFilter, PhytosanitaryProgramWhereInput>
    tasks?: PhytosanitaryTaskListRelationFilter
  }, "id">

  export type PhytosanitaryCycleOrderByWithAggregationInput = {
    id?: SortOrder
    sequence?: SortOrder
    agrochemicalId?: SortOrder
    programId?: SortOrder
    _count?: PhytosanitaryCycleCountOrderByAggregateInput
    _avg?: PhytosanitaryCycleAvgOrderByAggregateInput
    _max?: PhytosanitaryCycleMaxOrderByAggregateInput
    _min?: PhytosanitaryCycleMinOrderByAggregateInput
    _sum?: PhytosanitaryCycleSumOrderByAggregateInput
  }

  export type PhytosanitaryCycleScalarWhereWithAggregatesInput = {
    AND?: PhytosanitaryCycleScalarWhereWithAggregatesInput | PhytosanitaryCycleScalarWhereWithAggregatesInput[]
    OR?: PhytosanitaryCycleScalarWhereWithAggregatesInput[]
    NOT?: PhytosanitaryCycleScalarWhereWithAggregatesInput | PhytosanitaryCycleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PhytosanitaryCycle"> | string
    sequence?: IntWithAggregatesFilter<"PhytosanitaryCycle"> | number
    agrochemicalId?: StringWithAggregatesFilter<"PhytosanitaryCycle"> | string
    programId?: StringWithAggregatesFilter<"PhytosanitaryCycle"> | string
  }

  export type PhytosanitaryTaskWhereInput = {
    AND?: PhytosanitaryTaskWhereInput | PhytosanitaryTaskWhereInput[]
    OR?: PhytosanitaryTaskWhereInput[]
    NOT?: PhytosanitaryTaskWhereInput | PhytosanitaryTaskWhereInput[]
    id?: StringFilter<"PhytosanitaryTask"> | string
    scheduledDate?: DateTimeFilter<"PhytosanitaryTask"> | Date | string
    executionDate?: DateTimeNullableFilter<"PhytosanitaryTask"> | Date | string | null
    zones?: EnumZoneTypeNullableListFilter<"PhytosanitaryTask">
    note?: StringNullableFilter<"PhytosanitaryTask"> | string | null
    status?: EnumTaskStatusFilter<"PhytosanitaryTask"> | $Enums.TaskStatus
    agrochemicalId?: StringFilter<"PhytosanitaryTask"> | string
    productsCycleId?: StringNullableFilter<"PhytosanitaryTask"> | string | null
    agrochemical?: XOR<AgrochemicalScalarRelationFilter, AgrochemicalWhereInput>
    productsCycle?: XOR<PhytosanitaryCycleNullableScalarRelationFilter, PhytosanitaryCycleWhereInput> | null
  }

  export type PhytosanitaryTaskOrderByWithRelationInput = {
    id?: SortOrder
    scheduledDate?: SortOrder
    executionDate?: SortOrderInput | SortOrder
    zones?: SortOrder
    note?: SortOrderInput | SortOrder
    status?: SortOrder
    agrochemicalId?: SortOrder
    productsCycleId?: SortOrderInput | SortOrder
    agrochemical?: AgrochemicalOrderByWithRelationInput
    productsCycle?: PhytosanitaryCycleOrderByWithRelationInput
  }

  export type PhytosanitaryTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PhytosanitaryTaskWhereInput | PhytosanitaryTaskWhereInput[]
    OR?: PhytosanitaryTaskWhereInput[]
    NOT?: PhytosanitaryTaskWhereInput | PhytosanitaryTaskWhereInput[]
    scheduledDate?: DateTimeFilter<"PhytosanitaryTask"> | Date | string
    executionDate?: DateTimeNullableFilter<"PhytosanitaryTask"> | Date | string | null
    zones?: EnumZoneTypeNullableListFilter<"PhytosanitaryTask">
    note?: StringNullableFilter<"PhytosanitaryTask"> | string | null
    status?: EnumTaskStatusFilter<"PhytosanitaryTask"> | $Enums.TaskStatus
    agrochemicalId?: StringFilter<"PhytosanitaryTask"> | string
    productsCycleId?: StringNullableFilter<"PhytosanitaryTask"> | string | null
    agrochemical?: XOR<AgrochemicalScalarRelationFilter, AgrochemicalWhereInput>
    productsCycle?: XOR<PhytosanitaryCycleNullableScalarRelationFilter, PhytosanitaryCycleWhereInput> | null
  }, "id">

  export type PhytosanitaryTaskOrderByWithAggregationInput = {
    id?: SortOrder
    scheduledDate?: SortOrder
    executionDate?: SortOrderInput | SortOrder
    zones?: SortOrder
    note?: SortOrderInput | SortOrder
    status?: SortOrder
    agrochemicalId?: SortOrder
    productsCycleId?: SortOrderInput | SortOrder
    _count?: PhytosanitaryTaskCountOrderByAggregateInput
    _max?: PhytosanitaryTaskMaxOrderByAggregateInput
    _min?: PhytosanitaryTaskMinOrderByAggregateInput
  }

  export type PhytosanitaryTaskScalarWhereWithAggregatesInput = {
    AND?: PhytosanitaryTaskScalarWhereWithAggregatesInput | PhytosanitaryTaskScalarWhereWithAggregatesInput[]
    OR?: PhytosanitaryTaskScalarWhereWithAggregatesInput[]
    NOT?: PhytosanitaryTaskScalarWhereWithAggregatesInput | PhytosanitaryTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PhytosanitaryTask"> | string
    scheduledDate?: DateTimeWithAggregatesFilter<"PhytosanitaryTask"> | Date | string
    executionDate?: DateTimeNullableWithAggregatesFilter<"PhytosanitaryTask"> | Date | string | null
    zones?: EnumZoneTypeNullableListFilter<"PhytosanitaryTask">
    note?: StringNullableWithAggregatesFilter<"PhytosanitaryTask"> | string | null
    status?: EnumTaskStatusWithAggregatesFilter<"PhytosanitaryTask"> | $Enums.TaskStatus
    agrochemicalId?: StringWithAggregatesFilter<"PhytosanitaryTask"> | string
    productsCycleId?: StringNullableWithAggregatesFilter<"PhytosanitaryTask"> | string | null
  }

  export type IrrigationProgramWhereInput = {
    AND?: IrrigationProgramWhereInput | IrrigationProgramWhereInput[]
    OR?: IrrigationProgramWhereInput[]
    NOT?: IrrigationProgramWhereInput | IrrigationProgramWhereInput[]
    id?: StringFilter<"IrrigationProgram"> | string
    name?: StringFilter<"IrrigationProgram"> | string
    trigger?: EnumTriggerTypeFilter<"IrrigationProgram"> | $Enums.TriggerType
    actuator?: EnumActuatorTypeFilter<"IrrigationProgram"> | $Enums.ActuatorType
    startTime?: StringFilter<"IrrigationProgram"> | string
    duration?: IntFilter<"IrrigationProgram"> | number
    zones?: EnumZoneTypeNullableListFilter<"IrrigationProgram">
    tasks?: IrrigationTaskListRelationFilter
  }

  export type IrrigationProgramOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    trigger?: SortOrder
    actuator?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    zones?: SortOrder
    tasks?: IrrigationTaskOrderByRelationAggregateInput
  }

  export type IrrigationProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: IrrigationProgramWhereInput | IrrigationProgramWhereInput[]
    OR?: IrrigationProgramWhereInput[]
    NOT?: IrrigationProgramWhereInput | IrrigationProgramWhereInput[]
    trigger?: EnumTriggerTypeFilter<"IrrigationProgram"> | $Enums.TriggerType
    actuator?: EnumActuatorTypeFilter<"IrrigationProgram"> | $Enums.ActuatorType
    startTime?: StringFilter<"IrrigationProgram"> | string
    duration?: IntFilter<"IrrigationProgram"> | number
    zones?: EnumZoneTypeNullableListFilter<"IrrigationProgram">
    tasks?: IrrigationTaskListRelationFilter
  }, "id" | "name">

  export type IrrigationProgramOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    trigger?: SortOrder
    actuator?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    zones?: SortOrder
    _count?: IrrigationProgramCountOrderByAggregateInput
    _avg?: IrrigationProgramAvgOrderByAggregateInput
    _max?: IrrigationProgramMaxOrderByAggregateInput
    _min?: IrrigationProgramMinOrderByAggregateInput
    _sum?: IrrigationProgramSumOrderByAggregateInput
  }

  export type IrrigationProgramScalarWhereWithAggregatesInput = {
    AND?: IrrigationProgramScalarWhereWithAggregatesInput | IrrigationProgramScalarWhereWithAggregatesInput[]
    OR?: IrrigationProgramScalarWhereWithAggregatesInput[]
    NOT?: IrrigationProgramScalarWhereWithAggregatesInput | IrrigationProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IrrigationProgram"> | string
    name?: StringWithAggregatesFilter<"IrrigationProgram"> | string
    trigger?: EnumTriggerTypeWithAggregatesFilter<"IrrigationProgram"> | $Enums.TriggerType
    actuator?: EnumActuatorTypeWithAggregatesFilter<"IrrigationProgram"> | $Enums.ActuatorType
    startTime?: StringWithAggregatesFilter<"IrrigationProgram"> | string
    duration?: IntWithAggregatesFilter<"IrrigationProgram"> | number
    zones?: EnumZoneTypeNullableListFilter<"IrrigationProgram">
  }

  export type IrrigationTaskWhereInput = {
    AND?: IrrigationTaskWhereInput | IrrigationTaskWhereInput[]
    OR?: IrrigationTaskWhereInput[]
    NOT?: IrrigationTaskWhereInput | IrrigationTaskWhereInput[]
    id?: StringFilter<"IrrigationTask"> | string
    scheduledDate?: DateTimeFilter<"IrrigationTask"> | Date | string
    executionDate?: DateTimeNullableFilter<"IrrigationTask"> | Date | string | null
    actuator?: EnumActuatorTypeFilter<"IrrigationTask"> | $Enums.ActuatorType
    duration?: IntFilter<"IrrigationTask"> | number
    zones?: EnumZoneTypeNullableListFilter<"IrrigationTask">
    status?: EnumTaskStatusFilter<"IrrigationTask"> | $Enums.TaskStatus
    programId?: StringNullableFilter<"IrrigationTask"> | string | null
    program?: XOR<IrrigationProgramNullableScalarRelationFilter, IrrigationProgramWhereInput> | null
  }

  export type IrrigationTaskOrderByWithRelationInput = {
    id?: SortOrder
    scheduledDate?: SortOrder
    executionDate?: SortOrderInput | SortOrder
    actuator?: SortOrder
    duration?: SortOrder
    zones?: SortOrder
    status?: SortOrder
    programId?: SortOrderInput | SortOrder
    program?: IrrigationProgramOrderByWithRelationInput
  }

  export type IrrigationTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IrrigationTaskWhereInput | IrrigationTaskWhereInput[]
    OR?: IrrigationTaskWhereInput[]
    NOT?: IrrigationTaskWhereInput | IrrigationTaskWhereInput[]
    scheduledDate?: DateTimeFilter<"IrrigationTask"> | Date | string
    executionDate?: DateTimeNullableFilter<"IrrigationTask"> | Date | string | null
    actuator?: EnumActuatorTypeFilter<"IrrigationTask"> | $Enums.ActuatorType
    duration?: IntFilter<"IrrigationTask"> | number
    zones?: EnumZoneTypeNullableListFilter<"IrrigationTask">
    status?: EnumTaskStatusFilter<"IrrigationTask"> | $Enums.TaskStatus
    programId?: StringNullableFilter<"IrrigationTask"> | string | null
    program?: XOR<IrrigationProgramNullableScalarRelationFilter, IrrigationProgramWhereInput> | null
  }, "id">

  export type IrrigationTaskOrderByWithAggregationInput = {
    id?: SortOrder
    scheduledDate?: SortOrder
    executionDate?: SortOrderInput | SortOrder
    actuator?: SortOrder
    duration?: SortOrder
    zones?: SortOrder
    status?: SortOrder
    programId?: SortOrderInput | SortOrder
    _count?: IrrigationTaskCountOrderByAggregateInput
    _avg?: IrrigationTaskAvgOrderByAggregateInput
    _max?: IrrigationTaskMaxOrderByAggregateInput
    _min?: IrrigationTaskMinOrderByAggregateInput
    _sum?: IrrigationTaskSumOrderByAggregateInput
  }

  export type IrrigationTaskScalarWhereWithAggregatesInput = {
    AND?: IrrigationTaskScalarWhereWithAggregatesInput | IrrigationTaskScalarWhereWithAggregatesInput[]
    OR?: IrrigationTaskScalarWhereWithAggregatesInput[]
    NOT?: IrrigationTaskScalarWhereWithAggregatesInput | IrrigationTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IrrigationTask"> | string
    scheduledDate?: DateTimeWithAggregatesFilter<"IrrigationTask"> | Date | string
    executionDate?: DateTimeNullableWithAggregatesFilter<"IrrigationTask"> | Date | string | null
    actuator?: EnumActuatorTypeWithAggregatesFilter<"IrrigationTask"> | $Enums.ActuatorType
    duration?: IntWithAggregatesFilter<"IrrigationTask"> | number
    zones?: EnumZoneTypeNullableListFilter<"IrrigationTask">
    status?: EnumTaskStatusWithAggregatesFilter<"IrrigationTask"> | $Enums.TaskStatus
    programId?: StringNullableWithAggregatesFilter<"IrrigationTask"> | string | null
  }

  export type SensorReadingWhereInput = {
    AND?: SensorReadingWhereInput | SensorReadingWhereInput[]
    OR?: SensorReadingWhereInput[]
    NOT?: SensorReadingWhereInput | SensorReadingWhereInput[]
    id?: StringFilter<"SensorReading"> | string
    zone?: EnumZoneTypeFilter<"SensorReading"> | $Enums.ZoneType
    sensorType?: EnumSensorTypeFilter<"SensorReading"> | $Enums.SensorType
    value?: FloatFilter<"SensorReading"> | number
    timestamp?: DateTimeFilter<"SensorReading"> | Date | string
  }

  export type SensorReadingOrderByWithRelationInput = {
    id?: SortOrder
    zone?: SortOrder
    sensorType?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
  }

  export type SensorReadingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SensorReadingWhereInput | SensorReadingWhereInput[]
    OR?: SensorReadingWhereInput[]
    NOT?: SensorReadingWhereInput | SensorReadingWhereInput[]
    zone?: EnumZoneTypeFilter<"SensorReading"> | $Enums.ZoneType
    sensorType?: EnumSensorTypeFilter<"SensorReading"> | $Enums.SensorType
    value?: FloatFilter<"SensorReading"> | number
    timestamp?: DateTimeFilter<"SensorReading"> | Date | string
  }, "id">

  export type SensorReadingOrderByWithAggregationInput = {
    id?: SortOrder
    zone?: SortOrder
    sensorType?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
    _count?: SensorReadingCountOrderByAggregateInput
    _avg?: SensorReadingAvgOrderByAggregateInput
    _max?: SensorReadingMaxOrderByAggregateInput
    _min?: SensorReadingMinOrderByAggregateInput
    _sum?: SensorReadingSumOrderByAggregateInput
  }

  export type SensorReadingScalarWhereWithAggregatesInput = {
    AND?: SensorReadingScalarWhereWithAggregatesInput | SensorReadingScalarWhereWithAggregatesInput[]
    OR?: SensorReadingScalarWhereWithAggregatesInput[]
    NOT?: SensorReadingScalarWhereWithAggregatesInput | SensorReadingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SensorReading"> | string
    zone?: EnumZoneTypeWithAggregatesFilter<"SensorReading"> | $Enums.ZoneType
    sensorType?: EnumSensorTypeWithAggregatesFilter<"SensorReading"> | $Enums.SensorType
    value?: FloatWithAggregatesFilter<"SensorReading"> | number
    timestamp?: DateTimeWithAggregatesFilter<"SensorReading"> | Date | string
  }

  export type StockCreateInput = {
    id?: string
    quantity?: number
    available?: boolean
    species?: SpeciesCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateInput = {
    id?: string
    quantity?: number
    available?: boolean
    species?: SpeciesUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    available?: BoolFieldUpdateOperationsInput | boolean
    species?: SpeciesUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    available?: BoolFieldUpdateOperationsInput | boolean
    species?: SpeciesUncheckedUpdateManyWithoutStockNestedInput
  }

  export type StockCreateManyInput = {
    id?: string
    quantity?: number
    available?: boolean
  }

  export type StockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    available?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    available?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GenusCreateInput = {
    id?: string
    name: string
    type: $Enums.PlantType
    species?: SpeciesCreateNestedManyWithoutGenusInput
  }

  export type GenusUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.PlantType
    species?: SpeciesUncheckedCreateNestedManyWithoutGenusInput
  }

  export type GenusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPlantTypeFieldUpdateOperationsInput | $Enums.PlantType
    species?: SpeciesUpdateManyWithoutGenusNestedInput
  }

  export type GenusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPlantTypeFieldUpdateOperationsInput | $Enums.PlantType
    species?: SpeciesUncheckedUpdateManyWithoutGenusNestedInput
  }

  export type GenusCreateManyInput = {
    id?: string
    name: string
    type: $Enums.PlantType
  }

  export type GenusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPlantTypeFieldUpdateOperationsInput | $Enums.PlantType
  }

  export type GenusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPlantTypeFieldUpdateOperationsInput | $Enums.PlantType
  }

  export type SpeciesCreateInput = {
    id?: string
    name: string
    price?: number
    slug: string
    description?: string | null
    genus: GenusCreateNestedOneWithoutSpeciesInput
    stock: StockCreateNestedOneWithoutSpeciesInput
    plants?: PlantCreateNestedManyWithoutSpeciesInput
    images?: SpeciesImageCreateNestedManyWithoutSpeciesInput
  }

  export type SpeciesUncheckedCreateInput = {
    id?: string
    name: string
    price?: number
    slug: string
    description?: string | null
    genusId: string
    stockId: string
    plants?: PlantUncheckedCreateNestedManyWithoutSpeciesInput
    images?: SpeciesImageUncheckedCreateNestedManyWithoutSpeciesInput
  }

  export type SpeciesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genus?: GenusUpdateOneRequiredWithoutSpeciesNestedInput
    stock?: StockUpdateOneRequiredWithoutSpeciesNestedInput
    plants?: PlantUpdateManyWithoutSpeciesNestedInput
    images?: SpeciesImageUpdateManyWithoutSpeciesNestedInput
  }

  export type SpeciesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genusId?: StringFieldUpdateOperationsInput | string
    stockId?: StringFieldUpdateOperationsInput | string
    plants?: PlantUncheckedUpdateManyWithoutSpeciesNestedInput
    images?: SpeciesImageUncheckedUpdateManyWithoutSpeciesNestedInput
  }

  export type SpeciesCreateManyInput = {
    id?: string
    name: string
    price?: number
    slug: string
    description?: string | null
    genusId: string
    stockId: string
  }

  export type SpeciesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpeciesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genusId?: StringFieldUpdateOperationsInput | string
    stockId?: StringFieldUpdateOperationsInput | string
  }

  export type SpeciesImageCreateInput = {
    id?: string
    url: string
    species: SpeciesCreateNestedOneWithoutImagesInput
  }

  export type SpeciesImageUncheckedCreateInput = {
    id?: string
    url: string
    speciesId: string
  }

  export type SpeciesImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    species?: SpeciesUpdateOneRequiredWithoutImagesNestedInput
  }

  export type SpeciesImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    speciesId?: StringFieldUpdateOperationsInput | string
  }

  export type SpeciesImageCreateManyInput = {
    id?: string
    url: string
    speciesId: string
  }

  export type SpeciesImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SpeciesImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    speciesId?: StringFieldUpdateOperationsInput | string
  }

  export type LocationCreateInput = {
    id?: string
    zone: $Enums.ZoneType
    table: $Enums.TableType
    plants?: PlantCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    zone: $Enums.ZoneType
    table: $Enums.TableType
    plants?: PlantUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zone?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    table?: EnumTableTypeFieldUpdateOperationsInput | $Enums.TableType
    plants?: PlantUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zone?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    table?: EnumTableTypeFieldUpdateOperationsInput | $Enums.TableType
    plants?: PlantUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    zone: $Enums.ZoneType
    table: $Enums.TableType
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    zone?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    table?: EnumTableTypeFieldUpdateOperationsInput | $Enums.TableType
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    zone?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    table?: EnumTableTypeFieldUpdateOperationsInput | $Enums.TableType
  }

  export type PlantCreateInput = {
    id?: string
    pottingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    species: SpeciesCreateNestedOneWithoutPlantsInput
    location?: LocationCreateNestedOneWithoutPlantsInput
  }

  export type PlantUncheckedCreateInput = {
    id?: string
    pottingDate?: Date | string | null
    speciesId: string
    locationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pottingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    species?: SpeciesUpdateOneRequiredWithoutPlantsNestedInput
    location?: LocationUpdateOneWithoutPlantsNestedInput
  }

  export type PlantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pottingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    speciesId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantCreateManyInput = {
    id?: string
    pottingDate?: Date | string | null
    speciesId: string
    locationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pottingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pottingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    speciesId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgrochemicalCreateInput = {
    id?: string
    name: string
    description: string
    type: $Enums.AgrochemicalType
    porpose: $Enums.AgrochemicalPorpose
    preparation: string
    fertilizationCycles?: FertilizationCycleCreateNestedManyWithoutAgrochemicalInput
    fertilizationTasks?: FertilizationTaskCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryCycles?: PhytosanitaryCycleCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryTasks?: PhytosanitaryTaskCreateNestedManyWithoutAgrochemicalInput
  }

  export type AgrochemicalUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    type: $Enums.AgrochemicalType
    porpose: $Enums.AgrochemicalPorpose
    preparation: string
    fertilizationCycles?: FertilizationCycleUncheckedCreateNestedManyWithoutAgrochemicalInput
    fertilizationTasks?: FertilizationTaskUncheckedCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryCycles?: PhytosanitaryCycleUncheckedCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryTasks?: PhytosanitaryTaskUncheckedCreateNestedManyWithoutAgrochemicalInput
  }

  export type AgrochemicalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgrochemicalTypeFieldUpdateOperationsInput | $Enums.AgrochemicalType
    porpose?: EnumAgrochemicalPorposeFieldUpdateOperationsInput | $Enums.AgrochemicalPorpose
    preparation?: StringFieldUpdateOperationsInput | string
    fertilizationCycles?: FertilizationCycleUpdateManyWithoutAgrochemicalNestedInput
    fertilizationTasks?: FertilizationTaskUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryCycles?: PhytosanitaryCycleUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryTasks?: PhytosanitaryTaskUpdateManyWithoutAgrochemicalNestedInput
  }

  export type AgrochemicalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgrochemicalTypeFieldUpdateOperationsInput | $Enums.AgrochemicalType
    porpose?: EnumAgrochemicalPorposeFieldUpdateOperationsInput | $Enums.AgrochemicalPorpose
    preparation?: StringFieldUpdateOperationsInput | string
    fertilizationCycles?: FertilizationCycleUncheckedUpdateManyWithoutAgrochemicalNestedInput
    fertilizationTasks?: FertilizationTaskUncheckedUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryCycles?: PhytosanitaryCycleUncheckedUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryTasks?: PhytosanitaryTaskUncheckedUpdateManyWithoutAgrochemicalNestedInput
  }

  export type AgrochemicalCreateManyInput = {
    id?: string
    name: string
    description: string
    type: $Enums.AgrochemicalType
    porpose: $Enums.AgrochemicalPorpose
    preparation: string
  }

  export type AgrochemicalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgrochemicalTypeFieldUpdateOperationsInput | $Enums.AgrochemicalType
    porpose?: EnumAgrochemicalPorposeFieldUpdateOperationsInput | $Enums.AgrochemicalPorpose
    preparation?: StringFieldUpdateOperationsInput | string
  }

  export type AgrochemicalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgrochemicalTypeFieldUpdateOperationsInput | $Enums.AgrochemicalType
    porpose?: EnumAgrochemicalPorposeFieldUpdateOperationsInput | $Enums.AgrochemicalPorpose
    preparation?: StringFieldUpdateOperationsInput | string
  }

  export type FertilizationProgramCreateInput = {
    id?: string
    name: string
    weeklyFrequency: number
    productsCycle?: FertilizationCycleCreateNestedManyWithoutProgramInput
  }

  export type FertilizationProgramUncheckedCreateInput = {
    id?: string
    name: string
    weeklyFrequency: number
    productsCycle?: FertilizationCycleUncheckedCreateNestedManyWithoutProgramInput
  }

  export type FertilizationProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weeklyFrequency?: IntFieldUpdateOperationsInput | number
    productsCycle?: FertilizationCycleUpdateManyWithoutProgramNestedInput
  }

  export type FertilizationProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weeklyFrequency?: IntFieldUpdateOperationsInput | number
    productsCycle?: FertilizationCycleUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type FertilizationProgramCreateManyInput = {
    id?: string
    name: string
    weeklyFrequency: number
  }

  export type FertilizationProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weeklyFrequency?: IntFieldUpdateOperationsInput | number
  }

  export type FertilizationProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weeklyFrequency?: IntFieldUpdateOperationsInput | number
  }

  export type FertilizationCycleCreateInput = {
    id?: string
    sequence: number
    agrochemical: AgrochemicalCreateNestedOneWithoutFertilizationCyclesInput
    program: FertilizationProgramCreateNestedOneWithoutProductsCycleInput
    tasks?: FertilizationTaskCreateNestedManyWithoutProductsCycleInput
  }

  export type FertilizationCycleUncheckedCreateInput = {
    id?: string
    sequence: number
    agrochemicalId: string
    programId: string
    tasks?: FertilizationTaskUncheckedCreateNestedManyWithoutProductsCycleInput
  }

  export type FertilizationCycleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemical?: AgrochemicalUpdateOneRequiredWithoutFertilizationCyclesNestedInput
    program?: FertilizationProgramUpdateOneRequiredWithoutProductsCycleNestedInput
    tasks?: FertilizationTaskUpdateManyWithoutProductsCycleNestedInput
  }

  export type FertilizationCycleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemicalId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tasks?: FertilizationTaskUncheckedUpdateManyWithoutProductsCycleNestedInput
  }

  export type FertilizationCycleCreateManyInput = {
    id?: string
    sequence: number
    agrochemicalId: string
    programId: string
  }

  export type FertilizationCycleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
  }

  export type FertilizationCycleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemicalId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
  }

  export type FertilizationTaskCreateInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: FertilizationTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    agrochemical: AgrochemicalCreateNestedOneWithoutFertilizationTasksInput
    productsCycle?: FertilizationCycleCreateNestedOneWithoutTasksInput
  }

  export type FertilizationTaskUncheckedCreateInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: FertilizationTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    agrochemicalId: string
    productsCycleId?: string | null
  }

  export type FertilizationTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: FertilizationTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    agrochemical?: AgrochemicalUpdateOneRequiredWithoutFertilizationTasksNestedInput
    productsCycle?: FertilizationCycleUpdateOneWithoutTasksNestedInput
  }

  export type FertilizationTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: FertilizationTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    agrochemicalId?: StringFieldUpdateOperationsInput | string
    productsCycleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FertilizationTaskCreateManyInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: FertilizationTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    agrochemicalId: string
    productsCycleId?: string | null
  }

  export type FertilizationTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: FertilizationTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
  }

  export type FertilizationTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: FertilizationTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    agrochemicalId?: StringFieldUpdateOperationsInput | string
    productsCycleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhytosanitaryProgramCreateInput = {
    id?: string
    name: string
    monthlyFrequency: number
    productsCycle?: PhytosanitaryCycleCreateNestedManyWithoutProgramInput
  }

  export type PhytosanitaryProgramUncheckedCreateInput = {
    id?: string
    name: string
    monthlyFrequency: number
    productsCycle?: PhytosanitaryCycleUncheckedCreateNestedManyWithoutProgramInput
  }

  export type PhytosanitaryProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    monthlyFrequency?: IntFieldUpdateOperationsInput | number
    productsCycle?: PhytosanitaryCycleUpdateManyWithoutProgramNestedInput
  }

  export type PhytosanitaryProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    monthlyFrequency?: IntFieldUpdateOperationsInput | number
    productsCycle?: PhytosanitaryCycleUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type PhytosanitaryProgramCreateManyInput = {
    id?: string
    name: string
    monthlyFrequency: number
  }

  export type PhytosanitaryProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    monthlyFrequency?: IntFieldUpdateOperationsInput | number
  }

  export type PhytosanitaryProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    monthlyFrequency?: IntFieldUpdateOperationsInput | number
  }

  export type PhytosanitaryCycleCreateInput = {
    id?: string
    sequence: number
    agrochemical: AgrochemicalCreateNestedOneWithoutPhytosanitaryCyclesInput
    program: PhytosanitaryProgramCreateNestedOneWithoutProductsCycleInput
    tasks?: PhytosanitaryTaskCreateNestedManyWithoutProductsCycleInput
  }

  export type PhytosanitaryCycleUncheckedCreateInput = {
    id?: string
    sequence: number
    agrochemicalId: string
    programId: string
    tasks?: PhytosanitaryTaskUncheckedCreateNestedManyWithoutProductsCycleInput
  }

  export type PhytosanitaryCycleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemical?: AgrochemicalUpdateOneRequiredWithoutPhytosanitaryCyclesNestedInput
    program?: PhytosanitaryProgramUpdateOneRequiredWithoutProductsCycleNestedInput
    tasks?: PhytosanitaryTaskUpdateManyWithoutProductsCycleNestedInput
  }

  export type PhytosanitaryCycleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemicalId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tasks?: PhytosanitaryTaskUncheckedUpdateManyWithoutProductsCycleNestedInput
  }

  export type PhytosanitaryCycleCreateManyInput = {
    id?: string
    sequence: number
    agrochemicalId: string
    programId: string
  }

  export type PhytosanitaryCycleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
  }

  export type PhytosanitaryCycleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemicalId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
  }

  export type PhytosanitaryTaskCreateInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: PhytosanitaryTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    agrochemical: AgrochemicalCreateNestedOneWithoutPhytosanitaryTasksInput
    productsCycle?: PhytosanitaryCycleCreateNestedOneWithoutTasksInput
  }

  export type PhytosanitaryTaskUncheckedCreateInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: PhytosanitaryTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    agrochemicalId: string
    productsCycleId?: string | null
  }

  export type PhytosanitaryTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: PhytosanitaryTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    agrochemical?: AgrochemicalUpdateOneRequiredWithoutPhytosanitaryTasksNestedInput
    productsCycle?: PhytosanitaryCycleUpdateOneWithoutTasksNestedInput
  }

  export type PhytosanitaryTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: PhytosanitaryTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    agrochemicalId?: StringFieldUpdateOperationsInput | string
    productsCycleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhytosanitaryTaskCreateManyInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: PhytosanitaryTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    agrochemicalId: string
    productsCycleId?: string | null
  }

  export type PhytosanitaryTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: PhytosanitaryTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
  }

  export type PhytosanitaryTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: PhytosanitaryTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    agrochemicalId?: StringFieldUpdateOperationsInput | string
    productsCycleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IrrigationProgramCreateInput = {
    id?: string
    name: string
    trigger?: $Enums.TriggerType
    actuator?: $Enums.ActuatorType
    startTime?: string
    duration?: number
    zones?: IrrigationProgramCreatezonesInput | $Enums.ZoneType[]
    tasks?: IrrigationTaskCreateNestedManyWithoutProgramInput
  }

  export type IrrigationProgramUncheckedCreateInput = {
    id?: string
    name: string
    trigger?: $Enums.TriggerType
    actuator?: $Enums.ActuatorType
    startTime?: string
    duration?: number
    zones?: IrrigationProgramCreatezonesInput | $Enums.ZoneType[]
    tasks?: IrrigationTaskUncheckedCreateNestedManyWithoutProgramInput
  }

  export type IrrigationProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    trigger?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    actuator?: EnumActuatorTypeFieldUpdateOperationsInput | $Enums.ActuatorType
    startTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    zones?: IrrigationProgramUpdatezonesInput | $Enums.ZoneType[]
    tasks?: IrrigationTaskUpdateManyWithoutProgramNestedInput
  }

  export type IrrigationProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    trigger?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    actuator?: EnumActuatorTypeFieldUpdateOperationsInput | $Enums.ActuatorType
    startTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    zones?: IrrigationProgramUpdatezonesInput | $Enums.ZoneType[]
    tasks?: IrrigationTaskUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type IrrigationProgramCreateManyInput = {
    id?: string
    name: string
    trigger?: $Enums.TriggerType
    actuator?: $Enums.ActuatorType
    startTime?: string
    duration?: number
    zones?: IrrigationProgramCreatezonesInput | $Enums.ZoneType[]
  }

  export type IrrigationProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    trigger?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    actuator?: EnumActuatorTypeFieldUpdateOperationsInput | $Enums.ActuatorType
    startTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    zones?: IrrigationProgramUpdatezonesInput | $Enums.ZoneType[]
  }

  export type IrrigationProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    trigger?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    actuator?: EnumActuatorTypeFieldUpdateOperationsInput | $Enums.ActuatorType
    startTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    zones?: IrrigationProgramUpdatezonesInput | $Enums.ZoneType[]
  }

  export type IrrigationTaskCreateInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    actuator: $Enums.ActuatorType
    duration: number
    zones?: IrrigationTaskCreatezonesInput | $Enums.ZoneType[]
    status?: $Enums.TaskStatus
    program?: IrrigationProgramCreateNestedOneWithoutTasksInput
  }

  export type IrrigationTaskUncheckedCreateInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    actuator: $Enums.ActuatorType
    duration: number
    zones?: IrrigationTaskCreatezonesInput | $Enums.ZoneType[]
    status?: $Enums.TaskStatus
    programId?: string | null
  }

  export type IrrigationTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actuator?: EnumActuatorTypeFieldUpdateOperationsInput | $Enums.ActuatorType
    duration?: IntFieldUpdateOperationsInput | number
    zones?: IrrigationTaskUpdatezonesInput | $Enums.ZoneType[]
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    program?: IrrigationProgramUpdateOneWithoutTasksNestedInput
  }

  export type IrrigationTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actuator?: EnumActuatorTypeFieldUpdateOperationsInput | $Enums.ActuatorType
    duration?: IntFieldUpdateOperationsInput | number
    zones?: IrrigationTaskUpdatezonesInput | $Enums.ZoneType[]
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    programId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IrrigationTaskCreateManyInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    actuator: $Enums.ActuatorType
    duration: number
    zones?: IrrigationTaskCreatezonesInput | $Enums.ZoneType[]
    status?: $Enums.TaskStatus
    programId?: string | null
  }

  export type IrrigationTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actuator?: EnumActuatorTypeFieldUpdateOperationsInput | $Enums.ActuatorType
    duration?: IntFieldUpdateOperationsInput | number
    zones?: IrrigationTaskUpdatezonesInput | $Enums.ZoneType[]
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
  }

  export type IrrigationTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actuator?: EnumActuatorTypeFieldUpdateOperationsInput | $Enums.ActuatorType
    duration?: IntFieldUpdateOperationsInput | number
    zones?: IrrigationTaskUpdatezonesInput | $Enums.ZoneType[]
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    programId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SensorReadingCreateInput = {
    id?: string
    zone: $Enums.ZoneType
    sensorType: $Enums.SensorType
    value: number
    timestamp?: Date | string
  }

  export type SensorReadingUncheckedCreateInput = {
    id?: string
    zone: $Enums.ZoneType
    sensorType: $Enums.SensorType
    value: number
    timestamp?: Date | string
  }

  export type SensorReadingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zone?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    sensorType?: EnumSensorTypeFieldUpdateOperationsInput | $Enums.SensorType
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SensorReadingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zone?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    sensorType?: EnumSensorTypeFieldUpdateOperationsInput | $Enums.SensorType
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SensorReadingCreateManyInput = {
    id?: string
    zone: $Enums.ZoneType
    sensorType: $Enums.SensorType
    value: number
    timestamp?: Date | string
  }

  export type SensorReadingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    zone?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    sensorType?: EnumSensorTypeFieldUpdateOperationsInput | $Enums.SensorType
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SensorReadingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    zone?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    sensorType?: EnumSensorTypeFieldUpdateOperationsInput | $Enums.SensorType
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SpeciesListRelationFilter = {
    every?: SpeciesWhereInput
    some?: SpeciesWhereInput
    none?: SpeciesWhereInput
  }

  export type SpeciesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    available?: SortOrder
  }

  export type StockAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    available?: SortOrder
  }

  export type StockMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    available?: SortOrder
  }

  export type StockSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumPlantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlantType | EnumPlantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlantType[] | ListEnumPlantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlantType[] | ListEnumPlantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlantTypeFilter<$PrismaModel> | $Enums.PlantType
  }

  export type GenusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type GenusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type GenusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type EnumPlantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlantType | EnumPlantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlantType[] | ListEnumPlantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlantType[] | ListEnumPlantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlantTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlantTypeFilter<$PrismaModel>
    _max?: NestedEnumPlantTypeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type GenusScalarRelationFilter = {
    is?: GenusWhereInput
    isNot?: GenusWhereInput
  }

  export type StockScalarRelationFilter = {
    is?: StockWhereInput
    isNot?: StockWhereInput
  }

  export type PlantListRelationFilter = {
    every?: PlantWhereInput
    some?: PlantWhereInput
    none?: PlantWhereInput
  }

  export type SpeciesImageListRelationFilter = {
    every?: SpeciesImageWhereInput
    some?: SpeciesImageWhereInput
    none?: SpeciesImageWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PlantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpeciesImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpeciesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    genusId?: SortOrder
    stockId?: SortOrder
  }

  export type SpeciesAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type SpeciesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    genusId?: SortOrder
    stockId?: SortOrder
  }

  export type SpeciesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    genusId?: SortOrder
    stockId?: SortOrder
  }

  export type SpeciesSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type SpeciesScalarRelationFilter = {
    is?: SpeciesWhereInput
    isNot?: SpeciesWhereInput
  }

  export type SpeciesImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    speciesId?: SortOrder
  }

  export type SpeciesImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    speciesId?: SortOrder
  }

  export type SpeciesImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    speciesId?: SortOrder
  }

  export type EnumZoneTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZoneTypeFilter<$PrismaModel> | $Enums.ZoneType
  }

  export type EnumTableTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TableType | EnumTableTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TableType[] | ListEnumTableTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TableType[] | ListEnumTableTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTableTypeFilter<$PrismaModel> | $Enums.TableType
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    zone?: SortOrder
    table?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    zone?: SortOrder
    table?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    zone?: SortOrder
    table?: SortOrder
  }

  export type EnumZoneTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZoneTypeWithAggregatesFilter<$PrismaModel> | $Enums.ZoneType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumZoneTypeFilter<$PrismaModel>
    _max?: NestedEnumZoneTypeFilter<$PrismaModel>
  }

  export type EnumTableTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TableType | EnumTableTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TableType[] | ListEnumTableTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TableType[] | ListEnumTableTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTableTypeWithAggregatesFilter<$PrismaModel> | $Enums.TableType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTableTypeFilter<$PrismaModel>
    _max?: NestedEnumTableTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type LocationNullableScalarRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type PlantCountOrderByAggregateInput = {
    id?: SortOrder
    pottingDate?: SortOrder
    speciesId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlantMaxOrderByAggregateInput = {
    id?: SortOrder
    pottingDate?: SortOrder
    speciesId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlantMinOrderByAggregateInput = {
    id?: SortOrder
    pottingDate?: SortOrder
    speciesId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumAgrochemicalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgrochemicalType | EnumAgrochemicalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgrochemicalType[] | ListEnumAgrochemicalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgrochemicalType[] | ListEnumAgrochemicalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgrochemicalTypeFilter<$PrismaModel> | $Enums.AgrochemicalType
  }

  export type EnumAgrochemicalPorposeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgrochemicalPorpose | EnumAgrochemicalPorposeFieldRefInput<$PrismaModel>
    in?: $Enums.AgrochemicalPorpose[] | ListEnumAgrochemicalPorposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgrochemicalPorpose[] | ListEnumAgrochemicalPorposeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgrochemicalPorposeFilter<$PrismaModel> | $Enums.AgrochemicalPorpose
  }

  export type FertilizationCycleListRelationFilter = {
    every?: FertilizationCycleWhereInput
    some?: FertilizationCycleWhereInput
    none?: FertilizationCycleWhereInput
  }

  export type FertilizationTaskListRelationFilter = {
    every?: FertilizationTaskWhereInput
    some?: FertilizationTaskWhereInput
    none?: FertilizationTaskWhereInput
  }

  export type PhytosanitaryCycleListRelationFilter = {
    every?: PhytosanitaryCycleWhereInput
    some?: PhytosanitaryCycleWhereInput
    none?: PhytosanitaryCycleWhereInput
  }

  export type PhytosanitaryTaskListRelationFilter = {
    every?: PhytosanitaryTaskWhereInput
    some?: PhytosanitaryTaskWhereInput
    none?: PhytosanitaryTaskWhereInput
  }

  export type FertilizationCycleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FertilizationTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhytosanitaryCycleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhytosanitaryTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgrochemicalCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    porpose?: SortOrder
    preparation?: SortOrder
  }

  export type AgrochemicalMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    porpose?: SortOrder
    preparation?: SortOrder
  }

  export type AgrochemicalMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    porpose?: SortOrder
    preparation?: SortOrder
  }

  export type EnumAgrochemicalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgrochemicalType | EnumAgrochemicalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgrochemicalType[] | ListEnumAgrochemicalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgrochemicalType[] | ListEnumAgrochemicalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgrochemicalTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgrochemicalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgrochemicalTypeFilter<$PrismaModel>
    _max?: NestedEnumAgrochemicalTypeFilter<$PrismaModel>
  }

  export type EnumAgrochemicalPorposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgrochemicalPorpose | EnumAgrochemicalPorposeFieldRefInput<$PrismaModel>
    in?: $Enums.AgrochemicalPorpose[] | ListEnumAgrochemicalPorposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgrochemicalPorpose[] | ListEnumAgrochemicalPorposeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgrochemicalPorposeWithAggregatesFilter<$PrismaModel> | $Enums.AgrochemicalPorpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgrochemicalPorposeFilter<$PrismaModel>
    _max?: NestedEnumAgrochemicalPorposeFilter<$PrismaModel>
  }

  export type FertilizationProgramCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weeklyFrequency?: SortOrder
  }

  export type FertilizationProgramAvgOrderByAggregateInput = {
    weeklyFrequency?: SortOrder
  }

  export type FertilizationProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weeklyFrequency?: SortOrder
  }

  export type FertilizationProgramMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weeklyFrequency?: SortOrder
  }

  export type FertilizationProgramSumOrderByAggregateInput = {
    weeklyFrequency?: SortOrder
  }

  export type AgrochemicalScalarRelationFilter = {
    is?: AgrochemicalWhereInput
    isNot?: AgrochemicalWhereInput
  }

  export type FertilizationProgramScalarRelationFilter = {
    is?: FertilizationProgramWhereInput
    isNot?: FertilizationProgramWhereInput
  }

  export type FertilizationCycleCountOrderByAggregateInput = {
    id?: SortOrder
    sequence?: SortOrder
    agrochemicalId?: SortOrder
    programId?: SortOrder
  }

  export type FertilizationCycleAvgOrderByAggregateInput = {
    sequence?: SortOrder
  }

  export type FertilizationCycleMaxOrderByAggregateInput = {
    id?: SortOrder
    sequence?: SortOrder
    agrochemicalId?: SortOrder
    programId?: SortOrder
  }

  export type FertilizationCycleMinOrderByAggregateInput = {
    id?: SortOrder
    sequence?: SortOrder
    agrochemicalId?: SortOrder
    programId?: SortOrder
  }

  export type FertilizationCycleSumOrderByAggregateInput = {
    sequence?: SortOrder
  }

  export type EnumZoneTypeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel> | null
    has?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type FertilizationCycleNullableScalarRelationFilter = {
    is?: FertilizationCycleWhereInput | null
    isNot?: FertilizationCycleWhereInput | null
  }

  export type FertilizationTaskCountOrderByAggregateInput = {
    id?: SortOrder
    scheduledDate?: SortOrder
    executionDate?: SortOrder
    zones?: SortOrder
    note?: SortOrder
    status?: SortOrder
    agrochemicalId?: SortOrder
    productsCycleId?: SortOrder
  }

  export type FertilizationTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    scheduledDate?: SortOrder
    executionDate?: SortOrder
    note?: SortOrder
    status?: SortOrder
    agrochemicalId?: SortOrder
    productsCycleId?: SortOrder
  }

  export type FertilizationTaskMinOrderByAggregateInput = {
    id?: SortOrder
    scheduledDate?: SortOrder
    executionDate?: SortOrder
    note?: SortOrder
    status?: SortOrder
    agrochemicalId?: SortOrder
    productsCycleId?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type PhytosanitaryProgramCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    monthlyFrequency?: SortOrder
  }

  export type PhytosanitaryProgramAvgOrderByAggregateInput = {
    monthlyFrequency?: SortOrder
  }

  export type PhytosanitaryProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    monthlyFrequency?: SortOrder
  }

  export type PhytosanitaryProgramMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    monthlyFrequency?: SortOrder
  }

  export type PhytosanitaryProgramSumOrderByAggregateInput = {
    monthlyFrequency?: SortOrder
  }

  export type PhytosanitaryProgramScalarRelationFilter = {
    is?: PhytosanitaryProgramWhereInput
    isNot?: PhytosanitaryProgramWhereInput
  }

  export type PhytosanitaryCycleCountOrderByAggregateInput = {
    id?: SortOrder
    sequence?: SortOrder
    agrochemicalId?: SortOrder
    programId?: SortOrder
  }

  export type PhytosanitaryCycleAvgOrderByAggregateInput = {
    sequence?: SortOrder
  }

  export type PhytosanitaryCycleMaxOrderByAggregateInput = {
    id?: SortOrder
    sequence?: SortOrder
    agrochemicalId?: SortOrder
    programId?: SortOrder
  }

  export type PhytosanitaryCycleMinOrderByAggregateInput = {
    id?: SortOrder
    sequence?: SortOrder
    agrochemicalId?: SortOrder
    programId?: SortOrder
  }

  export type PhytosanitaryCycleSumOrderByAggregateInput = {
    sequence?: SortOrder
  }

  export type PhytosanitaryCycleNullableScalarRelationFilter = {
    is?: PhytosanitaryCycleWhereInput | null
    isNot?: PhytosanitaryCycleWhereInput | null
  }

  export type PhytosanitaryTaskCountOrderByAggregateInput = {
    id?: SortOrder
    scheduledDate?: SortOrder
    executionDate?: SortOrder
    zones?: SortOrder
    note?: SortOrder
    status?: SortOrder
    agrochemicalId?: SortOrder
    productsCycleId?: SortOrder
  }

  export type PhytosanitaryTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    scheduledDate?: SortOrder
    executionDate?: SortOrder
    note?: SortOrder
    status?: SortOrder
    agrochemicalId?: SortOrder
    productsCycleId?: SortOrder
  }

  export type PhytosanitaryTaskMinOrderByAggregateInput = {
    id?: SortOrder
    scheduledDate?: SortOrder
    executionDate?: SortOrder
    note?: SortOrder
    status?: SortOrder
    agrochemicalId?: SortOrder
    productsCycleId?: SortOrder
  }

  export type EnumTriggerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypeFilter<$PrismaModel> | $Enums.TriggerType
  }

  export type EnumActuatorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActuatorType | EnumActuatorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActuatorType[] | ListEnumActuatorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActuatorType[] | ListEnumActuatorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActuatorTypeFilter<$PrismaModel> | $Enums.ActuatorType
  }

  export type IrrigationTaskListRelationFilter = {
    every?: IrrigationTaskWhereInput
    some?: IrrigationTaskWhereInput
    none?: IrrigationTaskWhereInput
  }

  export type IrrigationTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IrrigationProgramCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    trigger?: SortOrder
    actuator?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    zones?: SortOrder
  }

  export type IrrigationProgramAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type IrrigationProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    trigger?: SortOrder
    actuator?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
  }

  export type IrrigationProgramMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    trigger?: SortOrder
    actuator?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
  }

  export type IrrigationProgramSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumTriggerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypeWithAggregatesFilter<$PrismaModel> | $Enums.TriggerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTriggerTypeFilter<$PrismaModel>
    _max?: NestedEnumTriggerTypeFilter<$PrismaModel>
  }

  export type EnumActuatorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActuatorType | EnumActuatorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActuatorType[] | ListEnumActuatorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActuatorType[] | ListEnumActuatorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActuatorTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActuatorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActuatorTypeFilter<$PrismaModel>
    _max?: NestedEnumActuatorTypeFilter<$PrismaModel>
  }

  export type IrrigationProgramNullableScalarRelationFilter = {
    is?: IrrigationProgramWhereInput | null
    isNot?: IrrigationProgramWhereInput | null
  }

  export type IrrigationTaskCountOrderByAggregateInput = {
    id?: SortOrder
    scheduledDate?: SortOrder
    executionDate?: SortOrder
    actuator?: SortOrder
    duration?: SortOrder
    zones?: SortOrder
    status?: SortOrder
    programId?: SortOrder
  }

  export type IrrigationTaskAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type IrrigationTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    scheduledDate?: SortOrder
    executionDate?: SortOrder
    actuator?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    programId?: SortOrder
  }

  export type IrrigationTaskMinOrderByAggregateInput = {
    id?: SortOrder
    scheduledDate?: SortOrder
    executionDate?: SortOrder
    actuator?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    programId?: SortOrder
  }

  export type IrrigationTaskSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumSensorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SensorType | EnumSensorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSensorTypeFilter<$PrismaModel> | $Enums.SensorType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SensorReadingCountOrderByAggregateInput = {
    id?: SortOrder
    zone?: SortOrder
    sensorType?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
  }

  export type SensorReadingAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type SensorReadingMaxOrderByAggregateInput = {
    id?: SortOrder
    zone?: SortOrder
    sensorType?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
  }

  export type SensorReadingMinOrderByAggregateInput = {
    id?: SortOrder
    zone?: SortOrder
    sensorType?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
  }

  export type SensorReadingSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumSensorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SensorType | EnumSensorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSensorTypeWithAggregatesFilter<$PrismaModel> | $Enums.SensorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSensorTypeFilter<$PrismaModel>
    _max?: NestedEnumSensorTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SpeciesCreateNestedManyWithoutStockInput = {
    create?: XOR<SpeciesCreateWithoutStockInput, SpeciesUncheckedCreateWithoutStockInput> | SpeciesCreateWithoutStockInput[] | SpeciesUncheckedCreateWithoutStockInput[]
    connectOrCreate?: SpeciesCreateOrConnectWithoutStockInput | SpeciesCreateOrConnectWithoutStockInput[]
    createMany?: SpeciesCreateManyStockInputEnvelope
    connect?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
  }

  export type SpeciesUncheckedCreateNestedManyWithoutStockInput = {
    create?: XOR<SpeciesCreateWithoutStockInput, SpeciesUncheckedCreateWithoutStockInput> | SpeciesCreateWithoutStockInput[] | SpeciesUncheckedCreateWithoutStockInput[]
    connectOrCreate?: SpeciesCreateOrConnectWithoutStockInput | SpeciesCreateOrConnectWithoutStockInput[]
    createMany?: SpeciesCreateManyStockInputEnvelope
    connect?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SpeciesUpdateManyWithoutStockNestedInput = {
    create?: XOR<SpeciesCreateWithoutStockInput, SpeciesUncheckedCreateWithoutStockInput> | SpeciesCreateWithoutStockInput[] | SpeciesUncheckedCreateWithoutStockInput[]
    connectOrCreate?: SpeciesCreateOrConnectWithoutStockInput | SpeciesCreateOrConnectWithoutStockInput[]
    upsert?: SpeciesUpsertWithWhereUniqueWithoutStockInput | SpeciesUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: SpeciesCreateManyStockInputEnvelope
    set?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    disconnect?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    delete?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    connect?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    update?: SpeciesUpdateWithWhereUniqueWithoutStockInput | SpeciesUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: SpeciesUpdateManyWithWhereWithoutStockInput | SpeciesUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: SpeciesScalarWhereInput | SpeciesScalarWhereInput[]
  }

  export type SpeciesUncheckedUpdateManyWithoutStockNestedInput = {
    create?: XOR<SpeciesCreateWithoutStockInput, SpeciesUncheckedCreateWithoutStockInput> | SpeciesCreateWithoutStockInput[] | SpeciesUncheckedCreateWithoutStockInput[]
    connectOrCreate?: SpeciesCreateOrConnectWithoutStockInput | SpeciesCreateOrConnectWithoutStockInput[]
    upsert?: SpeciesUpsertWithWhereUniqueWithoutStockInput | SpeciesUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: SpeciesCreateManyStockInputEnvelope
    set?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    disconnect?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    delete?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    connect?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    update?: SpeciesUpdateWithWhereUniqueWithoutStockInput | SpeciesUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: SpeciesUpdateManyWithWhereWithoutStockInput | SpeciesUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: SpeciesScalarWhereInput | SpeciesScalarWhereInput[]
  }

  export type SpeciesCreateNestedManyWithoutGenusInput = {
    create?: XOR<SpeciesCreateWithoutGenusInput, SpeciesUncheckedCreateWithoutGenusInput> | SpeciesCreateWithoutGenusInput[] | SpeciesUncheckedCreateWithoutGenusInput[]
    connectOrCreate?: SpeciesCreateOrConnectWithoutGenusInput | SpeciesCreateOrConnectWithoutGenusInput[]
    createMany?: SpeciesCreateManyGenusInputEnvelope
    connect?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
  }

  export type SpeciesUncheckedCreateNestedManyWithoutGenusInput = {
    create?: XOR<SpeciesCreateWithoutGenusInput, SpeciesUncheckedCreateWithoutGenusInput> | SpeciesCreateWithoutGenusInput[] | SpeciesUncheckedCreateWithoutGenusInput[]
    connectOrCreate?: SpeciesCreateOrConnectWithoutGenusInput | SpeciesCreateOrConnectWithoutGenusInput[]
    createMany?: SpeciesCreateManyGenusInputEnvelope
    connect?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
  }

  export type EnumPlantTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlantType
  }

  export type SpeciesUpdateManyWithoutGenusNestedInput = {
    create?: XOR<SpeciesCreateWithoutGenusInput, SpeciesUncheckedCreateWithoutGenusInput> | SpeciesCreateWithoutGenusInput[] | SpeciesUncheckedCreateWithoutGenusInput[]
    connectOrCreate?: SpeciesCreateOrConnectWithoutGenusInput | SpeciesCreateOrConnectWithoutGenusInput[]
    upsert?: SpeciesUpsertWithWhereUniqueWithoutGenusInput | SpeciesUpsertWithWhereUniqueWithoutGenusInput[]
    createMany?: SpeciesCreateManyGenusInputEnvelope
    set?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    disconnect?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    delete?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    connect?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    update?: SpeciesUpdateWithWhereUniqueWithoutGenusInput | SpeciesUpdateWithWhereUniqueWithoutGenusInput[]
    updateMany?: SpeciesUpdateManyWithWhereWithoutGenusInput | SpeciesUpdateManyWithWhereWithoutGenusInput[]
    deleteMany?: SpeciesScalarWhereInput | SpeciesScalarWhereInput[]
  }

  export type SpeciesUncheckedUpdateManyWithoutGenusNestedInput = {
    create?: XOR<SpeciesCreateWithoutGenusInput, SpeciesUncheckedCreateWithoutGenusInput> | SpeciesCreateWithoutGenusInput[] | SpeciesUncheckedCreateWithoutGenusInput[]
    connectOrCreate?: SpeciesCreateOrConnectWithoutGenusInput | SpeciesCreateOrConnectWithoutGenusInput[]
    upsert?: SpeciesUpsertWithWhereUniqueWithoutGenusInput | SpeciesUpsertWithWhereUniqueWithoutGenusInput[]
    createMany?: SpeciesCreateManyGenusInputEnvelope
    set?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    disconnect?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    delete?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    connect?: SpeciesWhereUniqueInput | SpeciesWhereUniqueInput[]
    update?: SpeciesUpdateWithWhereUniqueWithoutGenusInput | SpeciesUpdateWithWhereUniqueWithoutGenusInput[]
    updateMany?: SpeciesUpdateManyWithWhereWithoutGenusInput | SpeciesUpdateManyWithWhereWithoutGenusInput[]
    deleteMany?: SpeciesScalarWhereInput | SpeciesScalarWhereInput[]
  }

  export type GenusCreateNestedOneWithoutSpeciesInput = {
    create?: XOR<GenusCreateWithoutSpeciesInput, GenusUncheckedCreateWithoutSpeciesInput>
    connectOrCreate?: GenusCreateOrConnectWithoutSpeciesInput
    connect?: GenusWhereUniqueInput
  }

  export type StockCreateNestedOneWithoutSpeciesInput = {
    create?: XOR<StockCreateWithoutSpeciesInput, StockUncheckedCreateWithoutSpeciesInput>
    connectOrCreate?: StockCreateOrConnectWithoutSpeciesInput
    connect?: StockWhereUniqueInput
  }

  export type PlantCreateNestedManyWithoutSpeciesInput = {
    create?: XOR<PlantCreateWithoutSpeciesInput, PlantUncheckedCreateWithoutSpeciesInput> | PlantCreateWithoutSpeciesInput[] | PlantUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: PlantCreateOrConnectWithoutSpeciesInput | PlantCreateOrConnectWithoutSpeciesInput[]
    createMany?: PlantCreateManySpeciesInputEnvelope
    connect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
  }

  export type SpeciesImageCreateNestedManyWithoutSpeciesInput = {
    create?: XOR<SpeciesImageCreateWithoutSpeciesInput, SpeciesImageUncheckedCreateWithoutSpeciesInput> | SpeciesImageCreateWithoutSpeciesInput[] | SpeciesImageUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: SpeciesImageCreateOrConnectWithoutSpeciesInput | SpeciesImageCreateOrConnectWithoutSpeciesInput[]
    createMany?: SpeciesImageCreateManySpeciesInputEnvelope
    connect?: SpeciesImageWhereUniqueInput | SpeciesImageWhereUniqueInput[]
  }

  export type PlantUncheckedCreateNestedManyWithoutSpeciesInput = {
    create?: XOR<PlantCreateWithoutSpeciesInput, PlantUncheckedCreateWithoutSpeciesInput> | PlantCreateWithoutSpeciesInput[] | PlantUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: PlantCreateOrConnectWithoutSpeciesInput | PlantCreateOrConnectWithoutSpeciesInput[]
    createMany?: PlantCreateManySpeciesInputEnvelope
    connect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
  }

  export type SpeciesImageUncheckedCreateNestedManyWithoutSpeciesInput = {
    create?: XOR<SpeciesImageCreateWithoutSpeciesInput, SpeciesImageUncheckedCreateWithoutSpeciesInput> | SpeciesImageCreateWithoutSpeciesInput[] | SpeciesImageUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: SpeciesImageCreateOrConnectWithoutSpeciesInput | SpeciesImageCreateOrConnectWithoutSpeciesInput[]
    createMany?: SpeciesImageCreateManySpeciesInputEnvelope
    connect?: SpeciesImageWhereUniqueInput | SpeciesImageWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type GenusUpdateOneRequiredWithoutSpeciesNestedInput = {
    create?: XOR<GenusCreateWithoutSpeciesInput, GenusUncheckedCreateWithoutSpeciesInput>
    connectOrCreate?: GenusCreateOrConnectWithoutSpeciesInput
    upsert?: GenusUpsertWithoutSpeciesInput
    connect?: GenusWhereUniqueInput
    update?: XOR<XOR<GenusUpdateToOneWithWhereWithoutSpeciesInput, GenusUpdateWithoutSpeciesInput>, GenusUncheckedUpdateWithoutSpeciesInput>
  }

  export type StockUpdateOneRequiredWithoutSpeciesNestedInput = {
    create?: XOR<StockCreateWithoutSpeciesInput, StockUncheckedCreateWithoutSpeciesInput>
    connectOrCreate?: StockCreateOrConnectWithoutSpeciesInput
    upsert?: StockUpsertWithoutSpeciesInput
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutSpeciesInput, StockUpdateWithoutSpeciesInput>, StockUncheckedUpdateWithoutSpeciesInput>
  }

  export type PlantUpdateManyWithoutSpeciesNestedInput = {
    create?: XOR<PlantCreateWithoutSpeciesInput, PlantUncheckedCreateWithoutSpeciesInput> | PlantCreateWithoutSpeciesInput[] | PlantUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: PlantCreateOrConnectWithoutSpeciesInput | PlantCreateOrConnectWithoutSpeciesInput[]
    upsert?: PlantUpsertWithWhereUniqueWithoutSpeciesInput | PlantUpsertWithWhereUniqueWithoutSpeciesInput[]
    createMany?: PlantCreateManySpeciesInputEnvelope
    set?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    disconnect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    delete?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    connect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    update?: PlantUpdateWithWhereUniqueWithoutSpeciesInput | PlantUpdateWithWhereUniqueWithoutSpeciesInput[]
    updateMany?: PlantUpdateManyWithWhereWithoutSpeciesInput | PlantUpdateManyWithWhereWithoutSpeciesInput[]
    deleteMany?: PlantScalarWhereInput | PlantScalarWhereInput[]
  }

  export type SpeciesImageUpdateManyWithoutSpeciesNestedInput = {
    create?: XOR<SpeciesImageCreateWithoutSpeciesInput, SpeciesImageUncheckedCreateWithoutSpeciesInput> | SpeciesImageCreateWithoutSpeciesInput[] | SpeciesImageUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: SpeciesImageCreateOrConnectWithoutSpeciesInput | SpeciesImageCreateOrConnectWithoutSpeciesInput[]
    upsert?: SpeciesImageUpsertWithWhereUniqueWithoutSpeciesInput | SpeciesImageUpsertWithWhereUniqueWithoutSpeciesInput[]
    createMany?: SpeciesImageCreateManySpeciesInputEnvelope
    set?: SpeciesImageWhereUniqueInput | SpeciesImageWhereUniqueInput[]
    disconnect?: SpeciesImageWhereUniqueInput | SpeciesImageWhereUniqueInput[]
    delete?: SpeciesImageWhereUniqueInput | SpeciesImageWhereUniqueInput[]
    connect?: SpeciesImageWhereUniqueInput | SpeciesImageWhereUniqueInput[]
    update?: SpeciesImageUpdateWithWhereUniqueWithoutSpeciesInput | SpeciesImageUpdateWithWhereUniqueWithoutSpeciesInput[]
    updateMany?: SpeciesImageUpdateManyWithWhereWithoutSpeciesInput | SpeciesImageUpdateManyWithWhereWithoutSpeciesInput[]
    deleteMany?: SpeciesImageScalarWhereInput | SpeciesImageScalarWhereInput[]
  }

  export type PlantUncheckedUpdateManyWithoutSpeciesNestedInput = {
    create?: XOR<PlantCreateWithoutSpeciesInput, PlantUncheckedCreateWithoutSpeciesInput> | PlantCreateWithoutSpeciesInput[] | PlantUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: PlantCreateOrConnectWithoutSpeciesInput | PlantCreateOrConnectWithoutSpeciesInput[]
    upsert?: PlantUpsertWithWhereUniqueWithoutSpeciesInput | PlantUpsertWithWhereUniqueWithoutSpeciesInput[]
    createMany?: PlantCreateManySpeciesInputEnvelope
    set?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    disconnect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    delete?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    connect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    update?: PlantUpdateWithWhereUniqueWithoutSpeciesInput | PlantUpdateWithWhereUniqueWithoutSpeciesInput[]
    updateMany?: PlantUpdateManyWithWhereWithoutSpeciesInput | PlantUpdateManyWithWhereWithoutSpeciesInput[]
    deleteMany?: PlantScalarWhereInput | PlantScalarWhereInput[]
  }

  export type SpeciesImageUncheckedUpdateManyWithoutSpeciesNestedInput = {
    create?: XOR<SpeciesImageCreateWithoutSpeciesInput, SpeciesImageUncheckedCreateWithoutSpeciesInput> | SpeciesImageCreateWithoutSpeciesInput[] | SpeciesImageUncheckedCreateWithoutSpeciesInput[]
    connectOrCreate?: SpeciesImageCreateOrConnectWithoutSpeciesInput | SpeciesImageCreateOrConnectWithoutSpeciesInput[]
    upsert?: SpeciesImageUpsertWithWhereUniqueWithoutSpeciesInput | SpeciesImageUpsertWithWhereUniqueWithoutSpeciesInput[]
    createMany?: SpeciesImageCreateManySpeciesInputEnvelope
    set?: SpeciesImageWhereUniqueInput | SpeciesImageWhereUniqueInput[]
    disconnect?: SpeciesImageWhereUniqueInput | SpeciesImageWhereUniqueInput[]
    delete?: SpeciesImageWhereUniqueInput | SpeciesImageWhereUniqueInput[]
    connect?: SpeciesImageWhereUniqueInput | SpeciesImageWhereUniqueInput[]
    update?: SpeciesImageUpdateWithWhereUniqueWithoutSpeciesInput | SpeciesImageUpdateWithWhereUniqueWithoutSpeciesInput[]
    updateMany?: SpeciesImageUpdateManyWithWhereWithoutSpeciesInput | SpeciesImageUpdateManyWithWhereWithoutSpeciesInput[]
    deleteMany?: SpeciesImageScalarWhereInput | SpeciesImageScalarWhereInput[]
  }

  export type SpeciesCreateNestedOneWithoutImagesInput = {
    create?: XOR<SpeciesCreateWithoutImagesInput, SpeciesUncheckedCreateWithoutImagesInput>
    connectOrCreate?: SpeciesCreateOrConnectWithoutImagesInput
    connect?: SpeciesWhereUniqueInput
  }

  export type SpeciesUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<SpeciesCreateWithoutImagesInput, SpeciesUncheckedCreateWithoutImagesInput>
    connectOrCreate?: SpeciesCreateOrConnectWithoutImagesInput
    upsert?: SpeciesUpsertWithoutImagesInput
    connect?: SpeciesWhereUniqueInput
    update?: XOR<XOR<SpeciesUpdateToOneWithWhereWithoutImagesInput, SpeciesUpdateWithoutImagesInput>, SpeciesUncheckedUpdateWithoutImagesInput>
  }

  export type PlantCreateNestedManyWithoutLocationInput = {
    create?: XOR<PlantCreateWithoutLocationInput, PlantUncheckedCreateWithoutLocationInput> | PlantCreateWithoutLocationInput[] | PlantUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PlantCreateOrConnectWithoutLocationInput | PlantCreateOrConnectWithoutLocationInput[]
    createMany?: PlantCreateManyLocationInputEnvelope
    connect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
  }

  export type PlantUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<PlantCreateWithoutLocationInput, PlantUncheckedCreateWithoutLocationInput> | PlantCreateWithoutLocationInput[] | PlantUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PlantCreateOrConnectWithoutLocationInput | PlantCreateOrConnectWithoutLocationInput[]
    createMany?: PlantCreateManyLocationInputEnvelope
    connect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
  }

  export type EnumZoneTypeFieldUpdateOperationsInput = {
    set?: $Enums.ZoneType
  }

  export type EnumTableTypeFieldUpdateOperationsInput = {
    set?: $Enums.TableType
  }

  export type PlantUpdateManyWithoutLocationNestedInput = {
    create?: XOR<PlantCreateWithoutLocationInput, PlantUncheckedCreateWithoutLocationInput> | PlantCreateWithoutLocationInput[] | PlantUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PlantCreateOrConnectWithoutLocationInput | PlantCreateOrConnectWithoutLocationInput[]
    upsert?: PlantUpsertWithWhereUniqueWithoutLocationInput | PlantUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: PlantCreateManyLocationInputEnvelope
    set?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    disconnect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    delete?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    connect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    update?: PlantUpdateWithWhereUniqueWithoutLocationInput | PlantUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: PlantUpdateManyWithWhereWithoutLocationInput | PlantUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: PlantScalarWhereInput | PlantScalarWhereInput[]
  }

  export type PlantUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<PlantCreateWithoutLocationInput, PlantUncheckedCreateWithoutLocationInput> | PlantCreateWithoutLocationInput[] | PlantUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PlantCreateOrConnectWithoutLocationInput | PlantCreateOrConnectWithoutLocationInput[]
    upsert?: PlantUpsertWithWhereUniqueWithoutLocationInput | PlantUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: PlantCreateManyLocationInputEnvelope
    set?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    disconnect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    delete?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    connect?: PlantWhereUniqueInput | PlantWhereUniqueInput[]
    update?: PlantUpdateWithWhereUniqueWithoutLocationInput | PlantUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: PlantUpdateManyWithWhereWithoutLocationInput | PlantUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: PlantScalarWhereInput | PlantScalarWhereInput[]
  }

  export type SpeciesCreateNestedOneWithoutPlantsInput = {
    create?: XOR<SpeciesCreateWithoutPlantsInput, SpeciesUncheckedCreateWithoutPlantsInput>
    connectOrCreate?: SpeciesCreateOrConnectWithoutPlantsInput
    connect?: SpeciesWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutPlantsInput = {
    create?: XOR<LocationCreateWithoutPlantsInput, LocationUncheckedCreateWithoutPlantsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutPlantsInput
    connect?: LocationWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SpeciesUpdateOneRequiredWithoutPlantsNestedInput = {
    create?: XOR<SpeciesCreateWithoutPlantsInput, SpeciesUncheckedCreateWithoutPlantsInput>
    connectOrCreate?: SpeciesCreateOrConnectWithoutPlantsInput
    upsert?: SpeciesUpsertWithoutPlantsInput
    connect?: SpeciesWhereUniqueInput
    update?: XOR<XOR<SpeciesUpdateToOneWithWhereWithoutPlantsInput, SpeciesUpdateWithoutPlantsInput>, SpeciesUncheckedUpdateWithoutPlantsInput>
  }

  export type LocationUpdateOneWithoutPlantsNestedInput = {
    create?: XOR<LocationCreateWithoutPlantsInput, LocationUncheckedCreateWithoutPlantsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutPlantsInput
    upsert?: LocationUpsertWithoutPlantsInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutPlantsInput, LocationUpdateWithoutPlantsInput>, LocationUncheckedUpdateWithoutPlantsInput>
  }

  export type FertilizationCycleCreateNestedManyWithoutAgrochemicalInput = {
    create?: XOR<FertilizationCycleCreateWithoutAgrochemicalInput, FertilizationCycleUncheckedCreateWithoutAgrochemicalInput> | FertilizationCycleCreateWithoutAgrochemicalInput[] | FertilizationCycleUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: FertilizationCycleCreateOrConnectWithoutAgrochemicalInput | FertilizationCycleCreateOrConnectWithoutAgrochemicalInput[]
    createMany?: FertilizationCycleCreateManyAgrochemicalInputEnvelope
    connect?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
  }

  export type FertilizationTaskCreateNestedManyWithoutAgrochemicalInput = {
    create?: XOR<FertilizationTaskCreateWithoutAgrochemicalInput, FertilizationTaskUncheckedCreateWithoutAgrochemicalInput> | FertilizationTaskCreateWithoutAgrochemicalInput[] | FertilizationTaskUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: FertilizationTaskCreateOrConnectWithoutAgrochemicalInput | FertilizationTaskCreateOrConnectWithoutAgrochemicalInput[]
    createMany?: FertilizationTaskCreateManyAgrochemicalInputEnvelope
    connect?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
  }

  export type PhytosanitaryCycleCreateNestedManyWithoutAgrochemicalInput = {
    create?: XOR<PhytosanitaryCycleCreateWithoutAgrochemicalInput, PhytosanitaryCycleUncheckedCreateWithoutAgrochemicalInput> | PhytosanitaryCycleCreateWithoutAgrochemicalInput[] | PhytosanitaryCycleUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: PhytosanitaryCycleCreateOrConnectWithoutAgrochemicalInput | PhytosanitaryCycleCreateOrConnectWithoutAgrochemicalInput[]
    createMany?: PhytosanitaryCycleCreateManyAgrochemicalInputEnvelope
    connect?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
  }

  export type PhytosanitaryTaskCreateNestedManyWithoutAgrochemicalInput = {
    create?: XOR<PhytosanitaryTaskCreateWithoutAgrochemicalInput, PhytosanitaryTaskUncheckedCreateWithoutAgrochemicalInput> | PhytosanitaryTaskCreateWithoutAgrochemicalInput[] | PhytosanitaryTaskUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: PhytosanitaryTaskCreateOrConnectWithoutAgrochemicalInput | PhytosanitaryTaskCreateOrConnectWithoutAgrochemicalInput[]
    createMany?: PhytosanitaryTaskCreateManyAgrochemicalInputEnvelope
    connect?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
  }

  export type FertilizationCycleUncheckedCreateNestedManyWithoutAgrochemicalInput = {
    create?: XOR<FertilizationCycleCreateWithoutAgrochemicalInput, FertilizationCycleUncheckedCreateWithoutAgrochemicalInput> | FertilizationCycleCreateWithoutAgrochemicalInput[] | FertilizationCycleUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: FertilizationCycleCreateOrConnectWithoutAgrochemicalInput | FertilizationCycleCreateOrConnectWithoutAgrochemicalInput[]
    createMany?: FertilizationCycleCreateManyAgrochemicalInputEnvelope
    connect?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
  }

  export type FertilizationTaskUncheckedCreateNestedManyWithoutAgrochemicalInput = {
    create?: XOR<FertilizationTaskCreateWithoutAgrochemicalInput, FertilizationTaskUncheckedCreateWithoutAgrochemicalInput> | FertilizationTaskCreateWithoutAgrochemicalInput[] | FertilizationTaskUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: FertilizationTaskCreateOrConnectWithoutAgrochemicalInput | FertilizationTaskCreateOrConnectWithoutAgrochemicalInput[]
    createMany?: FertilizationTaskCreateManyAgrochemicalInputEnvelope
    connect?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
  }

  export type PhytosanitaryCycleUncheckedCreateNestedManyWithoutAgrochemicalInput = {
    create?: XOR<PhytosanitaryCycleCreateWithoutAgrochemicalInput, PhytosanitaryCycleUncheckedCreateWithoutAgrochemicalInput> | PhytosanitaryCycleCreateWithoutAgrochemicalInput[] | PhytosanitaryCycleUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: PhytosanitaryCycleCreateOrConnectWithoutAgrochemicalInput | PhytosanitaryCycleCreateOrConnectWithoutAgrochemicalInput[]
    createMany?: PhytosanitaryCycleCreateManyAgrochemicalInputEnvelope
    connect?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
  }

  export type PhytosanitaryTaskUncheckedCreateNestedManyWithoutAgrochemicalInput = {
    create?: XOR<PhytosanitaryTaskCreateWithoutAgrochemicalInput, PhytosanitaryTaskUncheckedCreateWithoutAgrochemicalInput> | PhytosanitaryTaskCreateWithoutAgrochemicalInput[] | PhytosanitaryTaskUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: PhytosanitaryTaskCreateOrConnectWithoutAgrochemicalInput | PhytosanitaryTaskCreateOrConnectWithoutAgrochemicalInput[]
    createMany?: PhytosanitaryTaskCreateManyAgrochemicalInputEnvelope
    connect?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
  }

  export type EnumAgrochemicalTypeFieldUpdateOperationsInput = {
    set?: $Enums.AgrochemicalType
  }

  export type EnumAgrochemicalPorposeFieldUpdateOperationsInput = {
    set?: $Enums.AgrochemicalPorpose
  }

  export type FertilizationCycleUpdateManyWithoutAgrochemicalNestedInput = {
    create?: XOR<FertilizationCycleCreateWithoutAgrochemicalInput, FertilizationCycleUncheckedCreateWithoutAgrochemicalInput> | FertilizationCycleCreateWithoutAgrochemicalInput[] | FertilizationCycleUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: FertilizationCycleCreateOrConnectWithoutAgrochemicalInput | FertilizationCycleCreateOrConnectWithoutAgrochemicalInput[]
    upsert?: FertilizationCycleUpsertWithWhereUniqueWithoutAgrochemicalInput | FertilizationCycleUpsertWithWhereUniqueWithoutAgrochemicalInput[]
    createMany?: FertilizationCycleCreateManyAgrochemicalInputEnvelope
    set?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    disconnect?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    delete?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    connect?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    update?: FertilizationCycleUpdateWithWhereUniqueWithoutAgrochemicalInput | FertilizationCycleUpdateWithWhereUniqueWithoutAgrochemicalInput[]
    updateMany?: FertilizationCycleUpdateManyWithWhereWithoutAgrochemicalInput | FertilizationCycleUpdateManyWithWhereWithoutAgrochemicalInput[]
    deleteMany?: FertilizationCycleScalarWhereInput | FertilizationCycleScalarWhereInput[]
  }

  export type FertilizationTaskUpdateManyWithoutAgrochemicalNestedInput = {
    create?: XOR<FertilizationTaskCreateWithoutAgrochemicalInput, FertilizationTaskUncheckedCreateWithoutAgrochemicalInput> | FertilizationTaskCreateWithoutAgrochemicalInput[] | FertilizationTaskUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: FertilizationTaskCreateOrConnectWithoutAgrochemicalInput | FertilizationTaskCreateOrConnectWithoutAgrochemicalInput[]
    upsert?: FertilizationTaskUpsertWithWhereUniqueWithoutAgrochemicalInput | FertilizationTaskUpsertWithWhereUniqueWithoutAgrochemicalInput[]
    createMany?: FertilizationTaskCreateManyAgrochemicalInputEnvelope
    set?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    disconnect?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    delete?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    connect?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    update?: FertilizationTaskUpdateWithWhereUniqueWithoutAgrochemicalInput | FertilizationTaskUpdateWithWhereUniqueWithoutAgrochemicalInput[]
    updateMany?: FertilizationTaskUpdateManyWithWhereWithoutAgrochemicalInput | FertilizationTaskUpdateManyWithWhereWithoutAgrochemicalInput[]
    deleteMany?: FertilizationTaskScalarWhereInput | FertilizationTaskScalarWhereInput[]
  }

  export type PhytosanitaryCycleUpdateManyWithoutAgrochemicalNestedInput = {
    create?: XOR<PhytosanitaryCycleCreateWithoutAgrochemicalInput, PhytosanitaryCycleUncheckedCreateWithoutAgrochemicalInput> | PhytosanitaryCycleCreateWithoutAgrochemicalInput[] | PhytosanitaryCycleUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: PhytosanitaryCycleCreateOrConnectWithoutAgrochemicalInput | PhytosanitaryCycleCreateOrConnectWithoutAgrochemicalInput[]
    upsert?: PhytosanitaryCycleUpsertWithWhereUniqueWithoutAgrochemicalInput | PhytosanitaryCycleUpsertWithWhereUniqueWithoutAgrochemicalInput[]
    createMany?: PhytosanitaryCycleCreateManyAgrochemicalInputEnvelope
    set?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    disconnect?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    delete?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    connect?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    update?: PhytosanitaryCycleUpdateWithWhereUniqueWithoutAgrochemicalInput | PhytosanitaryCycleUpdateWithWhereUniqueWithoutAgrochemicalInput[]
    updateMany?: PhytosanitaryCycleUpdateManyWithWhereWithoutAgrochemicalInput | PhytosanitaryCycleUpdateManyWithWhereWithoutAgrochemicalInput[]
    deleteMany?: PhytosanitaryCycleScalarWhereInput | PhytosanitaryCycleScalarWhereInput[]
  }

  export type PhytosanitaryTaskUpdateManyWithoutAgrochemicalNestedInput = {
    create?: XOR<PhytosanitaryTaskCreateWithoutAgrochemicalInput, PhytosanitaryTaskUncheckedCreateWithoutAgrochemicalInput> | PhytosanitaryTaskCreateWithoutAgrochemicalInput[] | PhytosanitaryTaskUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: PhytosanitaryTaskCreateOrConnectWithoutAgrochemicalInput | PhytosanitaryTaskCreateOrConnectWithoutAgrochemicalInput[]
    upsert?: PhytosanitaryTaskUpsertWithWhereUniqueWithoutAgrochemicalInput | PhytosanitaryTaskUpsertWithWhereUniqueWithoutAgrochemicalInput[]
    createMany?: PhytosanitaryTaskCreateManyAgrochemicalInputEnvelope
    set?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    disconnect?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    delete?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    connect?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    update?: PhytosanitaryTaskUpdateWithWhereUniqueWithoutAgrochemicalInput | PhytosanitaryTaskUpdateWithWhereUniqueWithoutAgrochemicalInput[]
    updateMany?: PhytosanitaryTaskUpdateManyWithWhereWithoutAgrochemicalInput | PhytosanitaryTaskUpdateManyWithWhereWithoutAgrochemicalInput[]
    deleteMany?: PhytosanitaryTaskScalarWhereInput | PhytosanitaryTaskScalarWhereInput[]
  }

  export type FertilizationCycleUncheckedUpdateManyWithoutAgrochemicalNestedInput = {
    create?: XOR<FertilizationCycleCreateWithoutAgrochemicalInput, FertilizationCycleUncheckedCreateWithoutAgrochemicalInput> | FertilizationCycleCreateWithoutAgrochemicalInput[] | FertilizationCycleUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: FertilizationCycleCreateOrConnectWithoutAgrochemicalInput | FertilizationCycleCreateOrConnectWithoutAgrochemicalInput[]
    upsert?: FertilizationCycleUpsertWithWhereUniqueWithoutAgrochemicalInput | FertilizationCycleUpsertWithWhereUniqueWithoutAgrochemicalInput[]
    createMany?: FertilizationCycleCreateManyAgrochemicalInputEnvelope
    set?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    disconnect?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    delete?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    connect?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    update?: FertilizationCycleUpdateWithWhereUniqueWithoutAgrochemicalInput | FertilizationCycleUpdateWithWhereUniqueWithoutAgrochemicalInput[]
    updateMany?: FertilizationCycleUpdateManyWithWhereWithoutAgrochemicalInput | FertilizationCycleUpdateManyWithWhereWithoutAgrochemicalInput[]
    deleteMany?: FertilizationCycleScalarWhereInput | FertilizationCycleScalarWhereInput[]
  }

  export type FertilizationTaskUncheckedUpdateManyWithoutAgrochemicalNestedInput = {
    create?: XOR<FertilizationTaskCreateWithoutAgrochemicalInput, FertilizationTaskUncheckedCreateWithoutAgrochemicalInput> | FertilizationTaskCreateWithoutAgrochemicalInput[] | FertilizationTaskUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: FertilizationTaskCreateOrConnectWithoutAgrochemicalInput | FertilizationTaskCreateOrConnectWithoutAgrochemicalInput[]
    upsert?: FertilizationTaskUpsertWithWhereUniqueWithoutAgrochemicalInput | FertilizationTaskUpsertWithWhereUniqueWithoutAgrochemicalInput[]
    createMany?: FertilizationTaskCreateManyAgrochemicalInputEnvelope
    set?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    disconnect?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    delete?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    connect?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    update?: FertilizationTaskUpdateWithWhereUniqueWithoutAgrochemicalInput | FertilizationTaskUpdateWithWhereUniqueWithoutAgrochemicalInput[]
    updateMany?: FertilizationTaskUpdateManyWithWhereWithoutAgrochemicalInput | FertilizationTaskUpdateManyWithWhereWithoutAgrochemicalInput[]
    deleteMany?: FertilizationTaskScalarWhereInput | FertilizationTaskScalarWhereInput[]
  }

  export type PhytosanitaryCycleUncheckedUpdateManyWithoutAgrochemicalNestedInput = {
    create?: XOR<PhytosanitaryCycleCreateWithoutAgrochemicalInput, PhytosanitaryCycleUncheckedCreateWithoutAgrochemicalInput> | PhytosanitaryCycleCreateWithoutAgrochemicalInput[] | PhytosanitaryCycleUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: PhytosanitaryCycleCreateOrConnectWithoutAgrochemicalInput | PhytosanitaryCycleCreateOrConnectWithoutAgrochemicalInput[]
    upsert?: PhytosanitaryCycleUpsertWithWhereUniqueWithoutAgrochemicalInput | PhytosanitaryCycleUpsertWithWhereUniqueWithoutAgrochemicalInput[]
    createMany?: PhytosanitaryCycleCreateManyAgrochemicalInputEnvelope
    set?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    disconnect?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    delete?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    connect?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    update?: PhytosanitaryCycleUpdateWithWhereUniqueWithoutAgrochemicalInput | PhytosanitaryCycleUpdateWithWhereUniqueWithoutAgrochemicalInput[]
    updateMany?: PhytosanitaryCycleUpdateManyWithWhereWithoutAgrochemicalInput | PhytosanitaryCycleUpdateManyWithWhereWithoutAgrochemicalInput[]
    deleteMany?: PhytosanitaryCycleScalarWhereInput | PhytosanitaryCycleScalarWhereInput[]
  }

  export type PhytosanitaryTaskUncheckedUpdateManyWithoutAgrochemicalNestedInput = {
    create?: XOR<PhytosanitaryTaskCreateWithoutAgrochemicalInput, PhytosanitaryTaskUncheckedCreateWithoutAgrochemicalInput> | PhytosanitaryTaskCreateWithoutAgrochemicalInput[] | PhytosanitaryTaskUncheckedCreateWithoutAgrochemicalInput[]
    connectOrCreate?: PhytosanitaryTaskCreateOrConnectWithoutAgrochemicalInput | PhytosanitaryTaskCreateOrConnectWithoutAgrochemicalInput[]
    upsert?: PhytosanitaryTaskUpsertWithWhereUniqueWithoutAgrochemicalInput | PhytosanitaryTaskUpsertWithWhereUniqueWithoutAgrochemicalInput[]
    createMany?: PhytosanitaryTaskCreateManyAgrochemicalInputEnvelope
    set?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    disconnect?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    delete?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    connect?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    update?: PhytosanitaryTaskUpdateWithWhereUniqueWithoutAgrochemicalInput | PhytosanitaryTaskUpdateWithWhereUniqueWithoutAgrochemicalInput[]
    updateMany?: PhytosanitaryTaskUpdateManyWithWhereWithoutAgrochemicalInput | PhytosanitaryTaskUpdateManyWithWhereWithoutAgrochemicalInput[]
    deleteMany?: PhytosanitaryTaskScalarWhereInput | PhytosanitaryTaskScalarWhereInput[]
  }

  export type FertilizationCycleCreateNestedManyWithoutProgramInput = {
    create?: XOR<FertilizationCycleCreateWithoutProgramInput, FertilizationCycleUncheckedCreateWithoutProgramInput> | FertilizationCycleCreateWithoutProgramInput[] | FertilizationCycleUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: FertilizationCycleCreateOrConnectWithoutProgramInput | FertilizationCycleCreateOrConnectWithoutProgramInput[]
    createMany?: FertilizationCycleCreateManyProgramInputEnvelope
    connect?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
  }

  export type FertilizationCycleUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<FertilizationCycleCreateWithoutProgramInput, FertilizationCycleUncheckedCreateWithoutProgramInput> | FertilizationCycleCreateWithoutProgramInput[] | FertilizationCycleUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: FertilizationCycleCreateOrConnectWithoutProgramInput | FertilizationCycleCreateOrConnectWithoutProgramInput[]
    createMany?: FertilizationCycleCreateManyProgramInputEnvelope
    connect?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
  }

  export type FertilizationCycleUpdateManyWithoutProgramNestedInput = {
    create?: XOR<FertilizationCycleCreateWithoutProgramInput, FertilizationCycleUncheckedCreateWithoutProgramInput> | FertilizationCycleCreateWithoutProgramInput[] | FertilizationCycleUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: FertilizationCycleCreateOrConnectWithoutProgramInput | FertilizationCycleCreateOrConnectWithoutProgramInput[]
    upsert?: FertilizationCycleUpsertWithWhereUniqueWithoutProgramInput | FertilizationCycleUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: FertilizationCycleCreateManyProgramInputEnvelope
    set?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    disconnect?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    delete?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    connect?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    update?: FertilizationCycleUpdateWithWhereUniqueWithoutProgramInput | FertilizationCycleUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: FertilizationCycleUpdateManyWithWhereWithoutProgramInput | FertilizationCycleUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: FertilizationCycleScalarWhereInput | FertilizationCycleScalarWhereInput[]
  }

  export type FertilizationCycleUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<FertilizationCycleCreateWithoutProgramInput, FertilizationCycleUncheckedCreateWithoutProgramInput> | FertilizationCycleCreateWithoutProgramInput[] | FertilizationCycleUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: FertilizationCycleCreateOrConnectWithoutProgramInput | FertilizationCycleCreateOrConnectWithoutProgramInput[]
    upsert?: FertilizationCycleUpsertWithWhereUniqueWithoutProgramInput | FertilizationCycleUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: FertilizationCycleCreateManyProgramInputEnvelope
    set?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    disconnect?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    delete?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    connect?: FertilizationCycleWhereUniqueInput | FertilizationCycleWhereUniqueInput[]
    update?: FertilizationCycleUpdateWithWhereUniqueWithoutProgramInput | FertilizationCycleUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: FertilizationCycleUpdateManyWithWhereWithoutProgramInput | FertilizationCycleUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: FertilizationCycleScalarWhereInput | FertilizationCycleScalarWhereInput[]
  }

  export type AgrochemicalCreateNestedOneWithoutFertilizationCyclesInput = {
    create?: XOR<AgrochemicalCreateWithoutFertilizationCyclesInput, AgrochemicalUncheckedCreateWithoutFertilizationCyclesInput>
    connectOrCreate?: AgrochemicalCreateOrConnectWithoutFertilizationCyclesInput
    connect?: AgrochemicalWhereUniqueInput
  }

  export type FertilizationProgramCreateNestedOneWithoutProductsCycleInput = {
    create?: XOR<FertilizationProgramCreateWithoutProductsCycleInput, FertilizationProgramUncheckedCreateWithoutProductsCycleInput>
    connectOrCreate?: FertilizationProgramCreateOrConnectWithoutProductsCycleInput
    connect?: FertilizationProgramWhereUniqueInput
  }

  export type FertilizationTaskCreateNestedManyWithoutProductsCycleInput = {
    create?: XOR<FertilizationTaskCreateWithoutProductsCycleInput, FertilizationTaskUncheckedCreateWithoutProductsCycleInput> | FertilizationTaskCreateWithoutProductsCycleInput[] | FertilizationTaskUncheckedCreateWithoutProductsCycleInput[]
    connectOrCreate?: FertilizationTaskCreateOrConnectWithoutProductsCycleInput | FertilizationTaskCreateOrConnectWithoutProductsCycleInput[]
    createMany?: FertilizationTaskCreateManyProductsCycleInputEnvelope
    connect?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
  }

  export type FertilizationTaskUncheckedCreateNestedManyWithoutProductsCycleInput = {
    create?: XOR<FertilizationTaskCreateWithoutProductsCycleInput, FertilizationTaskUncheckedCreateWithoutProductsCycleInput> | FertilizationTaskCreateWithoutProductsCycleInput[] | FertilizationTaskUncheckedCreateWithoutProductsCycleInput[]
    connectOrCreate?: FertilizationTaskCreateOrConnectWithoutProductsCycleInput | FertilizationTaskCreateOrConnectWithoutProductsCycleInput[]
    createMany?: FertilizationTaskCreateManyProductsCycleInputEnvelope
    connect?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
  }

  export type AgrochemicalUpdateOneRequiredWithoutFertilizationCyclesNestedInput = {
    create?: XOR<AgrochemicalCreateWithoutFertilizationCyclesInput, AgrochemicalUncheckedCreateWithoutFertilizationCyclesInput>
    connectOrCreate?: AgrochemicalCreateOrConnectWithoutFertilizationCyclesInput
    upsert?: AgrochemicalUpsertWithoutFertilizationCyclesInput
    connect?: AgrochemicalWhereUniqueInput
    update?: XOR<XOR<AgrochemicalUpdateToOneWithWhereWithoutFertilizationCyclesInput, AgrochemicalUpdateWithoutFertilizationCyclesInput>, AgrochemicalUncheckedUpdateWithoutFertilizationCyclesInput>
  }

  export type FertilizationProgramUpdateOneRequiredWithoutProductsCycleNestedInput = {
    create?: XOR<FertilizationProgramCreateWithoutProductsCycleInput, FertilizationProgramUncheckedCreateWithoutProductsCycleInput>
    connectOrCreate?: FertilizationProgramCreateOrConnectWithoutProductsCycleInput
    upsert?: FertilizationProgramUpsertWithoutProductsCycleInput
    connect?: FertilizationProgramWhereUniqueInput
    update?: XOR<XOR<FertilizationProgramUpdateToOneWithWhereWithoutProductsCycleInput, FertilizationProgramUpdateWithoutProductsCycleInput>, FertilizationProgramUncheckedUpdateWithoutProductsCycleInput>
  }

  export type FertilizationTaskUpdateManyWithoutProductsCycleNestedInput = {
    create?: XOR<FertilizationTaskCreateWithoutProductsCycleInput, FertilizationTaskUncheckedCreateWithoutProductsCycleInput> | FertilizationTaskCreateWithoutProductsCycleInput[] | FertilizationTaskUncheckedCreateWithoutProductsCycleInput[]
    connectOrCreate?: FertilizationTaskCreateOrConnectWithoutProductsCycleInput | FertilizationTaskCreateOrConnectWithoutProductsCycleInput[]
    upsert?: FertilizationTaskUpsertWithWhereUniqueWithoutProductsCycleInput | FertilizationTaskUpsertWithWhereUniqueWithoutProductsCycleInput[]
    createMany?: FertilizationTaskCreateManyProductsCycleInputEnvelope
    set?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    disconnect?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    delete?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    connect?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    update?: FertilizationTaskUpdateWithWhereUniqueWithoutProductsCycleInput | FertilizationTaskUpdateWithWhereUniqueWithoutProductsCycleInput[]
    updateMany?: FertilizationTaskUpdateManyWithWhereWithoutProductsCycleInput | FertilizationTaskUpdateManyWithWhereWithoutProductsCycleInput[]
    deleteMany?: FertilizationTaskScalarWhereInput | FertilizationTaskScalarWhereInput[]
  }

  export type FertilizationTaskUncheckedUpdateManyWithoutProductsCycleNestedInput = {
    create?: XOR<FertilizationTaskCreateWithoutProductsCycleInput, FertilizationTaskUncheckedCreateWithoutProductsCycleInput> | FertilizationTaskCreateWithoutProductsCycleInput[] | FertilizationTaskUncheckedCreateWithoutProductsCycleInput[]
    connectOrCreate?: FertilizationTaskCreateOrConnectWithoutProductsCycleInput | FertilizationTaskCreateOrConnectWithoutProductsCycleInput[]
    upsert?: FertilizationTaskUpsertWithWhereUniqueWithoutProductsCycleInput | FertilizationTaskUpsertWithWhereUniqueWithoutProductsCycleInput[]
    createMany?: FertilizationTaskCreateManyProductsCycleInputEnvelope
    set?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    disconnect?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    delete?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    connect?: FertilizationTaskWhereUniqueInput | FertilizationTaskWhereUniqueInput[]
    update?: FertilizationTaskUpdateWithWhereUniqueWithoutProductsCycleInput | FertilizationTaskUpdateWithWhereUniqueWithoutProductsCycleInput[]
    updateMany?: FertilizationTaskUpdateManyWithWhereWithoutProductsCycleInput | FertilizationTaskUpdateManyWithWhereWithoutProductsCycleInput[]
    deleteMany?: FertilizationTaskScalarWhereInput | FertilizationTaskScalarWhereInput[]
  }

  export type FertilizationTaskCreatezonesInput = {
    set: $Enums.ZoneType[]
  }

  export type AgrochemicalCreateNestedOneWithoutFertilizationTasksInput = {
    create?: XOR<AgrochemicalCreateWithoutFertilizationTasksInput, AgrochemicalUncheckedCreateWithoutFertilizationTasksInput>
    connectOrCreate?: AgrochemicalCreateOrConnectWithoutFertilizationTasksInput
    connect?: AgrochemicalWhereUniqueInput
  }

  export type FertilizationCycleCreateNestedOneWithoutTasksInput = {
    create?: XOR<FertilizationCycleCreateWithoutTasksInput, FertilizationCycleUncheckedCreateWithoutTasksInput>
    connectOrCreate?: FertilizationCycleCreateOrConnectWithoutTasksInput
    connect?: FertilizationCycleWhereUniqueInput
  }

  export type FertilizationTaskUpdatezonesInput = {
    set?: $Enums.ZoneType[]
    push?: $Enums.ZoneType | $Enums.ZoneType[]
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type AgrochemicalUpdateOneRequiredWithoutFertilizationTasksNestedInput = {
    create?: XOR<AgrochemicalCreateWithoutFertilizationTasksInput, AgrochemicalUncheckedCreateWithoutFertilizationTasksInput>
    connectOrCreate?: AgrochemicalCreateOrConnectWithoutFertilizationTasksInput
    upsert?: AgrochemicalUpsertWithoutFertilizationTasksInput
    connect?: AgrochemicalWhereUniqueInput
    update?: XOR<XOR<AgrochemicalUpdateToOneWithWhereWithoutFertilizationTasksInput, AgrochemicalUpdateWithoutFertilizationTasksInput>, AgrochemicalUncheckedUpdateWithoutFertilizationTasksInput>
  }

  export type FertilizationCycleUpdateOneWithoutTasksNestedInput = {
    create?: XOR<FertilizationCycleCreateWithoutTasksInput, FertilizationCycleUncheckedCreateWithoutTasksInput>
    connectOrCreate?: FertilizationCycleCreateOrConnectWithoutTasksInput
    upsert?: FertilizationCycleUpsertWithoutTasksInput
    disconnect?: FertilizationCycleWhereInput | boolean
    delete?: FertilizationCycleWhereInput | boolean
    connect?: FertilizationCycleWhereUniqueInput
    update?: XOR<XOR<FertilizationCycleUpdateToOneWithWhereWithoutTasksInput, FertilizationCycleUpdateWithoutTasksInput>, FertilizationCycleUncheckedUpdateWithoutTasksInput>
  }

  export type PhytosanitaryCycleCreateNestedManyWithoutProgramInput = {
    create?: XOR<PhytosanitaryCycleCreateWithoutProgramInput, PhytosanitaryCycleUncheckedCreateWithoutProgramInput> | PhytosanitaryCycleCreateWithoutProgramInput[] | PhytosanitaryCycleUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: PhytosanitaryCycleCreateOrConnectWithoutProgramInput | PhytosanitaryCycleCreateOrConnectWithoutProgramInput[]
    createMany?: PhytosanitaryCycleCreateManyProgramInputEnvelope
    connect?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
  }

  export type PhytosanitaryCycleUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<PhytosanitaryCycleCreateWithoutProgramInput, PhytosanitaryCycleUncheckedCreateWithoutProgramInput> | PhytosanitaryCycleCreateWithoutProgramInput[] | PhytosanitaryCycleUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: PhytosanitaryCycleCreateOrConnectWithoutProgramInput | PhytosanitaryCycleCreateOrConnectWithoutProgramInput[]
    createMany?: PhytosanitaryCycleCreateManyProgramInputEnvelope
    connect?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
  }

  export type PhytosanitaryCycleUpdateManyWithoutProgramNestedInput = {
    create?: XOR<PhytosanitaryCycleCreateWithoutProgramInput, PhytosanitaryCycleUncheckedCreateWithoutProgramInput> | PhytosanitaryCycleCreateWithoutProgramInput[] | PhytosanitaryCycleUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: PhytosanitaryCycleCreateOrConnectWithoutProgramInput | PhytosanitaryCycleCreateOrConnectWithoutProgramInput[]
    upsert?: PhytosanitaryCycleUpsertWithWhereUniqueWithoutProgramInput | PhytosanitaryCycleUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: PhytosanitaryCycleCreateManyProgramInputEnvelope
    set?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    disconnect?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    delete?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    connect?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    update?: PhytosanitaryCycleUpdateWithWhereUniqueWithoutProgramInput | PhytosanitaryCycleUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: PhytosanitaryCycleUpdateManyWithWhereWithoutProgramInput | PhytosanitaryCycleUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: PhytosanitaryCycleScalarWhereInput | PhytosanitaryCycleScalarWhereInput[]
  }

  export type PhytosanitaryCycleUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<PhytosanitaryCycleCreateWithoutProgramInput, PhytosanitaryCycleUncheckedCreateWithoutProgramInput> | PhytosanitaryCycleCreateWithoutProgramInput[] | PhytosanitaryCycleUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: PhytosanitaryCycleCreateOrConnectWithoutProgramInput | PhytosanitaryCycleCreateOrConnectWithoutProgramInput[]
    upsert?: PhytosanitaryCycleUpsertWithWhereUniqueWithoutProgramInput | PhytosanitaryCycleUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: PhytosanitaryCycleCreateManyProgramInputEnvelope
    set?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    disconnect?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    delete?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    connect?: PhytosanitaryCycleWhereUniqueInput | PhytosanitaryCycleWhereUniqueInput[]
    update?: PhytosanitaryCycleUpdateWithWhereUniqueWithoutProgramInput | PhytosanitaryCycleUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: PhytosanitaryCycleUpdateManyWithWhereWithoutProgramInput | PhytosanitaryCycleUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: PhytosanitaryCycleScalarWhereInput | PhytosanitaryCycleScalarWhereInput[]
  }

  export type AgrochemicalCreateNestedOneWithoutPhytosanitaryCyclesInput = {
    create?: XOR<AgrochemicalCreateWithoutPhytosanitaryCyclesInput, AgrochemicalUncheckedCreateWithoutPhytosanitaryCyclesInput>
    connectOrCreate?: AgrochemicalCreateOrConnectWithoutPhytosanitaryCyclesInput
    connect?: AgrochemicalWhereUniqueInput
  }

  export type PhytosanitaryProgramCreateNestedOneWithoutProductsCycleInput = {
    create?: XOR<PhytosanitaryProgramCreateWithoutProductsCycleInput, PhytosanitaryProgramUncheckedCreateWithoutProductsCycleInput>
    connectOrCreate?: PhytosanitaryProgramCreateOrConnectWithoutProductsCycleInput
    connect?: PhytosanitaryProgramWhereUniqueInput
  }

  export type PhytosanitaryTaskCreateNestedManyWithoutProductsCycleInput = {
    create?: XOR<PhytosanitaryTaskCreateWithoutProductsCycleInput, PhytosanitaryTaskUncheckedCreateWithoutProductsCycleInput> | PhytosanitaryTaskCreateWithoutProductsCycleInput[] | PhytosanitaryTaskUncheckedCreateWithoutProductsCycleInput[]
    connectOrCreate?: PhytosanitaryTaskCreateOrConnectWithoutProductsCycleInput | PhytosanitaryTaskCreateOrConnectWithoutProductsCycleInput[]
    createMany?: PhytosanitaryTaskCreateManyProductsCycleInputEnvelope
    connect?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
  }

  export type PhytosanitaryTaskUncheckedCreateNestedManyWithoutProductsCycleInput = {
    create?: XOR<PhytosanitaryTaskCreateWithoutProductsCycleInput, PhytosanitaryTaskUncheckedCreateWithoutProductsCycleInput> | PhytosanitaryTaskCreateWithoutProductsCycleInput[] | PhytosanitaryTaskUncheckedCreateWithoutProductsCycleInput[]
    connectOrCreate?: PhytosanitaryTaskCreateOrConnectWithoutProductsCycleInput | PhytosanitaryTaskCreateOrConnectWithoutProductsCycleInput[]
    createMany?: PhytosanitaryTaskCreateManyProductsCycleInputEnvelope
    connect?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
  }

  export type AgrochemicalUpdateOneRequiredWithoutPhytosanitaryCyclesNestedInput = {
    create?: XOR<AgrochemicalCreateWithoutPhytosanitaryCyclesInput, AgrochemicalUncheckedCreateWithoutPhytosanitaryCyclesInput>
    connectOrCreate?: AgrochemicalCreateOrConnectWithoutPhytosanitaryCyclesInput
    upsert?: AgrochemicalUpsertWithoutPhytosanitaryCyclesInput
    connect?: AgrochemicalWhereUniqueInput
    update?: XOR<XOR<AgrochemicalUpdateToOneWithWhereWithoutPhytosanitaryCyclesInput, AgrochemicalUpdateWithoutPhytosanitaryCyclesInput>, AgrochemicalUncheckedUpdateWithoutPhytosanitaryCyclesInput>
  }

  export type PhytosanitaryProgramUpdateOneRequiredWithoutProductsCycleNestedInput = {
    create?: XOR<PhytosanitaryProgramCreateWithoutProductsCycleInput, PhytosanitaryProgramUncheckedCreateWithoutProductsCycleInput>
    connectOrCreate?: PhytosanitaryProgramCreateOrConnectWithoutProductsCycleInput
    upsert?: PhytosanitaryProgramUpsertWithoutProductsCycleInput
    connect?: PhytosanitaryProgramWhereUniqueInput
    update?: XOR<XOR<PhytosanitaryProgramUpdateToOneWithWhereWithoutProductsCycleInput, PhytosanitaryProgramUpdateWithoutProductsCycleInput>, PhytosanitaryProgramUncheckedUpdateWithoutProductsCycleInput>
  }

  export type PhytosanitaryTaskUpdateManyWithoutProductsCycleNestedInput = {
    create?: XOR<PhytosanitaryTaskCreateWithoutProductsCycleInput, PhytosanitaryTaskUncheckedCreateWithoutProductsCycleInput> | PhytosanitaryTaskCreateWithoutProductsCycleInput[] | PhytosanitaryTaskUncheckedCreateWithoutProductsCycleInput[]
    connectOrCreate?: PhytosanitaryTaskCreateOrConnectWithoutProductsCycleInput | PhytosanitaryTaskCreateOrConnectWithoutProductsCycleInput[]
    upsert?: PhytosanitaryTaskUpsertWithWhereUniqueWithoutProductsCycleInput | PhytosanitaryTaskUpsertWithWhereUniqueWithoutProductsCycleInput[]
    createMany?: PhytosanitaryTaskCreateManyProductsCycleInputEnvelope
    set?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    disconnect?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    delete?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    connect?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    update?: PhytosanitaryTaskUpdateWithWhereUniqueWithoutProductsCycleInput | PhytosanitaryTaskUpdateWithWhereUniqueWithoutProductsCycleInput[]
    updateMany?: PhytosanitaryTaskUpdateManyWithWhereWithoutProductsCycleInput | PhytosanitaryTaskUpdateManyWithWhereWithoutProductsCycleInput[]
    deleteMany?: PhytosanitaryTaskScalarWhereInput | PhytosanitaryTaskScalarWhereInput[]
  }

  export type PhytosanitaryTaskUncheckedUpdateManyWithoutProductsCycleNestedInput = {
    create?: XOR<PhytosanitaryTaskCreateWithoutProductsCycleInput, PhytosanitaryTaskUncheckedCreateWithoutProductsCycleInput> | PhytosanitaryTaskCreateWithoutProductsCycleInput[] | PhytosanitaryTaskUncheckedCreateWithoutProductsCycleInput[]
    connectOrCreate?: PhytosanitaryTaskCreateOrConnectWithoutProductsCycleInput | PhytosanitaryTaskCreateOrConnectWithoutProductsCycleInput[]
    upsert?: PhytosanitaryTaskUpsertWithWhereUniqueWithoutProductsCycleInput | PhytosanitaryTaskUpsertWithWhereUniqueWithoutProductsCycleInput[]
    createMany?: PhytosanitaryTaskCreateManyProductsCycleInputEnvelope
    set?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    disconnect?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    delete?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    connect?: PhytosanitaryTaskWhereUniqueInput | PhytosanitaryTaskWhereUniqueInput[]
    update?: PhytosanitaryTaskUpdateWithWhereUniqueWithoutProductsCycleInput | PhytosanitaryTaskUpdateWithWhereUniqueWithoutProductsCycleInput[]
    updateMany?: PhytosanitaryTaskUpdateManyWithWhereWithoutProductsCycleInput | PhytosanitaryTaskUpdateManyWithWhereWithoutProductsCycleInput[]
    deleteMany?: PhytosanitaryTaskScalarWhereInput | PhytosanitaryTaskScalarWhereInput[]
  }

  export type PhytosanitaryTaskCreatezonesInput = {
    set: $Enums.ZoneType[]
  }

  export type AgrochemicalCreateNestedOneWithoutPhytosanitaryTasksInput = {
    create?: XOR<AgrochemicalCreateWithoutPhytosanitaryTasksInput, AgrochemicalUncheckedCreateWithoutPhytosanitaryTasksInput>
    connectOrCreate?: AgrochemicalCreateOrConnectWithoutPhytosanitaryTasksInput
    connect?: AgrochemicalWhereUniqueInput
  }

  export type PhytosanitaryCycleCreateNestedOneWithoutTasksInput = {
    create?: XOR<PhytosanitaryCycleCreateWithoutTasksInput, PhytosanitaryCycleUncheckedCreateWithoutTasksInput>
    connectOrCreate?: PhytosanitaryCycleCreateOrConnectWithoutTasksInput
    connect?: PhytosanitaryCycleWhereUniqueInput
  }

  export type PhytosanitaryTaskUpdatezonesInput = {
    set?: $Enums.ZoneType[]
    push?: $Enums.ZoneType | $Enums.ZoneType[]
  }

  export type AgrochemicalUpdateOneRequiredWithoutPhytosanitaryTasksNestedInput = {
    create?: XOR<AgrochemicalCreateWithoutPhytosanitaryTasksInput, AgrochemicalUncheckedCreateWithoutPhytosanitaryTasksInput>
    connectOrCreate?: AgrochemicalCreateOrConnectWithoutPhytosanitaryTasksInput
    upsert?: AgrochemicalUpsertWithoutPhytosanitaryTasksInput
    connect?: AgrochemicalWhereUniqueInput
    update?: XOR<XOR<AgrochemicalUpdateToOneWithWhereWithoutPhytosanitaryTasksInput, AgrochemicalUpdateWithoutPhytosanitaryTasksInput>, AgrochemicalUncheckedUpdateWithoutPhytosanitaryTasksInput>
  }

  export type PhytosanitaryCycleUpdateOneWithoutTasksNestedInput = {
    create?: XOR<PhytosanitaryCycleCreateWithoutTasksInput, PhytosanitaryCycleUncheckedCreateWithoutTasksInput>
    connectOrCreate?: PhytosanitaryCycleCreateOrConnectWithoutTasksInput
    upsert?: PhytosanitaryCycleUpsertWithoutTasksInput
    disconnect?: PhytosanitaryCycleWhereInput | boolean
    delete?: PhytosanitaryCycleWhereInput | boolean
    connect?: PhytosanitaryCycleWhereUniqueInput
    update?: XOR<XOR<PhytosanitaryCycleUpdateToOneWithWhereWithoutTasksInput, PhytosanitaryCycleUpdateWithoutTasksInput>, PhytosanitaryCycleUncheckedUpdateWithoutTasksInput>
  }

  export type IrrigationProgramCreatezonesInput = {
    set: $Enums.ZoneType[]
  }

  export type IrrigationTaskCreateNestedManyWithoutProgramInput = {
    create?: XOR<IrrigationTaskCreateWithoutProgramInput, IrrigationTaskUncheckedCreateWithoutProgramInput> | IrrigationTaskCreateWithoutProgramInput[] | IrrigationTaskUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: IrrigationTaskCreateOrConnectWithoutProgramInput | IrrigationTaskCreateOrConnectWithoutProgramInput[]
    createMany?: IrrigationTaskCreateManyProgramInputEnvelope
    connect?: IrrigationTaskWhereUniqueInput | IrrigationTaskWhereUniqueInput[]
  }

  export type IrrigationTaskUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<IrrigationTaskCreateWithoutProgramInput, IrrigationTaskUncheckedCreateWithoutProgramInput> | IrrigationTaskCreateWithoutProgramInput[] | IrrigationTaskUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: IrrigationTaskCreateOrConnectWithoutProgramInput | IrrigationTaskCreateOrConnectWithoutProgramInput[]
    createMany?: IrrigationTaskCreateManyProgramInputEnvelope
    connect?: IrrigationTaskWhereUniqueInput | IrrigationTaskWhereUniqueInput[]
  }

  export type EnumTriggerTypeFieldUpdateOperationsInput = {
    set?: $Enums.TriggerType
  }

  export type EnumActuatorTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActuatorType
  }

  export type IrrigationProgramUpdatezonesInput = {
    set?: $Enums.ZoneType[]
    push?: $Enums.ZoneType | $Enums.ZoneType[]
  }

  export type IrrigationTaskUpdateManyWithoutProgramNestedInput = {
    create?: XOR<IrrigationTaskCreateWithoutProgramInput, IrrigationTaskUncheckedCreateWithoutProgramInput> | IrrigationTaskCreateWithoutProgramInput[] | IrrigationTaskUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: IrrigationTaskCreateOrConnectWithoutProgramInput | IrrigationTaskCreateOrConnectWithoutProgramInput[]
    upsert?: IrrigationTaskUpsertWithWhereUniqueWithoutProgramInput | IrrigationTaskUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: IrrigationTaskCreateManyProgramInputEnvelope
    set?: IrrigationTaskWhereUniqueInput | IrrigationTaskWhereUniqueInput[]
    disconnect?: IrrigationTaskWhereUniqueInput | IrrigationTaskWhereUniqueInput[]
    delete?: IrrigationTaskWhereUniqueInput | IrrigationTaskWhereUniqueInput[]
    connect?: IrrigationTaskWhereUniqueInput | IrrigationTaskWhereUniqueInput[]
    update?: IrrigationTaskUpdateWithWhereUniqueWithoutProgramInput | IrrigationTaskUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: IrrigationTaskUpdateManyWithWhereWithoutProgramInput | IrrigationTaskUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: IrrigationTaskScalarWhereInput | IrrigationTaskScalarWhereInput[]
  }

  export type IrrigationTaskUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<IrrigationTaskCreateWithoutProgramInput, IrrigationTaskUncheckedCreateWithoutProgramInput> | IrrigationTaskCreateWithoutProgramInput[] | IrrigationTaskUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: IrrigationTaskCreateOrConnectWithoutProgramInput | IrrigationTaskCreateOrConnectWithoutProgramInput[]
    upsert?: IrrigationTaskUpsertWithWhereUniqueWithoutProgramInput | IrrigationTaskUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: IrrigationTaskCreateManyProgramInputEnvelope
    set?: IrrigationTaskWhereUniqueInput | IrrigationTaskWhereUniqueInput[]
    disconnect?: IrrigationTaskWhereUniqueInput | IrrigationTaskWhereUniqueInput[]
    delete?: IrrigationTaskWhereUniqueInput | IrrigationTaskWhereUniqueInput[]
    connect?: IrrigationTaskWhereUniqueInput | IrrigationTaskWhereUniqueInput[]
    update?: IrrigationTaskUpdateWithWhereUniqueWithoutProgramInput | IrrigationTaskUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: IrrigationTaskUpdateManyWithWhereWithoutProgramInput | IrrigationTaskUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: IrrigationTaskScalarWhereInput | IrrigationTaskScalarWhereInput[]
  }

  export type IrrigationTaskCreatezonesInput = {
    set: $Enums.ZoneType[]
  }

  export type IrrigationProgramCreateNestedOneWithoutTasksInput = {
    create?: XOR<IrrigationProgramCreateWithoutTasksInput, IrrigationProgramUncheckedCreateWithoutTasksInput>
    connectOrCreate?: IrrigationProgramCreateOrConnectWithoutTasksInput
    connect?: IrrigationProgramWhereUniqueInput
  }

  export type IrrigationTaskUpdatezonesInput = {
    set?: $Enums.ZoneType[]
    push?: $Enums.ZoneType | $Enums.ZoneType[]
  }

  export type IrrigationProgramUpdateOneWithoutTasksNestedInput = {
    create?: XOR<IrrigationProgramCreateWithoutTasksInput, IrrigationProgramUncheckedCreateWithoutTasksInput>
    connectOrCreate?: IrrigationProgramCreateOrConnectWithoutTasksInput
    upsert?: IrrigationProgramUpsertWithoutTasksInput
    disconnect?: IrrigationProgramWhereInput | boolean
    delete?: IrrigationProgramWhereInput | boolean
    connect?: IrrigationProgramWhereUniqueInput
    update?: XOR<XOR<IrrigationProgramUpdateToOneWithWhereWithoutTasksInput, IrrigationProgramUpdateWithoutTasksInput>, IrrigationProgramUncheckedUpdateWithoutTasksInput>
  }

  export type EnumSensorTypeFieldUpdateOperationsInput = {
    set?: $Enums.SensorType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumPlantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlantType | EnumPlantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlantType[] | ListEnumPlantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlantType[] | ListEnumPlantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlantTypeFilter<$PrismaModel> | $Enums.PlantType
  }

  export type NestedEnumPlantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlantType | EnumPlantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlantType[] | ListEnumPlantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlantType[] | ListEnumPlantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlantTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlantTypeFilter<$PrismaModel>
    _max?: NestedEnumPlantTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumZoneTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZoneTypeFilter<$PrismaModel> | $Enums.ZoneType
  }

  export type NestedEnumTableTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TableType | EnumTableTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TableType[] | ListEnumTableTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TableType[] | ListEnumTableTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTableTypeFilter<$PrismaModel> | $Enums.TableType
  }

  export type NestedEnumZoneTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ZoneType | EnumZoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZoneType[] | ListEnumZoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZoneTypeWithAggregatesFilter<$PrismaModel> | $Enums.ZoneType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumZoneTypeFilter<$PrismaModel>
    _max?: NestedEnumZoneTypeFilter<$PrismaModel>
  }

  export type NestedEnumTableTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TableType | EnumTableTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TableType[] | ListEnumTableTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TableType[] | ListEnumTableTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTableTypeWithAggregatesFilter<$PrismaModel> | $Enums.TableType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTableTypeFilter<$PrismaModel>
    _max?: NestedEnumTableTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAgrochemicalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgrochemicalType | EnumAgrochemicalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgrochemicalType[] | ListEnumAgrochemicalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgrochemicalType[] | ListEnumAgrochemicalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgrochemicalTypeFilter<$PrismaModel> | $Enums.AgrochemicalType
  }

  export type NestedEnumAgrochemicalPorposeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgrochemicalPorpose | EnumAgrochemicalPorposeFieldRefInput<$PrismaModel>
    in?: $Enums.AgrochemicalPorpose[] | ListEnumAgrochemicalPorposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgrochemicalPorpose[] | ListEnumAgrochemicalPorposeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgrochemicalPorposeFilter<$PrismaModel> | $Enums.AgrochemicalPorpose
  }

  export type NestedEnumAgrochemicalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgrochemicalType | EnumAgrochemicalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgrochemicalType[] | ListEnumAgrochemicalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgrochemicalType[] | ListEnumAgrochemicalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgrochemicalTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgrochemicalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgrochemicalTypeFilter<$PrismaModel>
    _max?: NestedEnumAgrochemicalTypeFilter<$PrismaModel>
  }

  export type NestedEnumAgrochemicalPorposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgrochemicalPorpose | EnumAgrochemicalPorposeFieldRefInput<$PrismaModel>
    in?: $Enums.AgrochemicalPorpose[] | ListEnumAgrochemicalPorposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgrochemicalPorpose[] | ListEnumAgrochemicalPorposeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgrochemicalPorposeWithAggregatesFilter<$PrismaModel> | $Enums.AgrochemicalPorpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgrochemicalPorposeFilter<$PrismaModel>
    _max?: NestedEnumAgrochemicalPorposeFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumTriggerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypeFilter<$PrismaModel> | $Enums.TriggerType
  }

  export type NestedEnumActuatorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActuatorType | EnumActuatorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActuatorType[] | ListEnumActuatorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActuatorType[] | ListEnumActuatorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActuatorTypeFilter<$PrismaModel> | $Enums.ActuatorType
  }

  export type NestedEnumTriggerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerType[] | ListEnumTriggerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypeWithAggregatesFilter<$PrismaModel> | $Enums.TriggerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTriggerTypeFilter<$PrismaModel>
    _max?: NestedEnumTriggerTypeFilter<$PrismaModel>
  }

  export type NestedEnumActuatorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActuatorType | EnumActuatorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActuatorType[] | ListEnumActuatorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActuatorType[] | ListEnumActuatorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActuatorTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActuatorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActuatorTypeFilter<$PrismaModel>
    _max?: NestedEnumActuatorTypeFilter<$PrismaModel>
  }

  export type NestedEnumSensorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SensorType | EnumSensorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSensorTypeFilter<$PrismaModel> | $Enums.SensorType
  }

  export type NestedEnumSensorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SensorType | EnumSensorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSensorTypeWithAggregatesFilter<$PrismaModel> | $Enums.SensorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSensorTypeFilter<$PrismaModel>
    _max?: NestedEnumSensorTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SpeciesCreateWithoutStockInput = {
    id?: string
    name: string
    price?: number
    slug: string
    description?: string | null
    genus: GenusCreateNestedOneWithoutSpeciesInput
    plants?: PlantCreateNestedManyWithoutSpeciesInput
    images?: SpeciesImageCreateNestedManyWithoutSpeciesInput
  }

  export type SpeciesUncheckedCreateWithoutStockInput = {
    id?: string
    name: string
    price?: number
    slug: string
    description?: string | null
    genusId: string
    plants?: PlantUncheckedCreateNestedManyWithoutSpeciesInput
    images?: SpeciesImageUncheckedCreateNestedManyWithoutSpeciesInput
  }

  export type SpeciesCreateOrConnectWithoutStockInput = {
    where: SpeciesWhereUniqueInput
    create: XOR<SpeciesCreateWithoutStockInput, SpeciesUncheckedCreateWithoutStockInput>
  }

  export type SpeciesCreateManyStockInputEnvelope = {
    data: SpeciesCreateManyStockInput | SpeciesCreateManyStockInput[]
    skipDuplicates?: boolean
  }

  export type SpeciesUpsertWithWhereUniqueWithoutStockInput = {
    where: SpeciesWhereUniqueInput
    update: XOR<SpeciesUpdateWithoutStockInput, SpeciesUncheckedUpdateWithoutStockInput>
    create: XOR<SpeciesCreateWithoutStockInput, SpeciesUncheckedCreateWithoutStockInput>
  }

  export type SpeciesUpdateWithWhereUniqueWithoutStockInput = {
    where: SpeciesWhereUniqueInput
    data: XOR<SpeciesUpdateWithoutStockInput, SpeciesUncheckedUpdateWithoutStockInput>
  }

  export type SpeciesUpdateManyWithWhereWithoutStockInput = {
    where: SpeciesScalarWhereInput
    data: XOR<SpeciesUpdateManyMutationInput, SpeciesUncheckedUpdateManyWithoutStockInput>
  }

  export type SpeciesScalarWhereInput = {
    AND?: SpeciesScalarWhereInput | SpeciesScalarWhereInput[]
    OR?: SpeciesScalarWhereInput[]
    NOT?: SpeciesScalarWhereInput | SpeciesScalarWhereInput[]
    id?: StringFilter<"Species"> | string
    name?: StringFilter<"Species"> | string
    price?: IntFilter<"Species"> | number
    slug?: StringFilter<"Species"> | string
    description?: StringNullableFilter<"Species"> | string | null
    genusId?: StringFilter<"Species"> | string
    stockId?: StringFilter<"Species"> | string
  }

  export type SpeciesCreateWithoutGenusInput = {
    id?: string
    name: string
    price?: number
    slug: string
    description?: string | null
    stock: StockCreateNestedOneWithoutSpeciesInput
    plants?: PlantCreateNestedManyWithoutSpeciesInput
    images?: SpeciesImageCreateNestedManyWithoutSpeciesInput
  }

  export type SpeciesUncheckedCreateWithoutGenusInput = {
    id?: string
    name: string
    price?: number
    slug: string
    description?: string | null
    stockId: string
    plants?: PlantUncheckedCreateNestedManyWithoutSpeciesInput
    images?: SpeciesImageUncheckedCreateNestedManyWithoutSpeciesInput
  }

  export type SpeciesCreateOrConnectWithoutGenusInput = {
    where: SpeciesWhereUniqueInput
    create: XOR<SpeciesCreateWithoutGenusInput, SpeciesUncheckedCreateWithoutGenusInput>
  }

  export type SpeciesCreateManyGenusInputEnvelope = {
    data: SpeciesCreateManyGenusInput | SpeciesCreateManyGenusInput[]
    skipDuplicates?: boolean
  }

  export type SpeciesUpsertWithWhereUniqueWithoutGenusInput = {
    where: SpeciesWhereUniqueInput
    update: XOR<SpeciesUpdateWithoutGenusInput, SpeciesUncheckedUpdateWithoutGenusInput>
    create: XOR<SpeciesCreateWithoutGenusInput, SpeciesUncheckedCreateWithoutGenusInput>
  }

  export type SpeciesUpdateWithWhereUniqueWithoutGenusInput = {
    where: SpeciesWhereUniqueInput
    data: XOR<SpeciesUpdateWithoutGenusInput, SpeciesUncheckedUpdateWithoutGenusInput>
  }

  export type SpeciesUpdateManyWithWhereWithoutGenusInput = {
    where: SpeciesScalarWhereInput
    data: XOR<SpeciesUpdateManyMutationInput, SpeciesUncheckedUpdateManyWithoutGenusInput>
  }

  export type GenusCreateWithoutSpeciesInput = {
    id?: string
    name: string
    type: $Enums.PlantType
  }

  export type GenusUncheckedCreateWithoutSpeciesInput = {
    id?: string
    name: string
    type: $Enums.PlantType
  }

  export type GenusCreateOrConnectWithoutSpeciesInput = {
    where: GenusWhereUniqueInput
    create: XOR<GenusCreateWithoutSpeciesInput, GenusUncheckedCreateWithoutSpeciesInput>
  }

  export type StockCreateWithoutSpeciesInput = {
    id?: string
    quantity?: number
    available?: boolean
  }

  export type StockUncheckedCreateWithoutSpeciesInput = {
    id?: string
    quantity?: number
    available?: boolean
  }

  export type StockCreateOrConnectWithoutSpeciesInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutSpeciesInput, StockUncheckedCreateWithoutSpeciesInput>
  }

  export type PlantCreateWithoutSpeciesInput = {
    id?: string
    pottingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutPlantsInput
  }

  export type PlantUncheckedCreateWithoutSpeciesInput = {
    id?: string
    pottingDate?: Date | string | null
    locationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlantCreateOrConnectWithoutSpeciesInput = {
    where: PlantWhereUniqueInput
    create: XOR<PlantCreateWithoutSpeciesInput, PlantUncheckedCreateWithoutSpeciesInput>
  }

  export type PlantCreateManySpeciesInputEnvelope = {
    data: PlantCreateManySpeciesInput | PlantCreateManySpeciesInput[]
    skipDuplicates?: boolean
  }

  export type SpeciesImageCreateWithoutSpeciesInput = {
    id?: string
    url: string
  }

  export type SpeciesImageUncheckedCreateWithoutSpeciesInput = {
    id?: string
    url: string
  }

  export type SpeciesImageCreateOrConnectWithoutSpeciesInput = {
    where: SpeciesImageWhereUniqueInput
    create: XOR<SpeciesImageCreateWithoutSpeciesInput, SpeciesImageUncheckedCreateWithoutSpeciesInput>
  }

  export type SpeciesImageCreateManySpeciesInputEnvelope = {
    data: SpeciesImageCreateManySpeciesInput | SpeciesImageCreateManySpeciesInput[]
    skipDuplicates?: boolean
  }

  export type GenusUpsertWithoutSpeciesInput = {
    update: XOR<GenusUpdateWithoutSpeciesInput, GenusUncheckedUpdateWithoutSpeciesInput>
    create: XOR<GenusCreateWithoutSpeciesInput, GenusUncheckedCreateWithoutSpeciesInput>
    where?: GenusWhereInput
  }

  export type GenusUpdateToOneWithWhereWithoutSpeciesInput = {
    where?: GenusWhereInput
    data: XOR<GenusUpdateWithoutSpeciesInput, GenusUncheckedUpdateWithoutSpeciesInput>
  }

  export type GenusUpdateWithoutSpeciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPlantTypeFieldUpdateOperationsInput | $Enums.PlantType
  }

  export type GenusUncheckedUpdateWithoutSpeciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPlantTypeFieldUpdateOperationsInput | $Enums.PlantType
  }

  export type StockUpsertWithoutSpeciesInput = {
    update: XOR<StockUpdateWithoutSpeciesInput, StockUncheckedUpdateWithoutSpeciesInput>
    create: XOR<StockCreateWithoutSpeciesInput, StockUncheckedCreateWithoutSpeciesInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutSpeciesInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutSpeciesInput, StockUncheckedUpdateWithoutSpeciesInput>
  }

  export type StockUpdateWithoutSpeciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    available?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StockUncheckedUpdateWithoutSpeciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    available?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlantUpsertWithWhereUniqueWithoutSpeciesInput = {
    where: PlantWhereUniqueInput
    update: XOR<PlantUpdateWithoutSpeciesInput, PlantUncheckedUpdateWithoutSpeciesInput>
    create: XOR<PlantCreateWithoutSpeciesInput, PlantUncheckedCreateWithoutSpeciesInput>
  }

  export type PlantUpdateWithWhereUniqueWithoutSpeciesInput = {
    where: PlantWhereUniqueInput
    data: XOR<PlantUpdateWithoutSpeciesInput, PlantUncheckedUpdateWithoutSpeciesInput>
  }

  export type PlantUpdateManyWithWhereWithoutSpeciesInput = {
    where: PlantScalarWhereInput
    data: XOR<PlantUpdateManyMutationInput, PlantUncheckedUpdateManyWithoutSpeciesInput>
  }

  export type PlantScalarWhereInput = {
    AND?: PlantScalarWhereInput | PlantScalarWhereInput[]
    OR?: PlantScalarWhereInput[]
    NOT?: PlantScalarWhereInput | PlantScalarWhereInput[]
    id?: StringFilter<"Plant"> | string
    pottingDate?: DateTimeNullableFilter<"Plant"> | Date | string | null
    speciesId?: StringFilter<"Plant"> | string
    locationId?: StringNullableFilter<"Plant"> | string | null
    createdAt?: DateTimeFilter<"Plant"> | Date | string
    updatedAt?: DateTimeFilter<"Plant"> | Date | string
  }

  export type SpeciesImageUpsertWithWhereUniqueWithoutSpeciesInput = {
    where: SpeciesImageWhereUniqueInput
    update: XOR<SpeciesImageUpdateWithoutSpeciesInput, SpeciesImageUncheckedUpdateWithoutSpeciesInput>
    create: XOR<SpeciesImageCreateWithoutSpeciesInput, SpeciesImageUncheckedCreateWithoutSpeciesInput>
  }

  export type SpeciesImageUpdateWithWhereUniqueWithoutSpeciesInput = {
    where: SpeciesImageWhereUniqueInput
    data: XOR<SpeciesImageUpdateWithoutSpeciesInput, SpeciesImageUncheckedUpdateWithoutSpeciesInput>
  }

  export type SpeciesImageUpdateManyWithWhereWithoutSpeciesInput = {
    where: SpeciesImageScalarWhereInput
    data: XOR<SpeciesImageUpdateManyMutationInput, SpeciesImageUncheckedUpdateManyWithoutSpeciesInput>
  }

  export type SpeciesImageScalarWhereInput = {
    AND?: SpeciesImageScalarWhereInput | SpeciesImageScalarWhereInput[]
    OR?: SpeciesImageScalarWhereInput[]
    NOT?: SpeciesImageScalarWhereInput | SpeciesImageScalarWhereInput[]
    id?: StringFilter<"SpeciesImage"> | string
    url?: StringFilter<"SpeciesImage"> | string
    speciesId?: StringFilter<"SpeciesImage"> | string
  }

  export type SpeciesCreateWithoutImagesInput = {
    id?: string
    name: string
    price?: number
    slug: string
    description?: string | null
    genus: GenusCreateNestedOneWithoutSpeciesInput
    stock: StockCreateNestedOneWithoutSpeciesInput
    plants?: PlantCreateNestedManyWithoutSpeciesInput
  }

  export type SpeciesUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
    price?: number
    slug: string
    description?: string | null
    genusId: string
    stockId: string
    plants?: PlantUncheckedCreateNestedManyWithoutSpeciesInput
  }

  export type SpeciesCreateOrConnectWithoutImagesInput = {
    where: SpeciesWhereUniqueInput
    create: XOR<SpeciesCreateWithoutImagesInput, SpeciesUncheckedCreateWithoutImagesInput>
  }

  export type SpeciesUpsertWithoutImagesInput = {
    update: XOR<SpeciesUpdateWithoutImagesInput, SpeciesUncheckedUpdateWithoutImagesInput>
    create: XOR<SpeciesCreateWithoutImagesInput, SpeciesUncheckedCreateWithoutImagesInput>
    where?: SpeciesWhereInput
  }

  export type SpeciesUpdateToOneWithWhereWithoutImagesInput = {
    where?: SpeciesWhereInput
    data: XOR<SpeciesUpdateWithoutImagesInput, SpeciesUncheckedUpdateWithoutImagesInput>
  }

  export type SpeciesUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genus?: GenusUpdateOneRequiredWithoutSpeciesNestedInput
    stock?: StockUpdateOneRequiredWithoutSpeciesNestedInput
    plants?: PlantUpdateManyWithoutSpeciesNestedInput
  }

  export type SpeciesUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genusId?: StringFieldUpdateOperationsInput | string
    stockId?: StringFieldUpdateOperationsInput | string
    plants?: PlantUncheckedUpdateManyWithoutSpeciesNestedInput
  }

  export type PlantCreateWithoutLocationInput = {
    id?: string
    pottingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    species: SpeciesCreateNestedOneWithoutPlantsInput
  }

  export type PlantUncheckedCreateWithoutLocationInput = {
    id?: string
    pottingDate?: Date | string | null
    speciesId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlantCreateOrConnectWithoutLocationInput = {
    where: PlantWhereUniqueInput
    create: XOR<PlantCreateWithoutLocationInput, PlantUncheckedCreateWithoutLocationInput>
  }

  export type PlantCreateManyLocationInputEnvelope = {
    data: PlantCreateManyLocationInput | PlantCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type PlantUpsertWithWhereUniqueWithoutLocationInput = {
    where: PlantWhereUniqueInput
    update: XOR<PlantUpdateWithoutLocationInput, PlantUncheckedUpdateWithoutLocationInput>
    create: XOR<PlantCreateWithoutLocationInput, PlantUncheckedCreateWithoutLocationInput>
  }

  export type PlantUpdateWithWhereUniqueWithoutLocationInput = {
    where: PlantWhereUniqueInput
    data: XOR<PlantUpdateWithoutLocationInput, PlantUncheckedUpdateWithoutLocationInput>
  }

  export type PlantUpdateManyWithWhereWithoutLocationInput = {
    where: PlantScalarWhereInput
    data: XOR<PlantUpdateManyMutationInput, PlantUncheckedUpdateManyWithoutLocationInput>
  }

  export type SpeciesCreateWithoutPlantsInput = {
    id?: string
    name: string
    price?: number
    slug: string
    description?: string | null
    genus: GenusCreateNestedOneWithoutSpeciesInput
    stock: StockCreateNestedOneWithoutSpeciesInput
    images?: SpeciesImageCreateNestedManyWithoutSpeciesInput
  }

  export type SpeciesUncheckedCreateWithoutPlantsInput = {
    id?: string
    name: string
    price?: number
    slug: string
    description?: string | null
    genusId: string
    stockId: string
    images?: SpeciesImageUncheckedCreateNestedManyWithoutSpeciesInput
  }

  export type SpeciesCreateOrConnectWithoutPlantsInput = {
    where: SpeciesWhereUniqueInput
    create: XOR<SpeciesCreateWithoutPlantsInput, SpeciesUncheckedCreateWithoutPlantsInput>
  }

  export type LocationCreateWithoutPlantsInput = {
    id?: string
    zone: $Enums.ZoneType
    table: $Enums.TableType
  }

  export type LocationUncheckedCreateWithoutPlantsInput = {
    id?: string
    zone: $Enums.ZoneType
    table: $Enums.TableType
  }

  export type LocationCreateOrConnectWithoutPlantsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutPlantsInput, LocationUncheckedCreateWithoutPlantsInput>
  }

  export type SpeciesUpsertWithoutPlantsInput = {
    update: XOR<SpeciesUpdateWithoutPlantsInput, SpeciesUncheckedUpdateWithoutPlantsInput>
    create: XOR<SpeciesCreateWithoutPlantsInput, SpeciesUncheckedCreateWithoutPlantsInput>
    where?: SpeciesWhereInput
  }

  export type SpeciesUpdateToOneWithWhereWithoutPlantsInput = {
    where?: SpeciesWhereInput
    data: XOR<SpeciesUpdateWithoutPlantsInput, SpeciesUncheckedUpdateWithoutPlantsInput>
  }

  export type SpeciesUpdateWithoutPlantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genus?: GenusUpdateOneRequiredWithoutSpeciesNestedInput
    stock?: StockUpdateOneRequiredWithoutSpeciesNestedInput
    images?: SpeciesImageUpdateManyWithoutSpeciesNestedInput
  }

  export type SpeciesUncheckedUpdateWithoutPlantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genusId?: StringFieldUpdateOperationsInput | string
    stockId?: StringFieldUpdateOperationsInput | string
    images?: SpeciesImageUncheckedUpdateManyWithoutSpeciesNestedInput
  }

  export type LocationUpsertWithoutPlantsInput = {
    update: XOR<LocationUpdateWithoutPlantsInput, LocationUncheckedUpdateWithoutPlantsInput>
    create: XOR<LocationCreateWithoutPlantsInput, LocationUncheckedCreateWithoutPlantsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutPlantsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutPlantsInput, LocationUncheckedUpdateWithoutPlantsInput>
  }

  export type LocationUpdateWithoutPlantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    zone?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    table?: EnumTableTypeFieldUpdateOperationsInput | $Enums.TableType
  }

  export type LocationUncheckedUpdateWithoutPlantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    zone?: EnumZoneTypeFieldUpdateOperationsInput | $Enums.ZoneType
    table?: EnumTableTypeFieldUpdateOperationsInput | $Enums.TableType
  }

  export type FertilizationCycleCreateWithoutAgrochemicalInput = {
    id?: string
    sequence: number
    program: FertilizationProgramCreateNestedOneWithoutProductsCycleInput
    tasks?: FertilizationTaskCreateNestedManyWithoutProductsCycleInput
  }

  export type FertilizationCycleUncheckedCreateWithoutAgrochemicalInput = {
    id?: string
    sequence: number
    programId: string
    tasks?: FertilizationTaskUncheckedCreateNestedManyWithoutProductsCycleInput
  }

  export type FertilizationCycleCreateOrConnectWithoutAgrochemicalInput = {
    where: FertilizationCycleWhereUniqueInput
    create: XOR<FertilizationCycleCreateWithoutAgrochemicalInput, FertilizationCycleUncheckedCreateWithoutAgrochemicalInput>
  }

  export type FertilizationCycleCreateManyAgrochemicalInputEnvelope = {
    data: FertilizationCycleCreateManyAgrochemicalInput | FertilizationCycleCreateManyAgrochemicalInput[]
    skipDuplicates?: boolean
  }

  export type FertilizationTaskCreateWithoutAgrochemicalInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: FertilizationTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    productsCycle?: FertilizationCycleCreateNestedOneWithoutTasksInput
  }

  export type FertilizationTaskUncheckedCreateWithoutAgrochemicalInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: FertilizationTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    productsCycleId?: string | null
  }

  export type FertilizationTaskCreateOrConnectWithoutAgrochemicalInput = {
    where: FertilizationTaskWhereUniqueInput
    create: XOR<FertilizationTaskCreateWithoutAgrochemicalInput, FertilizationTaskUncheckedCreateWithoutAgrochemicalInput>
  }

  export type FertilizationTaskCreateManyAgrochemicalInputEnvelope = {
    data: FertilizationTaskCreateManyAgrochemicalInput | FertilizationTaskCreateManyAgrochemicalInput[]
    skipDuplicates?: boolean
  }

  export type PhytosanitaryCycleCreateWithoutAgrochemicalInput = {
    id?: string
    sequence: number
    program: PhytosanitaryProgramCreateNestedOneWithoutProductsCycleInput
    tasks?: PhytosanitaryTaskCreateNestedManyWithoutProductsCycleInput
  }

  export type PhytosanitaryCycleUncheckedCreateWithoutAgrochemicalInput = {
    id?: string
    sequence: number
    programId: string
    tasks?: PhytosanitaryTaskUncheckedCreateNestedManyWithoutProductsCycleInput
  }

  export type PhytosanitaryCycleCreateOrConnectWithoutAgrochemicalInput = {
    where: PhytosanitaryCycleWhereUniqueInput
    create: XOR<PhytosanitaryCycleCreateWithoutAgrochemicalInput, PhytosanitaryCycleUncheckedCreateWithoutAgrochemicalInput>
  }

  export type PhytosanitaryCycleCreateManyAgrochemicalInputEnvelope = {
    data: PhytosanitaryCycleCreateManyAgrochemicalInput | PhytosanitaryCycleCreateManyAgrochemicalInput[]
    skipDuplicates?: boolean
  }

  export type PhytosanitaryTaskCreateWithoutAgrochemicalInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: PhytosanitaryTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    productsCycle?: PhytosanitaryCycleCreateNestedOneWithoutTasksInput
  }

  export type PhytosanitaryTaskUncheckedCreateWithoutAgrochemicalInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: PhytosanitaryTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    productsCycleId?: string | null
  }

  export type PhytosanitaryTaskCreateOrConnectWithoutAgrochemicalInput = {
    where: PhytosanitaryTaskWhereUniqueInput
    create: XOR<PhytosanitaryTaskCreateWithoutAgrochemicalInput, PhytosanitaryTaskUncheckedCreateWithoutAgrochemicalInput>
  }

  export type PhytosanitaryTaskCreateManyAgrochemicalInputEnvelope = {
    data: PhytosanitaryTaskCreateManyAgrochemicalInput | PhytosanitaryTaskCreateManyAgrochemicalInput[]
    skipDuplicates?: boolean
  }

  export type FertilizationCycleUpsertWithWhereUniqueWithoutAgrochemicalInput = {
    where: FertilizationCycleWhereUniqueInput
    update: XOR<FertilizationCycleUpdateWithoutAgrochemicalInput, FertilizationCycleUncheckedUpdateWithoutAgrochemicalInput>
    create: XOR<FertilizationCycleCreateWithoutAgrochemicalInput, FertilizationCycleUncheckedCreateWithoutAgrochemicalInput>
  }

  export type FertilizationCycleUpdateWithWhereUniqueWithoutAgrochemicalInput = {
    where: FertilizationCycleWhereUniqueInput
    data: XOR<FertilizationCycleUpdateWithoutAgrochemicalInput, FertilizationCycleUncheckedUpdateWithoutAgrochemicalInput>
  }

  export type FertilizationCycleUpdateManyWithWhereWithoutAgrochemicalInput = {
    where: FertilizationCycleScalarWhereInput
    data: XOR<FertilizationCycleUpdateManyMutationInput, FertilizationCycleUncheckedUpdateManyWithoutAgrochemicalInput>
  }

  export type FertilizationCycleScalarWhereInput = {
    AND?: FertilizationCycleScalarWhereInput | FertilizationCycleScalarWhereInput[]
    OR?: FertilizationCycleScalarWhereInput[]
    NOT?: FertilizationCycleScalarWhereInput | FertilizationCycleScalarWhereInput[]
    id?: StringFilter<"FertilizationCycle"> | string
    sequence?: IntFilter<"FertilizationCycle"> | number
    agrochemicalId?: StringFilter<"FertilizationCycle"> | string
    programId?: StringFilter<"FertilizationCycle"> | string
  }

  export type FertilizationTaskUpsertWithWhereUniqueWithoutAgrochemicalInput = {
    where: FertilizationTaskWhereUniqueInput
    update: XOR<FertilizationTaskUpdateWithoutAgrochemicalInput, FertilizationTaskUncheckedUpdateWithoutAgrochemicalInput>
    create: XOR<FertilizationTaskCreateWithoutAgrochemicalInput, FertilizationTaskUncheckedCreateWithoutAgrochemicalInput>
  }

  export type FertilizationTaskUpdateWithWhereUniqueWithoutAgrochemicalInput = {
    where: FertilizationTaskWhereUniqueInput
    data: XOR<FertilizationTaskUpdateWithoutAgrochemicalInput, FertilizationTaskUncheckedUpdateWithoutAgrochemicalInput>
  }

  export type FertilizationTaskUpdateManyWithWhereWithoutAgrochemicalInput = {
    where: FertilizationTaskScalarWhereInput
    data: XOR<FertilizationTaskUpdateManyMutationInput, FertilizationTaskUncheckedUpdateManyWithoutAgrochemicalInput>
  }

  export type FertilizationTaskScalarWhereInput = {
    AND?: FertilizationTaskScalarWhereInput | FertilizationTaskScalarWhereInput[]
    OR?: FertilizationTaskScalarWhereInput[]
    NOT?: FertilizationTaskScalarWhereInput | FertilizationTaskScalarWhereInput[]
    id?: StringFilter<"FertilizationTask"> | string
    scheduledDate?: DateTimeFilter<"FertilizationTask"> | Date | string
    executionDate?: DateTimeNullableFilter<"FertilizationTask"> | Date | string | null
    zones?: EnumZoneTypeNullableListFilter<"FertilizationTask">
    note?: StringNullableFilter<"FertilizationTask"> | string | null
    status?: EnumTaskStatusFilter<"FertilizationTask"> | $Enums.TaskStatus
    agrochemicalId?: StringFilter<"FertilizationTask"> | string
    productsCycleId?: StringNullableFilter<"FertilizationTask"> | string | null
  }

  export type PhytosanitaryCycleUpsertWithWhereUniqueWithoutAgrochemicalInput = {
    where: PhytosanitaryCycleWhereUniqueInput
    update: XOR<PhytosanitaryCycleUpdateWithoutAgrochemicalInput, PhytosanitaryCycleUncheckedUpdateWithoutAgrochemicalInput>
    create: XOR<PhytosanitaryCycleCreateWithoutAgrochemicalInput, PhytosanitaryCycleUncheckedCreateWithoutAgrochemicalInput>
  }

  export type PhytosanitaryCycleUpdateWithWhereUniqueWithoutAgrochemicalInput = {
    where: PhytosanitaryCycleWhereUniqueInput
    data: XOR<PhytosanitaryCycleUpdateWithoutAgrochemicalInput, PhytosanitaryCycleUncheckedUpdateWithoutAgrochemicalInput>
  }

  export type PhytosanitaryCycleUpdateManyWithWhereWithoutAgrochemicalInput = {
    where: PhytosanitaryCycleScalarWhereInput
    data: XOR<PhytosanitaryCycleUpdateManyMutationInput, PhytosanitaryCycleUncheckedUpdateManyWithoutAgrochemicalInput>
  }

  export type PhytosanitaryCycleScalarWhereInput = {
    AND?: PhytosanitaryCycleScalarWhereInput | PhytosanitaryCycleScalarWhereInput[]
    OR?: PhytosanitaryCycleScalarWhereInput[]
    NOT?: PhytosanitaryCycleScalarWhereInput | PhytosanitaryCycleScalarWhereInput[]
    id?: StringFilter<"PhytosanitaryCycle"> | string
    sequence?: IntFilter<"PhytosanitaryCycle"> | number
    agrochemicalId?: StringFilter<"PhytosanitaryCycle"> | string
    programId?: StringFilter<"PhytosanitaryCycle"> | string
  }

  export type PhytosanitaryTaskUpsertWithWhereUniqueWithoutAgrochemicalInput = {
    where: PhytosanitaryTaskWhereUniqueInput
    update: XOR<PhytosanitaryTaskUpdateWithoutAgrochemicalInput, PhytosanitaryTaskUncheckedUpdateWithoutAgrochemicalInput>
    create: XOR<PhytosanitaryTaskCreateWithoutAgrochemicalInput, PhytosanitaryTaskUncheckedCreateWithoutAgrochemicalInput>
  }

  export type PhytosanitaryTaskUpdateWithWhereUniqueWithoutAgrochemicalInput = {
    where: PhytosanitaryTaskWhereUniqueInput
    data: XOR<PhytosanitaryTaskUpdateWithoutAgrochemicalInput, PhytosanitaryTaskUncheckedUpdateWithoutAgrochemicalInput>
  }

  export type PhytosanitaryTaskUpdateManyWithWhereWithoutAgrochemicalInput = {
    where: PhytosanitaryTaskScalarWhereInput
    data: XOR<PhytosanitaryTaskUpdateManyMutationInput, PhytosanitaryTaskUncheckedUpdateManyWithoutAgrochemicalInput>
  }

  export type PhytosanitaryTaskScalarWhereInput = {
    AND?: PhytosanitaryTaskScalarWhereInput | PhytosanitaryTaskScalarWhereInput[]
    OR?: PhytosanitaryTaskScalarWhereInput[]
    NOT?: PhytosanitaryTaskScalarWhereInput | PhytosanitaryTaskScalarWhereInput[]
    id?: StringFilter<"PhytosanitaryTask"> | string
    scheduledDate?: DateTimeFilter<"PhytosanitaryTask"> | Date | string
    executionDate?: DateTimeNullableFilter<"PhytosanitaryTask"> | Date | string | null
    zones?: EnumZoneTypeNullableListFilter<"PhytosanitaryTask">
    note?: StringNullableFilter<"PhytosanitaryTask"> | string | null
    status?: EnumTaskStatusFilter<"PhytosanitaryTask"> | $Enums.TaskStatus
    agrochemicalId?: StringFilter<"PhytosanitaryTask"> | string
    productsCycleId?: StringNullableFilter<"PhytosanitaryTask"> | string | null
  }

  export type FertilizationCycleCreateWithoutProgramInput = {
    id?: string
    sequence: number
    agrochemical: AgrochemicalCreateNestedOneWithoutFertilizationCyclesInput
    tasks?: FertilizationTaskCreateNestedManyWithoutProductsCycleInput
  }

  export type FertilizationCycleUncheckedCreateWithoutProgramInput = {
    id?: string
    sequence: number
    agrochemicalId: string
    tasks?: FertilizationTaskUncheckedCreateNestedManyWithoutProductsCycleInput
  }

  export type FertilizationCycleCreateOrConnectWithoutProgramInput = {
    where: FertilizationCycleWhereUniqueInput
    create: XOR<FertilizationCycleCreateWithoutProgramInput, FertilizationCycleUncheckedCreateWithoutProgramInput>
  }

  export type FertilizationCycleCreateManyProgramInputEnvelope = {
    data: FertilizationCycleCreateManyProgramInput | FertilizationCycleCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type FertilizationCycleUpsertWithWhereUniqueWithoutProgramInput = {
    where: FertilizationCycleWhereUniqueInput
    update: XOR<FertilizationCycleUpdateWithoutProgramInput, FertilizationCycleUncheckedUpdateWithoutProgramInput>
    create: XOR<FertilizationCycleCreateWithoutProgramInput, FertilizationCycleUncheckedCreateWithoutProgramInput>
  }

  export type FertilizationCycleUpdateWithWhereUniqueWithoutProgramInput = {
    where: FertilizationCycleWhereUniqueInput
    data: XOR<FertilizationCycleUpdateWithoutProgramInput, FertilizationCycleUncheckedUpdateWithoutProgramInput>
  }

  export type FertilizationCycleUpdateManyWithWhereWithoutProgramInput = {
    where: FertilizationCycleScalarWhereInput
    data: XOR<FertilizationCycleUpdateManyMutationInput, FertilizationCycleUncheckedUpdateManyWithoutProgramInput>
  }

  export type AgrochemicalCreateWithoutFertilizationCyclesInput = {
    id?: string
    name: string
    description: string
    type: $Enums.AgrochemicalType
    porpose: $Enums.AgrochemicalPorpose
    preparation: string
    fertilizationTasks?: FertilizationTaskCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryCycles?: PhytosanitaryCycleCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryTasks?: PhytosanitaryTaskCreateNestedManyWithoutAgrochemicalInput
  }

  export type AgrochemicalUncheckedCreateWithoutFertilizationCyclesInput = {
    id?: string
    name: string
    description: string
    type: $Enums.AgrochemicalType
    porpose: $Enums.AgrochemicalPorpose
    preparation: string
    fertilizationTasks?: FertilizationTaskUncheckedCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryCycles?: PhytosanitaryCycleUncheckedCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryTasks?: PhytosanitaryTaskUncheckedCreateNestedManyWithoutAgrochemicalInput
  }

  export type AgrochemicalCreateOrConnectWithoutFertilizationCyclesInput = {
    where: AgrochemicalWhereUniqueInput
    create: XOR<AgrochemicalCreateWithoutFertilizationCyclesInput, AgrochemicalUncheckedCreateWithoutFertilizationCyclesInput>
  }

  export type FertilizationProgramCreateWithoutProductsCycleInput = {
    id?: string
    name: string
    weeklyFrequency: number
  }

  export type FertilizationProgramUncheckedCreateWithoutProductsCycleInput = {
    id?: string
    name: string
    weeklyFrequency: number
  }

  export type FertilizationProgramCreateOrConnectWithoutProductsCycleInput = {
    where: FertilizationProgramWhereUniqueInput
    create: XOR<FertilizationProgramCreateWithoutProductsCycleInput, FertilizationProgramUncheckedCreateWithoutProductsCycleInput>
  }

  export type FertilizationTaskCreateWithoutProductsCycleInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: FertilizationTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    agrochemical: AgrochemicalCreateNestedOneWithoutFertilizationTasksInput
  }

  export type FertilizationTaskUncheckedCreateWithoutProductsCycleInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: FertilizationTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    agrochemicalId: string
  }

  export type FertilizationTaskCreateOrConnectWithoutProductsCycleInput = {
    where: FertilizationTaskWhereUniqueInput
    create: XOR<FertilizationTaskCreateWithoutProductsCycleInput, FertilizationTaskUncheckedCreateWithoutProductsCycleInput>
  }

  export type FertilizationTaskCreateManyProductsCycleInputEnvelope = {
    data: FertilizationTaskCreateManyProductsCycleInput | FertilizationTaskCreateManyProductsCycleInput[]
    skipDuplicates?: boolean
  }

  export type AgrochemicalUpsertWithoutFertilizationCyclesInput = {
    update: XOR<AgrochemicalUpdateWithoutFertilizationCyclesInput, AgrochemicalUncheckedUpdateWithoutFertilizationCyclesInput>
    create: XOR<AgrochemicalCreateWithoutFertilizationCyclesInput, AgrochemicalUncheckedCreateWithoutFertilizationCyclesInput>
    where?: AgrochemicalWhereInput
  }

  export type AgrochemicalUpdateToOneWithWhereWithoutFertilizationCyclesInput = {
    where?: AgrochemicalWhereInput
    data: XOR<AgrochemicalUpdateWithoutFertilizationCyclesInput, AgrochemicalUncheckedUpdateWithoutFertilizationCyclesInput>
  }

  export type AgrochemicalUpdateWithoutFertilizationCyclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgrochemicalTypeFieldUpdateOperationsInput | $Enums.AgrochemicalType
    porpose?: EnumAgrochemicalPorposeFieldUpdateOperationsInput | $Enums.AgrochemicalPorpose
    preparation?: StringFieldUpdateOperationsInput | string
    fertilizationTasks?: FertilizationTaskUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryCycles?: PhytosanitaryCycleUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryTasks?: PhytosanitaryTaskUpdateManyWithoutAgrochemicalNestedInput
  }

  export type AgrochemicalUncheckedUpdateWithoutFertilizationCyclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgrochemicalTypeFieldUpdateOperationsInput | $Enums.AgrochemicalType
    porpose?: EnumAgrochemicalPorposeFieldUpdateOperationsInput | $Enums.AgrochemicalPorpose
    preparation?: StringFieldUpdateOperationsInput | string
    fertilizationTasks?: FertilizationTaskUncheckedUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryCycles?: PhytosanitaryCycleUncheckedUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryTasks?: PhytosanitaryTaskUncheckedUpdateManyWithoutAgrochemicalNestedInput
  }

  export type FertilizationProgramUpsertWithoutProductsCycleInput = {
    update: XOR<FertilizationProgramUpdateWithoutProductsCycleInput, FertilizationProgramUncheckedUpdateWithoutProductsCycleInput>
    create: XOR<FertilizationProgramCreateWithoutProductsCycleInput, FertilizationProgramUncheckedCreateWithoutProductsCycleInput>
    where?: FertilizationProgramWhereInput
  }

  export type FertilizationProgramUpdateToOneWithWhereWithoutProductsCycleInput = {
    where?: FertilizationProgramWhereInput
    data: XOR<FertilizationProgramUpdateWithoutProductsCycleInput, FertilizationProgramUncheckedUpdateWithoutProductsCycleInput>
  }

  export type FertilizationProgramUpdateWithoutProductsCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weeklyFrequency?: IntFieldUpdateOperationsInput | number
  }

  export type FertilizationProgramUncheckedUpdateWithoutProductsCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weeklyFrequency?: IntFieldUpdateOperationsInput | number
  }

  export type FertilizationTaskUpsertWithWhereUniqueWithoutProductsCycleInput = {
    where: FertilizationTaskWhereUniqueInput
    update: XOR<FertilizationTaskUpdateWithoutProductsCycleInput, FertilizationTaskUncheckedUpdateWithoutProductsCycleInput>
    create: XOR<FertilizationTaskCreateWithoutProductsCycleInput, FertilizationTaskUncheckedCreateWithoutProductsCycleInput>
  }

  export type FertilizationTaskUpdateWithWhereUniqueWithoutProductsCycleInput = {
    where: FertilizationTaskWhereUniqueInput
    data: XOR<FertilizationTaskUpdateWithoutProductsCycleInput, FertilizationTaskUncheckedUpdateWithoutProductsCycleInput>
  }

  export type FertilizationTaskUpdateManyWithWhereWithoutProductsCycleInput = {
    where: FertilizationTaskScalarWhereInput
    data: XOR<FertilizationTaskUpdateManyMutationInput, FertilizationTaskUncheckedUpdateManyWithoutProductsCycleInput>
  }

  export type AgrochemicalCreateWithoutFertilizationTasksInput = {
    id?: string
    name: string
    description: string
    type: $Enums.AgrochemicalType
    porpose: $Enums.AgrochemicalPorpose
    preparation: string
    fertilizationCycles?: FertilizationCycleCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryCycles?: PhytosanitaryCycleCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryTasks?: PhytosanitaryTaskCreateNestedManyWithoutAgrochemicalInput
  }

  export type AgrochemicalUncheckedCreateWithoutFertilizationTasksInput = {
    id?: string
    name: string
    description: string
    type: $Enums.AgrochemicalType
    porpose: $Enums.AgrochemicalPorpose
    preparation: string
    fertilizationCycles?: FertilizationCycleUncheckedCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryCycles?: PhytosanitaryCycleUncheckedCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryTasks?: PhytosanitaryTaskUncheckedCreateNestedManyWithoutAgrochemicalInput
  }

  export type AgrochemicalCreateOrConnectWithoutFertilizationTasksInput = {
    where: AgrochemicalWhereUniqueInput
    create: XOR<AgrochemicalCreateWithoutFertilizationTasksInput, AgrochemicalUncheckedCreateWithoutFertilizationTasksInput>
  }

  export type FertilizationCycleCreateWithoutTasksInput = {
    id?: string
    sequence: number
    agrochemical: AgrochemicalCreateNestedOneWithoutFertilizationCyclesInput
    program: FertilizationProgramCreateNestedOneWithoutProductsCycleInput
  }

  export type FertilizationCycleUncheckedCreateWithoutTasksInput = {
    id?: string
    sequence: number
    agrochemicalId: string
    programId: string
  }

  export type FertilizationCycleCreateOrConnectWithoutTasksInput = {
    where: FertilizationCycleWhereUniqueInput
    create: XOR<FertilizationCycleCreateWithoutTasksInput, FertilizationCycleUncheckedCreateWithoutTasksInput>
  }

  export type AgrochemicalUpsertWithoutFertilizationTasksInput = {
    update: XOR<AgrochemicalUpdateWithoutFertilizationTasksInput, AgrochemicalUncheckedUpdateWithoutFertilizationTasksInput>
    create: XOR<AgrochemicalCreateWithoutFertilizationTasksInput, AgrochemicalUncheckedCreateWithoutFertilizationTasksInput>
    where?: AgrochemicalWhereInput
  }

  export type AgrochemicalUpdateToOneWithWhereWithoutFertilizationTasksInput = {
    where?: AgrochemicalWhereInput
    data: XOR<AgrochemicalUpdateWithoutFertilizationTasksInput, AgrochemicalUncheckedUpdateWithoutFertilizationTasksInput>
  }

  export type AgrochemicalUpdateWithoutFertilizationTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgrochemicalTypeFieldUpdateOperationsInput | $Enums.AgrochemicalType
    porpose?: EnumAgrochemicalPorposeFieldUpdateOperationsInput | $Enums.AgrochemicalPorpose
    preparation?: StringFieldUpdateOperationsInput | string
    fertilizationCycles?: FertilizationCycleUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryCycles?: PhytosanitaryCycleUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryTasks?: PhytosanitaryTaskUpdateManyWithoutAgrochemicalNestedInput
  }

  export type AgrochemicalUncheckedUpdateWithoutFertilizationTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgrochemicalTypeFieldUpdateOperationsInput | $Enums.AgrochemicalType
    porpose?: EnumAgrochemicalPorposeFieldUpdateOperationsInput | $Enums.AgrochemicalPorpose
    preparation?: StringFieldUpdateOperationsInput | string
    fertilizationCycles?: FertilizationCycleUncheckedUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryCycles?: PhytosanitaryCycleUncheckedUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryTasks?: PhytosanitaryTaskUncheckedUpdateManyWithoutAgrochemicalNestedInput
  }

  export type FertilizationCycleUpsertWithoutTasksInput = {
    update: XOR<FertilizationCycleUpdateWithoutTasksInput, FertilizationCycleUncheckedUpdateWithoutTasksInput>
    create: XOR<FertilizationCycleCreateWithoutTasksInput, FertilizationCycleUncheckedCreateWithoutTasksInput>
    where?: FertilizationCycleWhereInput
  }

  export type FertilizationCycleUpdateToOneWithWhereWithoutTasksInput = {
    where?: FertilizationCycleWhereInput
    data: XOR<FertilizationCycleUpdateWithoutTasksInput, FertilizationCycleUncheckedUpdateWithoutTasksInput>
  }

  export type FertilizationCycleUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemical?: AgrochemicalUpdateOneRequiredWithoutFertilizationCyclesNestedInput
    program?: FertilizationProgramUpdateOneRequiredWithoutProductsCycleNestedInput
  }

  export type FertilizationCycleUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemicalId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
  }

  export type PhytosanitaryCycleCreateWithoutProgramInput = {
    id?: string
    sequence: number
    agrochemical: AgrochemicalCreateNestedOneWithoutPhytosanitaryCyclesInput
    tasks?: PhytosanitaryTaskCreateNestedManyWithoutProductsCycleInput
  }

  export type PhytosanitaryCycleUncheckedCreateWithoutProgramInput = {
    id?: string
    sequence: number
    agrochemicalId: string
    tasks?: PhytosanitaryTaskUncheckedCreateNestedManyWithoutProductsCycleInput
  }

  export type PhytosanitaryCycleCreateOrConnectWithoutProgramInput = {
    where: PhytosanitaryCycleWhereUniqueInput
    create: XOR<PhytosanitaryCycleCreateWithoutProgramInput, PhytosanitaryCycleUncheckedCreateWithoutProgramInput>
  }

  export type PhytosanitaryCycleCreateManyProgramInputEnvelope = {
    data: PhytosanitaryCycleCreateManyProgramInput | PhytosanitaryCycleCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type PhytosanitaryCycleUpsertWithWhereUniqueWithoutProgramInput = {
    where: PhytosanitaryCycleWhereUniqueInput
    update: XOR<PhytosanitaryCycleUpdateWithoutProgramInput, PhytosanitaryCycleUncheckedUpdateWithoutProgramInput>
    create: XOR<PhytosanitaryCycleCreateWithoutProgramInput, PhytosanitaryCycleUncheckedCreateWithoutProgramInput>
  }

  export type PhytosanitaryCycleUpdateWithWhereUniqueWithoutProgramInput = {
    where: PhytosanitaryCycleWhereUniqueInput
    data: XOR<PhytosanitaryCycleUpdateWithoutProgramInput, PhytosanitaryCycleUncheckedUpdateWithoutProgramInput>
  }

  export type PhytosanitaryCycleUpdateManyWithWhereWithoutProgramInput = {
    where: PhytosanitaryCycleScalarWhereInput
    data: XOR<PhytosanitaryCycleUpdateManyMutationInput, PhytosanitaryCycleUncheckedUpdateManyWithoutProgramInput>
  }

  export type AgrochemicalCreateWithoutPhytosanitaryCyclesInput = {
    id?: string
    name: string
    description: string
    type: $Enums.AgrochemicalType
    porpose: $Enums.AgrochemicalPorpose
    preparation: string
    fertilizationCycles?: FertilizationCycleCreateNestedManyWithoutAgrochemicalInput
    fertilizationTasks?: FertilizationTaskCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryTasks?: PhytosanitaryTaskCreateNestedManyWithoutAgrochemicalInput
  }

  export type AgrochemicalUncheckedCreateWithoutPhytosanitaryCyclesInput = {
    id?: string
    name: string
    description: string
    type: $Enums.AgrochemicalType
    porpose: $Enums.AgrochemicalPorpose
    preparation: string
    fertilizationCycles?: FertilizationCycleUncheckedCreateNestedManyWithoutAgrochemicalInput
    fertilizationTasks?: FertilizationTaskUncheckedCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryTasks?: PhytosanitaryTaskUncheckedCreateNestedManyWithoutAgrochemicalInput
  }

  export type AgrochemicalCreateOrConnectWithoutPhytosanitaryCyclesInput = {
    where: AgrochemicalWhereUniqueInput
    create: XOR<AgrochemicalCreateWithoutPhytosanitaryCyclesInput, AgrochemicalUncheckedCreateWithoutPhytosanitaryCyclesInput>
  }

  export type PhytosanitaryProgramCreateWithoutProductsCycleInput = {
    id?: string
    name: string
    monthlyFrequency: number
  }

  export type PhytosanitaryProgramUncheckedCreateWithoutProductsCycleInput = {
    id?: string
    name: string
    monthlyFrequency: number
  }

  export type PhytosanitaryProgramCreateOrConnectWithoutProductsCycleInput = {
    where: PhytosanitaryProgramWhereUniqueInput
    create: XOR<PhytosanitaryProgramCreateWithoutProductsCycleInput, PhytosanitaryProgramUncheckedCreateWithoutProductsCycleInput>
  }

  export type PhytosanitaryTaskCreateWithoutProductsCycleInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: PhytosanitaryTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    agrochemical: AgrochemicalCreateNestedOneWithoutPhytosanitaryTasksInput
  }

  export type PhytosanitaryTaskUncheckedCreateWithoutProductsCycleInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: PhytosanitaryTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    agrochemicalId: string
  }

  export type PhytosanitaryTaskCreateOrConnectWithoutProductsCycleInput = {
    where: PhytosanitaryTaskWhereUniqueInput
    create: XOR<PhytosanitaryTaskCreateWithoutProductsCycleInput, PhytosanitaryTaskUncheckedCreateWithoutProductsCycleInput>
  }

  export type PhytosanitaryTaskCreateManyProductsCycleInputEnvelope = {
    data: PhytosanitaryTaskCreateManyProductsCycleInput | PhytosanitaryTaskCreateManyProductsCycleInput[]
    skipDuplicates?: boolean
  }

  export type AgrochemicalUpsertWithoutPhytosanitaryCyclesInput = {
    update: XOR<AgrochemicalUpdateWithoutPhytosanitaryCyclesInput, AgrochemicalUncheckedUpdateWithoutPhytosanitaryCyclesInput>
    create: XOR<AgrochemicalCreateWithoutPhytosanitaryCyclesInput, AgrochemicalUncheckedCreateWithoutPhytosanitaryCyclesInput>
    where?: AgrochemicalWhereInput
  }

  export type AgrochemicalUpdateToOneWithWhereWithoutPhytosanitaryCyclesInput = {
    where?: AgrochemicalWhereInput
    data: XOR<AgrochemicalUpdateWithoutPhytosanitaryCyclesInput, AgrochemicalUncheckedUpdateWithoutPhytosanitaryCyclesInput>
  }

  export type AgrochemicalUpdateWithoutPhytosanitaryCyclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgrochemicalTypeFieldUpdateOperationsInput | $Enums.AgrochemicalType
    porpose?: EnumAgrochemicalPorposeFieldUpdateOperationsInput | $Enums.AgrochemicalPorpose
    preparation?: StringFieldUpdateOperationsInput | string
    fertilizationCycles?: FertilizationCycleUpdateManyWithoutAgrochemicalNestedInput
    fertilizationTasks?: FertilizationTaskUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryTasks?: PhytosanitaryTaskUpdateManyWithoutAgrochemicalNestedInput
  }

  export type AgrochemicalUncheckedUpdateWithoutPhytosanitaryCyclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgrochemicalTypeFieldUpdateOperationsInput | $Enums.AgrochemicalType
    porpose?: EnumAgrochemicalPorposeFieldUpdateOperationsInput | $Enums.AgrochemicalPorpose
    preparation?: StringFieldUpdateOperationsInput | string
    fertilizationCycles?: FertilizationCycleUncheckedUpdateManyWithoutAgrochemicalNestedInput
    fertilizationTasks?: FertilizationTaskUncheckedUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryTasks?: PhytosanitaryTaskUncheckedUpdateManyWithoutAgrochemicalNestedInput
  }

  export type PhytosanitaryProgramUpsertWithoutProductsCycleInput = {
    update: XOR<PhytosanitaryProgramUpdateWithoutProductsCycleInput, PhytosanitaryProgramUncheckedUpdateWithoutProductsCycleInput>
    create: XOR<PhytosanitaryProgramCreateWithoutProductsCycleInput, PhytosanitaryProgramUncheckedCreateWithoutProductsCycleInput>
    where?: PhytosanitaryProgramWhereInput
  }

  export type PhytosanitaryProgramUpdateToOneWithWhereWithoutProductsCycleInput = {
    where?: PhytosanitaryProgramWhereInput
    data: XOR<PhytosanitaryProgramUpdateWithoutProductsCycleInput, PhytosanitaryProgramUncheckedUpdateWithoutProductsCycleInput>
  }

  export type PhytosanitaryProgramUpdateWithoutProductsCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    monthlyFrequency?: IntFieldUpdateOperationsInput | number
  }

  export type PhytosanitaryProgramUncheckedUpdateWithoutProductsCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    monthlyFrequency?: IntFieldUpdateOperationsInput | number
  }

  export type PhytosanitaryTaskUpsertWithWhereUniqueWithoutProductsCycleInput = {
    where: PhytosanitaryTaskWhereUniqueInput
    update: XOR<PhytosanitaryTaskUpdateWithoutProductsCycleInput, PhytosanitaryTaskUncheckedUpdateWithoutProductsCycleInput>
    create: XOR<PhytosanitaryTaskCreateWithoutProductsCycleInput, PhytosanitaryTaskUncheckedCreateWithoutProductsCycleInput>
  }

  export type PhytosanitaryTaskUpdateWithWhereUniqueWithoutProductsCycleInput = {
    where: PhytosanitaryTaskWhereUniqueInput
    data: XOR<PhytosanitaryTaskUpdateWithoutProductsCycleInput, PhytosanitaryTaskUncheckedUpdateWithoutProductsCycleInput>
  }

  export type PhytosanitaryTaskUpdateManyWithWhereWithoutProductsCycleInput = {
    where: PhytosanitaryTaskScalarWhereInput
    data: XOR<PhytosanitaryTaskUpdateManyMutationInput, PhytosanitaryTaskUncheckedUpdateManyWithoutProductsCycleInput>
  }

  export type AgrochemicalCreateWithoutPhytosanitaryTasksInput = {
    id?: string
    name: string
    description: string
    type: $Enums.AgrochemicalType
    porpose: $Enums.AgrochemicalPorpose
    preparation: string
    fertilizationCycles?: FertilizationCycleCreateNestedManyWithoutAgrochemicalInput
    fertilizationTasks?: FertilizationTaskCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryCycles?: PhytosanitaryCycleCreateNestedManyWithoutAgrochemicalInput
  }

  export type AgrochemicalUncheckedCreateWithoutPhytosanitaryTasksInput = {
    id?: string
    name: string
    description: string
    type: $Enums.AgrochemicalType
    porpose: $Enums.AgrochemicalPorpose
    preparation: string
    fertilizationCycles?: FertilizationCycleUncheckedCreateNestedManyWithoutAgrochemicalInput
    fertilizationTasks?: FertilizationTaskUncheckedCreateNestedManyWithoutAgrochemicalInput
    phytosanitaryCycles?: PhytosanitaryCycleUncheckedCreateNestedManyWithoutAgrochemicalInput
  }

  export type AgrochemicalCreateOrConnectWithoutPhytosanitaryTasksInput = {
    where: AgrochemicalWhereUniqueInput
    create: XOR<AgrochemicalCreateWithoutPhytosanitaryTasksInput, AgrochemicalUncheckedCreateWithoutPhytosanitaryTasksInput>
  }

  export type PhytosanitaryCycleCreateWithoutTasksInput = {
    id?: string
    sequence: number
    agrochemical: AgrochemicalCreateNestedOneWithoutPhytosanitaryCyclesInput
    program: PhytosanitaryProgramCreateNestedOneWithoutProductsCycleInput
  }

  export type PhytosanitaryCycleUncheckedCreateWithoutTasksInput = {
    id?: string
    sequence: number
    agrochemicalId: string
    programId: string
  }

  export type PhytosanitaryCycleCreateOrConnectWithoutTasksInput = {
    where: PhytosanitaryCycleWhereUniqueInput
    create: XOR<PhytosanitaryCycleCreateWithoutTasksInput, PhytosanitaryCycleUncheckedCreateWithoutTasksInput>
  }

  export type AgrochemicalUpsertWithoutPhytosanitaryTasksInput = {
    update: XOR<AgrochemicalUpdateWithoutPhytosanitaryTasksInput, AgrochemicalUncheckedUpdateWithoutPhytosanitaryTasksInput>
    create: XOR<AgrochemicalCreateWithoutPhytosanitaryTasksInput, AgrochemicalUncheckedCreateWithoutPhytosanitaryTasksInput>
    where?: AgrochemicalWhereInput
  }

  export type AgrochemicalUpdateToOneWithWhereWithoutPhytosanitaryTasksInput = {
    where?: AgrochemicalWhereInput
    data: XOR<AgrochemicalUpdateWithoutPhytosanitaryTasksInput, AgrochemicalUncheckedUpdateWithoutPhytosanitaryTasksInput>
  }

  export type AgrochemicalUpdateWithoutPhytosanitaryTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgrochemicalTypeFieldUpdateOperationsInput | $Enums.AgrochemicalType
    porpose?: EnumAgrochemicalPorposeFieldUpdateOperationsInput | $Enums.AgrochemicalPorpose
    preparation?: StringFieldUpdateOperationsInput | string
    fertilizationCycles?: FertilizationCycleUpdateManyWithoutAgrochemicalNestedInput
    fertilizationTasks?: FertilizationTaskUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryCycles?: PhytosanitaryCycleUpdateManyWithoutAgrochemicalNestedInput
  }

  export type AgrochemicalUncheckedUpdateWithoutPhytosanitaryTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgrochemicalTypeFieldUpdateOperationsInput | $Enums.AgrochemicalType
    porpose?: EnumAgrochemicalPorposeFieldUpdateOperationsInput | $Enums.AgrochemicalPorpose
    preparation?: StringFieldUpdateOperationsInput | string
    fertilizationCycles?: FertilizationCycleUncheckedUpdateManyWithoutAgrochemicalNestedInput
    fertilizationTasks?: FertilizationTaskUncheckedUpdateManyWithoutAgrochemicalNestedInput
    phytosanitaryCycles?: PhytosanitaryCycleUncheckedUpdateManyWithoutAgrochemicalNestedInput
  }

  export type PhytosanitaryCycleUpsertWithoutTasksInput = {
    update: XOR<PhytosanitaryCycleUpdateWithoutTasksInput, PhytosanitaryCycleUncheckedUpdateWithoutTasksInput>
    create: XOR<PhytosanitaryCycleCreateWithoutTasksInput, PhytosanitaryCycleUncheckedCreateWithoutTasksInput>
    where?: PhytosanitaryCycleWhereInput
  }

  export type PhytosanitaryCycleUpdateToOneWithWhereWithoutTasksInput = {
    where?: PhytosanitaryCycleWhereInput
    data: XOR<PhytosanitaryCycleUpdateWithoutTasksInput, PhytosanitaryCycleUncheckedUpdateWithoutTasksInput>
  }

  export type PhytosanitaryCycleUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemical?: AgrochemicalUpdateOneRequiredWithoutPhytosanitaryCyclesNestedInput
    program?: PhytosanitaryProgramUpdateOneRequiredWithoutProductsCycleNestedInput
  }

  export type PhytosanitaryCycleUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemicalId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
  }

  export type IrrigationTaskCreateWithoutProgramInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    actuator: $Enums.ActuatorType
    duration: number
    zones?: IrrigationTaskCreatezonesInput | $Enums.ZoneType[]
    status?: $Enums.TaskStatus
  }

  export type IrrigationTaskUncheckedCreateWithoutProgramInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    actuator: $Enums.ActuatorType
    duration: number
    zones?: IrrigationTaskCreatezonesInput | $Enums.ZoneType[]
    status?: $Enums.TaskStatus
  }

  export type IrrigationTaskCreateOrConnectWithoutProgramInput = {
    where: IrrigationTaskWhereUniqueInput
    create: XOR<IrrigationTaskCreateWithoutProgramInput, IrrigationTaskUncheckedCreateWithoutProgramInput>
  }

  export type IrrigationTaskCreateManyProgramInputEnvelope = {
    data: IrrigationTaskCreateManyProgramInput | IrrigationTaskCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type IrrigationTaskUpsertWithWhereUniqueWithoutProgramInput = {
    where: IrrigationTaskWhereUniqueInput
    update: XOR<IrrigationTaskUpdateWithoutProgramInput, IrrigationTaskUncheckedUpdateWithoutProgramInput>
    create: XOR<IrrigationTaskCreateWithoutProgramInput, IrrigationTaskUncheckedCreateWithoutProgramInput>
  }

  export type IrrigationTaskUpdateWithWhereUniqueWithoutProgramInput = {
    where: IrrigationTaskWhereUniqueInput
    data: XOR<IrrigationTaskUpdateWithoutProgramInput, IrrigationTaskUncheckedUpdateWithoutProgramInput>
  }

  export type IrrigationTaskUpdateManyWithWhereWithoutProgramInput = {
    where: IrrigationTaskScalarWhereInput
    data: XOR<IrrigationTaskUpdateManyMutationInput, IrrigationTaskUncheckedUpdateManyWithoutProgramInput>
  }

  export type IrrigationTaskScalarWhereInput = {
    AND?: IrrigationTaskScalarWhereInput | IrrigationTaskScalarWhereInput[]
    OR?: IrrigationTaskScalarWhereInput[]
    NOT?: IrrigationTaskScalarWhereInput | IrrigationTaskScalarWhereInput[]
    id?: StringFilter<"IrrigationTask"> | string
    scheduledDate?: DateTimeFilter<"IrrigationTask"> | Date | string
    executionDate?: DateTimeNullableFilter<"IrrigationTask"> | Date | string | null
    actuator?: EnumActuatorTypeFilter<"IrrigationTask"> | $Enums.ActuatorType
    duration?: IntFilter<"IrrigationTask"> | number
    zones?: EnumZoneTypeNullableListFilter<"IrrigationTask">
    status?: EnumTaskStatusFilter<"IrrigationTask"> | $Enums.TaskStatus
    programId?: StringNullableFilter<"IrrigationTask"> | string | null
  }

  export type IrrigationProgramCreateWithoutTasksInput = {
    id?: string
    name: string
    trigger?: $Enums.TriggerType
    actuator?: $Enums.ActuatorType
    startTime?: string
    duration?: number
    zones?: IrrigationProgramCreatezonesInput | $Enums.ZoneType[]
  }

  export type IrrigationProgramUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    trigger?: $Enums.TriggerType
    actuator?: $Enums.ActuatorType
    startTime?: string
    duration?: number
    zones?: IrrigationProgramCreatezonesInput | $Enums.ZoneType[]
  }

  export type IrrigationProgramCreateOrConnectWithoutTasksInput = {
    where: IrrigationProgramWhereUniqueInput
    create: XOR<IrrigationProgramCreateWithoutTasksInput, IrrigationProgramUncheckedCreateWithoutTasksInput>
  }

  export type IrrigationProgramUpsertWithoutTasksInput = {
    update: XOR<IrrigationProgramUpdateWithoutTasksInput, IrrigationProgramUncheckedUpdateWithoutTasksInput>
    create: XOR<IrrigationProgramCreateWithoutTasksInput, IrrigationProgramUncheckedCreateWithoutTasksInput>
    where?: IrrigationProgramWhereInput
  }

  export type IrrigationProgramUpdateToOneWithWhereWithoutTasksInput = {
    where?: IrrigationProgramWhereInput
    data: XOR<IrrigationProgramUpdateWithoutTasksInput, IrrigationProgramUncheckedUpdateWithoutTasksInput>
  }

  export type IrrigationProgramUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    trigger?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    actuator?: EnumActuatorTypeFieldUpdateOperationsInput | $Enums.ActuatorType
    startTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    zones?: IrrigationProgramUpdatezonesInput | $Enums.ZoneType[]
  }

  export type IrrigationProgramUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    trigger?: EnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType
    actuator?: EnumActuatorTypeFieldUpdateOperationsInput | $Enums.ActuatorType
    startTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    zones?: IrrigationProgramUpdatezonesInput | $Enums.ZoneType[]
  }

  export type SpeciesCreateManyStockInput = {
    id?: string
    name: string
    price?: number
    slug: string
    description?: string | null
    genusId: string
  }

  export type SpeciesUpdateWithoutStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genus?: GenusUpdateOneRequiredWithoutSpeciesNestedInput
    plants?: PlantUpdateManyWithoutSpeciesNestedInput
    images?: SpeciesImageUpdateManyWithoutSpeciesNestedInput
  }

  export type SpeciesUncheckedUpdateWithoutStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genusId?: StringFieldUpdateOperationsInput | string
    plants?: PlantUncheckedUpdateManyWithoutSpeciesNestedInput
    images?: SpeciesImageUncheckedUpdateManyWithoutSpeciesNestedInput
  }

  export type SpeciesUncheckedUpdateManyWithoutStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    genusId?: StringFieldUpdateOperationsInput | string
  }

  export type SpeciesCreateManyGenusInput = {
    id?: string
    name: string
    price?: number
    slug: string
    description?: string | null
    stockId: string
  }

  export type SpeciesUpdateWithoutGenusInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: StockUpdateOneRequiredWithoutSpeciesNestedInput
    plants?: PlantUpdateManyWithoutSpeciesNestedInput
    images?: SpeciesImageUpdateManyWithoutSpeciesNestedInput
  }

  export type SpeciesUncheckedUpdateWithoutGenusInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockId?: StringFieldUpdateOperationsInput | string
    plants?: PlantUncheckedUpdateManyWithoutSpeciesNestedInput
    images?: SpeciesImageUncheckedUpdateManyWithoutSpeciesNestedInput
  }

  export type SpeciesUncheckedUpdateManyWithoutGenusInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stockId?: StringFieldUpdateOperationsInput | string
  }

  export type PlantCreateManySpeciesInput = {
    id?: string
    pottingDate?: Date | string | null
    locationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpeciesImageCreateManySpeciesInput = {
    id?: string
    url: string
  }

  export type PlantUpdateWithoutSpeciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    pottingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutPlantsNestedInput
  }

  export type PlantUncheckedUpdateWithoutSpeciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    pottingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantUncheckedUpdateManyWithoutSpeciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    pottingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeciesImageUpdateWithoutSpeciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SpeciesImageUncheckedUpdateWithoutSpeciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SpeciesImageUncheckedUpdateManyWithoutSpeciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type PlantCreateManyLocationInput = {
    id?: string
    pottingDate?: Date | string | null
    speciesId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlantUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pottingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    species?: SpeciesUpdateOneRequiredWithoutPlantsNestedInput
  }

  export type PlantUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pottingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    speciesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pottingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    speciesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FertilizationCycleCreateManyAgrochemicalInput = {
    id?: string
    sequence: number
    programId: string
  }

  export type FertilizationTaskCreateManyAgrochemicalInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: FertilizationTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    productsCycleId?: string | null
  }

  export type PhytosanitaryCycleCreateManyAgrochemicalInput = {
    id?: string
    sequence: number
    programId: string
  }

  export type PhytosanitaryTaskCreateManyAgrochemicalInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: PhytosanitaryTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    productsCycleId?: string | null
  }

  export type FertilizationCycleUpdateWithoutAgrochemicalInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    program?: FertilizationProgramUpdateOneRequiredWithoutProductsCycleNestedInput
    tasks?: FertilizationTaskUpdateManyWithoutProductsCycleNestedInput
  }

  export type FertilizationCycleUncheckedUpdateWithoutAgrochemicalInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    programId?: StringFieldUpdateOperationsInput | string
    tasks?: FertilizationTaskUncheckedUpdateManyWithoutProductsCycleNestedInput
  }

  export type FertilizationCycleUncheckedUpdateManyWithoutAgrochemicalInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    programId?: StringFieldUpdateOperationsInput | string
  }

  export type FertilizationTaskUpdateWithoutAgrochemicalInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: FertilizationTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    productsCycle?: FertilizationCycleUpdateOneWithoutTasksNestedInput
  }

  export type FertilizationTaskUncheckedUpdateWithoutAgrochemicalInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: FertilizationTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    productsCycleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FertilizationTaskUncheckedUpdateManyWithoutAgrochemicalInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: FertilizationTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    productsCycleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhytosanitaryCycleUpdateWithoutAgrochemicalInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    program?: PhytosanitaryProgramUpdateOneRequiredWithoutProductsCycleNestedInput
    tasks?: PhytosanitaryTaskUpdateManyWithoutProductsCycleNestedInput
  }

  export type PhytosanitaryCycleUncheckedUpdateWithoutAgrochemicalInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    programId?: StringFieldUpdateOperationsInput | string
    tasks?: PhytosanitaryTaskUncheckedUpdateManyWithoutProductsCycleNestedInput
  }

  export type PhytosanitaryCycleUncheckedUpdateManyWithoutAgrochemicalInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    programId?: StringFieldUpdateOperationsInput | string
  }

  export type PhytosanitaryTaskUpdateWithoutAgrochemicalInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: PhytosanitaryTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    productsCycle?: PhytosanitaryCycleUpdateOneWithoutTasksNestedInput
  }

  export type PhytosanitaryTaskUncheckedUpdateWithoutAgrochemicalInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: PhytosanitaryTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    productsCycleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhytosanitaryTaskUncheckedUpdateManyWithoutAgrochemicalInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: PhytosanitaryTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    productsCycleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FertilizationCycleCreateManyProgramInput = {
    id?: string
    sequence: number
    agrochemicalId: string
  }

  export type FertilizationCycleUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemical?: AgrochemicalUpdateOneRequiredWithoutFertilizationCyclesNestedInput
    tasks?: FertilizationTaskUpdateManyWithoutProductsCycleNestedInput
  }

  export type FertilizationCycleUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemicalId?: StringFieldUpdateOperationsInput | string
    tasks?: FertilizationTaskUncheckedUpdateManyWithoutProductsCycleNestedInput
  }

  export type FertilizationCycleUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemicalId?: StringFieldUpdateOperationsInput | string
  }

  export type FertilizationTaskCreateManyProductsCycleInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: FertilizationTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    agrochemicalId: string
  }

  export type FertilizationTaskUpdateWithoutProductsCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: FertilizationTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    agrochemical?: AgrochemicalUpdateOneRequiredWithoutFertilizationTasksNestedInput
  }

  export type FertilizationTaskUncheckedUpdateWithoutProductsCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: FertilizationTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    agrochemicalId?: StringFieldUpdateOperationsInput | string
  }

  export type FertilizationTaskUncheckedUpdateManyWithoutProductsCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: FertilizationTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    agrochemicalId?: StringFieldUpdateOperationsInput | string
  }

  export type PhytosanitaryCycleCreateManyProgramInput = {
    id?: string
    sequence: number
    agrochemicalId: string
  }

  export type PhytosanitaryCycleUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemical?: AgrochemicalUpdateOneRequiredWithoutPhytosanitaryCyclesNestedInput
    tasks?: PhytosanitaryTaskUpdateManyWithoutProductsCycleNestedInput
  }

  export type PhytosanitaryCycleUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemicalId?: StringFieldUpdateOperationsInput | string
    tasks?: PhytosanitaryTaskUncheckedUpdateManyWithoutProductsCycleNestedInput
  }

  export type PhytosanitaryCycleUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    agrochemicalId?: StringFieldUpdateOperationsInput | string
  }

  export type PhytosanitaryTaskCreateManyProductsCycleInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    zones?: PhytosanitaryTaskCreatezonesInput | $Enums.ZoneType[]
    note?: string | null
    status?: $Enums.TaskStatus
    agrochemicalId: string
  }

  export type PhytosanitaryTaskUpdateWithoutProductsCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: PhytosanitaryTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    agrochemical?: AgrochemicalUpdateOneRequiredWithoutPhytosanitaryTasksNestedInput
  }

  export type PhytosanitaryTaskUncheckedUpdateWithoutProductsCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: PhytosanitaryTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    agrochemicalId?: StringFieldUpdateOperationsInput | string
  }

  export type PhytosanitaryTaskUncheckedUpdateManyWithoutProductsCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zones?: PhytosanitaryTaskUpdatezonesInput | $Enums.ZoneType[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    agrochemicalId?: StringFieldUpdateOperationsInput | string
  }

  export type IrrigationTaskCreateManyProgramInput = {
    id?: string
    scheduledDate: Date | string
    executionDate?: Date | string | null
    actuator: $Enums.ActuatorType
    duration: number
    zones?: IrrigationTaskCreatezonesInput | $Enums.ZoneType[]
    status?: $Enums.TaskStatus
  }

  export type IrrigationTaskUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actuator?: EnumActuatorTypeFieldUpdateOperationsInput | $Enums.ActuatorType
    duration?: IntFieldUpdateOperationsInput | number
    zones?: IrrigationTaskUpdatezonesInput | $Enums.ZoneType[]
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
  }

  export type IrrigationTaskUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actuator?: EnumActuatorTypeFieldUpdateOperationsInput | $Enums.ActuatorType
    duration?: IntFieldUpdateOperationsInput | number
    zones?: IrrigationTaskUpdatezonesInput | $Enums.ZoneType[]
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
  }

  export type IrrigationTaskUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actuator?: EnumActuatorTypeFieldUpdateOperationsInput | $Enums.ActuatorType
    duration?: IntFieldUpdateOperationsInput | number
    zones?: IrrigationTaskUpdatezonesInput | $Enums.ZoneType[]
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}